/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 1.3.8
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://esi.evetech.net/latest';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Bad request model
*/
export class BadRequest {
    /**
    * Bad request message
    */
    'error': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BadRequest.attributeTypeMap;
    }
}

/**
* Unprocessable entity
*/
export class DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity.attributeTypeMap;
    }
}

/**
* Not found
*/
export class DeleteFleetsFleetIdMembersMemberIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteFleetsFleetIdMembersMemberIdNotFound.attributeTypeMap;
    }
}

/**
* Not found
*/
export class DeleteFleetsFleetIdSquadsSquadIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteFleetsFleetIdSquadsSquadIdNotFound.attributeTypeMap;
    }
}

/**
* Not found
*/
export class DeleteFleetsFleetIdWingsWingIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteFleetsFleetIdWingsWingIdNotFound.attributeTypeMap;
    }
}

/**
* Error limited model
*/
export class ErrorLimited {
    /**
    * Error limited message
    */
    'error': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErrorLimited.attributeTypeMap;
    }
}

/**
* Forbidden model
*/
export class Forbidden {
    /**
    * Forbidden message
    */
    'error': string;
    /**
    * status code received from SSO
    */
    'ssoStatus'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "ssoStatus",
            "baseName": "sso_status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Forbidden.attributeTypeMap;
    }
}

/**
* Gateway timeout model
*/
export class GatewayTimeout {
    /**
    * Gateway timeout message
    */
    'error': string;
    /**
    * number of seconds the request was given
    */
    'timeout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GatewayTimeout.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdContacts200Ok {
    /**
    * contact_id integer
    */
    'contactId': number;
    /**
    * contact_type string
    */
    'contactType': GetAlliancesAllianceIdContacts200Ok.ContactTypeEnum;
    /**
    * label_ids array
    */
    'labelIds'?: Array<number>;
    /**
    * Standing of the contact
    */
    'standing': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contactId",
            "baseName": "contact_id",
            "type": "number"
        },
        {
            "name": "contactType",
            "baseName": "contact_type",
            "type": "GetAlliancesAllianceIdContacts200Ok.ContactTypeEnum"
        },
        {
            "name": "labelIds",
            "baseName": "label_ids",
            "type": "Array<number>"
        },
        {
            "name": "standing",
            "baseName": "standing",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetAlliancesAllianceIdContacts200Ok.attributeTypeMap;
    }
}

export namespace GetAlliancesAllianceIdContacts200Ok {
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}
/**
* 200 ok object
*/
export class GetAlliancesAllianceIdContactsLabels200Ok {
    /**
    * label_id integer
    */
    'labelId': number;
    /**
    * label_name string
    */
    'labelName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "labelId",
            "baseName": "label_id",
            "type": "number"
        },
        {
            "name": "labelName",
            "baseName": "label_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAlliancesAllianceIdContactsLabels200Ok.attributeTypeMap;
    }
}

/**
* No image server for this datasource
*/
export class GetAlliancesAllianceIdIconsNotFound {
    /**
    * error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAlliancesAllianceIdIconsNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdIconsOk {
    /**
    * px128x128 string
    */
    'px128x128'?: string;
    /**
    * px64x64 string
    */
    'px64x64'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "px128x128",
            "baseName": "px128x128",
            "type": "string"
        },
        {
            "name": "px64x64",
            "baseName": "px64x64",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAlliancesAllianceIdIconsOk.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetAlliancesAllianceIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAlliancesAllianceIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdOk {
    /**
    * ID of the corporation that created the alliance
    */
    'creatorCorporationId': number;
    /**
    * ID of the character that created the alliance
    */
    'creatorId': number;
    /**
    * date_founded string
    */
    'dateFounded': Date;
    /**
    * the executor corporation ID, if this alliance is not closed
    */
    'executorCorporationId'?: number;
    /**
    * Faction ID this alliance is fighting for, if this alliance is enlisted in factional warfare
    */
    'factionId'?: number;
    /**
    * the full name of the alliance
    */
    'name': string;
    /**
    * the short name of the alliance
    */
    'ticker': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creatorCorporationId",
            "baseName": "creator_corporation_id",
            "type": "number"
        },
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "number"
        },
        {
            "name": "dateFounded",
            "baseName": "date_founded",
            "type": "Date"
        },
        {
            "name": "executorCorporationId",
            "baseName": "executor_corporation_id",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAlliancesAllianceIdOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdAgentsResearch200Ok {
    /**
    * agent_id integer
    */
    'agentId': number;
    /**
    * points_per_day number
    */
    'pointsPerDay': number;
    /**
    * remainder_points number
    */
    'remainderPoints': number;
    /**
    * skill_type_id integer
    */
    'skillTypeId': number;
    /**
    * started_at string
    */
    'startedAt': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agentId",
            "baseName": "agent_id",
            "type": "number"
        },
        {
            "name": "pointsPerDay",
            "baseName": "points_per_day",
            "type": "number"
        },
        {
            "name": "remainderPoints",
            "baseName": "remainder_points",
            "type": "number"
        },
        {
            "name": "skillTypeId",
            "baseName": "skill_type_id",
            "type": "number"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdAgentsResearch200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdAssets200Ok {
    /**
    * is_blueprint_copy boolean
    */
    'isBlueprintCopy'?: boolean;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * location_flag string
    */
    'locationFlag': GetCharactersCharacterIdAssets200Ok.LocationFlagEnum;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdAssets200Ok.LocationTypeEnum;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isBlueprintCopy",
            "baseName": "is_blueprint_copy",
            "type": "boolean"
        },
        {
            "name": "isSingleton",
            "baseName": "is_singleton",
            "type": "boolean"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "locationFlag",
            "baseName": "location_flag",
            "type": "GetCharactersCharacterIdAssets200Ok.LocationFlagEnum"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "locationType",
            "baseName": "location_type",
            "type": "GetCharactersCharacterIdAssets200Ok.LocationTypeEnum"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdAssets200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdAssets200Ok {
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        BoosterBay = <any> 'BoosterBay',
        Cargo = <any> 'Cargo',
        CorpseBay = <any> 'CorpseBay',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        QuafeBay = <any> 'QuafeBay',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        ShipHangar = <any> 'ShipHangar',
        Skill = <any> 'Skill',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wardrobe = <any> 'Wardrobe'
    }
    export enum LocationTypeEnum {
        Station = <any> 'station',
        SolarSystem = <any> 'solar_system',
        Item = <any> 'item',
        Other = <any> 'other'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdAttributesOk {
    /**
    * Neural remapping cooldown after a character uses remap accrued over time
    */
    'accruedRemapCooldownDate'?: Date;
    /**
    * Number of available bonus character neural remaps
    */
    'bonusRemaps'?: number;
    /**
    * charisma integer
    */
    'charisma': number;
    /**
    * intelligence integer
    */
    'intelligence': number;
    /**
    * Datetime of last neural remap, including usage of bonus remaps
    */
    'lastRemapDate'?: Date;
    /**
    * memory integer
    */
    'memory': number;
    /**
    * perception integer
    */
    'perception': number;
    /**
    * willpower integer
    */
    'willpower': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accruedRemapCooldownDate",
            "baseName": "accrued_remap_cooldown_date",
            "type": "Date"
        },
        {
            "name": "bonusRemaps",
            "baseName": "bonus_remaps",
            "type": "number"
        },
        {
            "name": "charisma",
            "baseName": "charisma",
            "type": "number"
        },
        {
            "name": "intelligence",
            "baseName": "intelligence",
            "type": "number"
        },
        {
            "name": "lastRemapDate",
            "baseName": "last_remap_date",
            "type": "Date"
        },
        {
            "name": "memory",
            "baseName": "memory",
            "type": "number"
        },
        {
            "name": "perception",
            "baseName": "perception",
            "type": "number"
        },
        {
            "name": "willpower",
            "baseName": "willpower",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdAttributesOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdBlueprints200Ok {
    /**
    * Unique ID for this item.
    */
    'itemId': number;
    /**
    * Type of the location_id
    */
    'locationFlag': GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum;
    /**
    * References a station, a ship or an item_id if this blueprint is located within a container. If the return value is an item_id, then the Character AssetList API must be queried to find the container using the given item_id to determine the correct location of the Blueprint.
    */
    'locationId': number;
    /**
    * Material Efficiency Level of the blueprint.
    */
    'materialEfficiency': number;
    /**
    * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
    */
    'quantity': number;
    /**
    * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
    */
    'runs': number;
    /**
    * Time Efficiency Level of the blueprint.
    */
    'timeEfficiency': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "locationFlag",
            "baseName": "location_flag",
            "type": "GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "materialEfficiency",
            "baseName": "material_efficiency",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "runs",
            "baseName": "runs",
            "type": "number"
        },
        {
            "name": "timeEfficiency",
            "baseName": "time_efficiency",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdBlueprints200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdBlueprints200Ok {
    export enum LocationFlagEnum {
        AutoFit = <any> 'AutoFit',
        Cargo = <any> 'Cargo',
        CorpseBay = <any> 'CorpseBay',
        DroneBay = <any> 'DroneBay',
        FleetHangar = <any> 'FleetHangar',
        Deliveries = <any> 'Deliveries',
        HiddenModifiers = <any> 'HiddenModifiers',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        AssetSafety = <any> 'AssetSafety',
        Locked = <any> 'Locked',
        Unlocked = <any> 'Unlocked',
        Implant = <any> 'Implant',
        QuafeBay = <any> 'QuafeBay',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        ShipHangar = <any> 'ShipHangar',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        Module = <any> 'Module'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdBookmarks200Ok {
    /**
    * bookmark_id integer
    */
    'bookmarkId': number;
    'coordinates'?: GetCharactersCharacterIdBookmarksCoordinates;
    /**
    * created string
    */
    'created': Date;
    /**
    * creator_id integer
    */
    'creatorId': number;
    /**
    * folder_id integer
    */
    'folderId'?: number;
    'item'?: GetCharactersCharacterIdBookmarksItem;
    /**
    * label string
    */
    'label': string;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * notes string
    */
    'notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bookmarkId",
            "baseName": "bookmark_id",
            "type": "number"
        },
        {
            "name": "coordinates",
            "baseName": "coordinates",
            "type": "GetCharactersCharacterIdBookmarksCoordinates"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "number"
        },
        {
            "name": "folderId",
            "baseName": "folder_id",
            "type": "number"
        },
        {
            "name": "item",
            "baseName": "item",
            "type": "GetCharactersCharacterIdBookmarksItem"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdBookmarks200Ok.attributeTypeMap;
    }
}

/**
* Optional object that is returned if a bookmark was made on a planet or a random location in space.
*/
export class GetCharactersCharacterIdBookmarksCoordinates {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdBookmarksCoordinates.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdBookmarksFolders200Ok {
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "folderId",
            "baseName": "folder_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdBookmarksFolders200Ok.attributeTypeMap;
    }
}

/**
* Optional object that is returned if a bookmark was made on a particular item.
*/
export class GetCharactersCharacterIdBookmarksItem {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdBookmarksItem.attributeTypeMap;
    }
}

/**
* event
*/
export class GetCharactersCharacterIdCalendar200Ok {
    /**
    * event_date string
    */
    'eventDate'?: Date;
    /**
    * event_id integer
    */
    'eventId'?: number;
    /**
    * event_response string
    */
    'eventResponse'?: GetCharactersCharacterIdCalendar200Ok.EventResponseEnum;
    /**
    * importance integer
    */
    'importance'?: number;
    /**
    * title string
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventDate",
            "baseName": "event_date",
            "type": "Date"
        },
        {
            "name": "eventId",
            "baseName": "event_id",
            "type": "number"
        },
        {
            "name": "eventResponse",
            "baseName": "event_response",
            "type": "GetCharactersCharacterIdCalendar200Ok.EventResponseEnum"
        },
        {
            "name": "importance",
            "baseName": "importance",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdCalendar200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdCalendar200Ok {
    export enum EventResponseEnum {
        Declined = <any> 'declined',
        NotResponded = <any> 'not_responded',
        Accepted = <any> 'accepted',
        Tentative = <any> 'tentative'
    }
}
/**
* character_id and response of an attendee
*/
export class GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
    /**
    * character_id integer
    */
    'characterId'?: number;
    /**
    * event_response string
    */
    'eventResponse'?: GetCharactersCharacterIdCalendarEventIdAttendees200Ok.EventResponseEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "eventResponse",
            "baseName": "event_response",
            "type": "GetCharactersCharacterIdCalendarEventIdAttendees200Ok.EventResponseEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdCalendarEventIdAttendees200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
    export enum EventResponseEnum {
        Declined = <any> 'declined',
        NotResponded = <any> 'not_responded',
        Accepted = <any> 'accepted',
        Tentative = <any> 'tentative'
    }
}
/**
* Not found
*/
export class GetCharactersCharacterIdCalendarEventIdAttendeesNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdCalendarEventIdAttendeesNotFound.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCharactersCharacterIdCalendarEventIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdCalendarEventIdNotFound.attributeTypeMap;
    }
}

/**
* Full details of a specific event
*/
export class GetCharactersCharacterIdCalendarEventIdOk {
    /**
    * date string
    */
    'date': Date;
    /**
    * Length in minutes
    */
    'duration': number;
    /**
    * event_id integer
    */
    'eventId': number;
    /**
    * importance integer
    */
    'importance': number;
    /**
    * owner_id integer
    */
    'ownerId': number;
    /**
    * owner_name string
    */
    'ownerName': string;
    /**
    * owner_type string
    */
    'ownerType': GetCharactersCharacterIdCalendarEventIdOk.OwnerTypeEnum;
    /**
    * response string
    */
    'response': string;
    /**
    * text string
    */
    'text': string;
    /**
    * title string
    */
    'title': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "eventId",
            "baseName": "event_id",
            "type": "number"
        },
        {
            "name": "importance",
            "baseName": "importance",
            "type": "number"
        },
        {
            "name": "ownerId",
            "baseName": "owner_id",
            "type": "number"
        },
        {
            "name": "ownerName",
            "baseName": "owner_name",
            "type": "string"
        },
        {
            "name": "ownerType",
            "baseName": "owner_type",
            "type": "GetCharactersCharacterIdCalendarEventIdOk.OwnerTypeEnum"
        },
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdCalendarEventIdOk.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdCalendarEventIdOk {
    export enum OwnerTypeEnum {
        EveServer = <any> 'eve_server',
        Corporation = <any> 'corporation',
        Faction = <any> 'faction',
        Character = <any> 'character',
        Alliance = <any> 'alliance'
    }
}
/**
* home_location object
*/
export class GetCharactersCharacterIdClonesHomeLocation {
    /**
    * location_id integer
    */
    'locationId'?: number;
    /**
    * location_type string
    */
    'locationType'?: GetCharactersCharacterIdClonesHomeLocation.LocationTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "locationType",
            "baseName": "location_type",
            "type": "GetCharactersCharacterIdClonesHomeLocation.LocationTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdClonesHomeLocation.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdClonesHomeLocation {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}
/**
* jump_clone object
*/
export class GetCharactersCharacterIdClonesJumpClone {
    /**
    * implants array
    */
    'implants': Array<number>;
    /**
    * jump_clone_id integer
    */
    'jumpCloneId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdClonesJumpClone.LocationTypeEnum;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "implants",
            "baseName": "implants",
            "type": "Array<number>"
        },
        {
            "name": "jumpCloneId",
            "baseName": "jump_clone_id",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "locationType",
            "baseName": "location_type",
            "type": "GetCharactersCharacterIdClonesJumpClone.LocationTypeEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdClonesJumpClone.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdClonesJumpClone {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdClonesOk {
    'homeLocation'?: GetCharactersCharacterIdClonesHomeLocation;
    /**
    * jump_clones array
    */
    'jumpClones': Array<GetCharactersCharacterIdClonesJumpClone>;
    /**
    * last_clone_jump_date string
    */
    'lastCloneJumpDate'?: Date;
    /**
    * last_station_change_date string
    */
    'lastStationChangeDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "homeLocation",
            "baseName": "home_location",
            "type": "GetCharactersCharacterIdClonesHomeLocation"
        },
        {
            "name": "jumpClones",
            "baseName": "jump_clones",
            "type": "Array<GetCharactersCharacterIdClonesJumpClone>"
        },
        {
            "name": "lastCloneJumpDate",
            "baseName": "last_clone_jump_date",
            "type": "Date"
        },
        {
            "name": "lastStationChangeDate",
            "baseName": "last_station_change_date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdClonesOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdContacts200Ok {
    /**
    * contact_id integer
    */
    'contactId': number;
    /**
    * contact_type string
    */
    'contactType': GetCharactersCharacterIdContacts200Ok.ContactTypeEnum;
    /**
    * Whether this contact is in the blocked list. Note a missing value denotes unknown, not true or false
    */
    'isBlocked'?: boolean;
    /**
    * Whether this contact is being watched
    */
    'isWatched'?: boolean;
    /**
    * label_ids array
    */
    'labelIds'?: Array<number>;
    /**
    * Standing of the contact
    */
    'standing': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contactId",
            "baseName": "contact_id",
            "type": "number"
        },
        {
            "name": "contactType",
            "baseName": "contact_type",
            "type": "GetCharactersCharacterIdContacts200Ok.ContactTypeEnum"
        },
        {
            "name": "isBlocked",
            "baseName": "is_blocked",
            "type": "boolean"
        },
        {
            "name": "isWatched",
            "baseName": "is_watched",
            "type": "boolean"
        },
        {
            "name": "labelIds",
            "baseName": "label_ids",
            "type": "Array<number>"
        },
        {
            "name": "standing",
            "baseName": "standing",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdContacts200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdContacts200Ok {
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdContactsLabels200Ok {
    /**
    * label_id integer
    */
    'labelId': number;
    /**
    * label_name string
    */
    'labelName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "labelId",
            "baseName": "label_id",
            "type": "number"
        },
        {
            "name": "labelName",
            "baseName": "label_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdContactsLabels200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdContracts200Ok {
    /**
    * Who will accept the contract
    */
    'acceptorId': number;
    /**
    * ID to whom the contract is assigned, can be corporation or character ID
    */
    'assigneeId': number;
    /**
    * To whom the contract is available
    */
    'availability': GetCharactersCharacterIdContracts200Ok.AvailabilityEnum;
    /**
    * Buyout price (for Auctions only)
    */
    'buyout'?: number;
    /**
    * Collateral price (for Couriers only)
    */
    'collateral'?: number;
    /**
    * contract_id integer
    */
    'contractId': number;
    /**
    * Date of confirmation of contract
    */
    'dateAccepted'?: Date;
    /**
    * Date of completed of contract
    */
    'dateCompleted'?: Date;
    /**
    * Expiration date of the contract
    */
    'dateExpired': Date;
    /**
    * Сreation date of the contract
    */
    'dateIssued': Date;
    /**
    * Number of days to perform the contract
    */
    'daysToComplete'?: number;
    /**
    * End location ID (for Couriers contract)
    */
    'endLocationId'?: number;
    /**
    * true if the contract was issued on behalf of the issuer's corporation
    */
    'forCorporation': boolean;
    /**
    * Character's corporation ID for the issuer
    */
    'issuerCorporationId': number;
    /**
    * Character ID for the issuer
    */
    'issuerId': number;
    /**
    * Price of contract (for ItemsExchange and Auctions)
    */
    'price'?: number;
    /**
    * Remuneration for contract (for Couriers only)
    */
    'reward'?: number;
    /**
    * Start location ID (for Couriers contract)
    */
    'startLocationId'?: number;
    /**
    * Status of the the contract
    */
    'status': GetCharactersCharacterIdContracts200Ok.StatusEnum;
    /**
    * Title of the contract
    */
    'title'?: string;
    /**
    * Type of the contract
    */
    'type': GetCharactersCharacterIdContracts200Ok.TypeEnum;
    /**
    * Volume of items in the contract
    */
    'volume'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acceptorId",
            "baseName": "acceptor_id",
            "type": "number"
        },
        {
            "name": "assigneeId",
            "baseName": "assignee_id",
            "type": "number"
        },
        {
            "name": "availability",
            "baseName": "availability",
            "type": "GetCharactersCharacterIdContracts200Ok.AvailabilityEnum"
        },
        {
            "name": "buyout",
            "baseName": "buyout",
            "type": "number"
        },
        {
            "name": "collateral",
            "baseName": "collateral",
            "type": "number"
        },
        {
            "name": "contractId",
            "baseName": "contract_id",
            "type": "number"
        },
        {
            "name": "dateAccepted",
            "baseName": "date_accepted",
            "type": "Date"
        },
        {
            "name": "dateCompleted",
            "baseName": "date_completed",
            "type": "Date"
        },
        {
            "name": "dateExpired",
            "baseName": "date_expired",
            "type": "Date"
        },
        {
            "name": "dateIssued",
            "baseName": "date_issued",
            "type": "Date"
        },
        {
            "name": "daysToComplete",
            "baseName": "days_to_complete",
            "type": "number"
        },
        {
            "name": "endLocationId",
            "baseName": "end_location_id",
            "type": "number"
        },
        {
            "name": "forCorporation",
            "baseName": "for_corporation",
            "type": "boolean"
        },
        {
            "name": "issuerCorporationId",
            "baseName": "issuer_corporation_id",
            "type": "number"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "reward",
            "baseName": "reward",
            "type": "number"
        },
        {
            "name": "startLocationId",
            "baseName": "start_location_id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCharactersCharacterIdContracts200Ok.StatusEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetCharactersCharacterIdContracts200Ok.TypeEnum"
        },
        {
            "name": "volume",
            "baseName": "volume",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdContracts200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdContracts200Ok {
    export enum AvailabilityEnum {
        Public = <any> 'public',
        Personal = <any> 'personal',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
    export enum StatusEnum {
        Outstanding = <any> 'outstanding',
        InProgress = <any> 'in_progress',
        FinishedIssuer = <any> 'finished_issuer',
        FinishedContractor = <any> 'finished_contractor',
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Rejected = <any> 'rejected',
        Failed = <any> 'failed',
        Deleted = <any> 'deleted',
        Reversed = <any> 'reversed'
    }
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdContractsContractIdBids200Ok {
    /**
    * The amount bid, in ISK
    */
    'amount': number;
    /**
    * Unique ID for the bid
    */
    'bidId': number;
    /**
    * Character ID of the bidder
    */
    'bidderId': number;
    /**
    * Datetime when the bid was placed
    */
    'dateBid': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "bidId",
            "baseName": "bid_id",
            "type": "number"
        },
        {
            "name": "bidderId",
            "baseName": "bidder_id",
            "type": "number"
        },
        {
            "name": "dateBid",
            "baseName": "date_bid",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdContractsContractIdBids200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCharactersCharacterIdContractsContractIdBidsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdContractsContractIdBidsNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdContractsContractIdItems200Ok {
    /**
    * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
    */
    'isIncluded': boolean;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
    /**
    * Number of items in the stack
    */
    'quantity': number;
    /**
    * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
    */
    'rawQuantity'?: number;
    /**
    * Unique ID for the item
    */
    'recordId': number;
    /**
    * Type ID for item
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isIncluded",
            "baseName": "is_included",
            "type": "boolean"
        },
        {
            "name": "isSingleton",
            "baseName": "is_singleton",
            "type": "boolean"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "rawQuantity",
            "baseName": "raw_quantity",
            "type": "number"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdContractsContractIdItems200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCharactersCharacterIdContractsContractIdItemsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdContractsContractIdItemsNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdCorporationhistory200Ok {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * True if the corporation has been deleted
    */
    'isDeleted'?: boolean;
    /**
    * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
    */
    'recordId': number;
    /**
    * start_date string
    */
    'startDate': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "isDeleted",
            "baseName": "is_deleted",
            "type": "boolean"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdCorporationhistory200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFatigueOk {
    /**
    * Character's jump fatigue expiry
    */
    'jumpFatigueExpireDate'?: Date;
    /**
    * Character's last jump activation
    */
    'lastJumpDate'?: Date;
    /**
    * Character's last jump update
    */
    'lastUpdateDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jumpFatigueExpireDate",
            "baseName": "jump_fatigue_expire_date",
            "type": "Date"
        },
        {
            "name": "lastJumpDate",
            "baseName": "last_jump_date",
            "type": "Date"
        },
        {
            "name": "lastUpdateDate",
            "baseName": "last_update_date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFatigueOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFittings200Ok {
    /**
    * description string
    */
    'description': string;
    /**
    * fitting_id integer
    */
    'fittingId': number;
    /**
    * items array
    */
    'items': Array<GetCharactersCharacterIdFittingsItem>;
    /**
    * name string
    */
    'name': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fittingId",
            "baseName": "fitting_id",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<GetCharactersCharacterIdFittingsItem>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFittings200Ok.attributeTypeMap;
    }
}

/**
* item object
*/
export class GetCharactersCharacterIdFittingsItem {
    /**
    * flag string
    */
    'flag': GetCharactersCharacterIdFittingsItem.FlagEnum;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "flag",
            "baseName": "flag",
            "type": "GetCharactersCharacterIdFittingsItem.FlagEnum"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFittingsItem.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdFittingsItem {
    export enum FlagEnum {
        Cargo = <any> 'Cargo',
        DroneBay = <any> 'DroneBay',
        FighterBay = <any> 'FighterBay',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        Invalid = <any> 'Invalid',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3'
    }
}
/**
* Not found
*/
export class GetCharactersCharacterIdFleetNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFleetNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFleetOk {
    /**
    * The character's current fleet ID
    */
    'fleetId': number;
    /**
    * Member’s role in fleet
    */
    'role': GetCharactersCharacterIdFleetOk.RoleEnum;
    /**
    * ID of the squad the member is in. If not applicable, will be set to -1
    */
    'squadId': number;
    /**
    * ID of the wing the member is in. If not applicable, will be set to -1
    */
    'wingId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fleetId",
            "baseName": "fleet_id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "GetCharactersCharacterIdFleetOk.RoleEnum"
        },
        {
            "name": "squadId",
            "baseName": "squad_id",
            "type": "number"
        },
        {
            "name": "wingId",
            "baseName": "wing_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFleetOk.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdFleetOk {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member',
        WingCommander = <any> 'wing_commander'
    }
}
/**
* Summary of kills done by the given character against enemy factions
*/
export class GetCharactersCharacterIdFwStatsKills {
    /**
    * Last week's total number of kills by a given character against enemy factions
    */
    'lastWeek': number;
    /**
    * Total number of kills by a given character against enemy factions since the character enlisted
    */
    'total': number;
    /**
    * Yesterday's total number of kills by a given character against enemy factions
    */
    'yesterday': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFwStatsKills.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFwStatsOk {
    /**
    * The given character's current faction rank
    */
    'currentRank'?: number;
    /**
    * The enlistment date of the given character into faction warfare. Will not be included if character is not enlisted in faction warfare
    */
    'enlistedOn'?: Date;
    /**
    * The faction the given character is enlisted to fight for. Will not be included if character is not enlisted in faction warfare
    */
    'factionId'?: number;
    /**
    * The given character's highest faction rank achieved
    */
    'highestRank'?: number;
    'kills': GetCharactersCharacterIdFwStatsKills;
    'victoryPoints': GetCharactersCharacterIdFwStatsVictoryPoints;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currentRank",
            "baseName": "current_rank",
            "type": "number"
        },
        {
            "name": "enlistedOn",
            "baseName": "enlisted_on",
            "type": "Date"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "highestRank",
            "baseName": "highest_rank",
            "type": "number"
        },
        {
            "name": "kills",
            "baseName": "kills",
            "type": "GetCharactersCharacterIdFwStatsKills"
        },
        {
            "name": "victoryPoints",
            "baseName": "victory_points",
            "type": "GetCharactersCharacterIdFwStatsVictoryPoints"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFwStatsOk.attributeTypeMap;
    }
}

/**
* Summary of victory points gained by the given character for the enlisted faction
*/
export class GetCharactersCharacterIdFwStatsVictoryPoints {
    /**
    * Last week's victory points gained by the given character
    */
    'lastWeek': number;
    /**
    * Total victory points gained since the given character enlisted
    */
    'total': number;
    /**
    * Yesterday's victory points gained by the given character
    */
    'yesterday': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdFwStatsVictoryPoints.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdIndustryJobs200Ok {
    /**
    * Job activity ID
    */
    'activityId': number;
    /**
    * blueprint_id integer
    */
    'blueprintId': number;
    /**
    * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
    */
    'blueprintLocationId': number;
    /**
    * blueprint_type_id integer
    */
    'blueprintTypeId': number;
    /**
    * ID of the character which completed this job
    */
    'completedCharacterId'?: number;
    /**
    * Date and time when this job was completed
    */
    'completedDate'?: Date;
    /**
    * The sume of job installation fee and industry facility tax
    */
    'cost'?: number;
    /**
    * Job duration in seconds
    */
    'duration': number;
    /**
    * Date and time when this job finished
    */
    'endDate': Date;
    /**
    * ID of the facility where this job is running
    */
    'facilityId': number;
    /**
    * ID of the character which installed this job
    */
    'installerId': number;
    /**
    * Unique job ID
    */
    'jobId': number;
    /**
    * Number of runs blueprint is licensed for
    */
    'licensedRuns'?: number;
    /**
    * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
    */
    'outputLocationId': number;
    /**
    * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
    */
    'pauseDate'?: Date;
    /**
    * Chance of success for invention
    */
    'probability'?: number;
    /**
    * Type ID of product (manufactured, copied or invented)
    */
    'productTypeId'?: number;
    /**
    * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
    */
    'runs': number;
    /**
    * Date and time when this job started
    */
    'startDate': Date;
    /**
    * ID of the station where industry facility is located
    */
    'stationId': number;
    /**
    * status string
    */
    'status': GetCharactersCharacterIdIndustryJobs200Ok.StatusEnum;
    /**
    * Number of successful runs for this job. Equal to runs unless this is an invention job
    */
    'successfulRuns'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activityId",
            "baseName": "activity_id",
            "type": "number"
        },
        {
            "name": "blueprintId",
            "baseName": "blueprint_id",
            "type": "number"
        },
        {
            "name": "blueprintLocationId",
            "baseName": "blueprint_location_id",
            "type": "number"
        },
        {
            "name": "blueprintTypeId",
            "baseName": "blueprint_type_id",
            "type": "number"
        },
        {
            "name": "completedCharacterId",
            "baseName": "completed_character_id",
            "type": "number"
        },
        {
            "name": "completedDate",
            "baseName": "completed_date",
            "type": "Date"
        },
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "Date"
        },
        {
            "name": "facilityId",
            "baseName": "facility_id",
            "type": "number"
        },
        {
            "name": "installerId",
            "baseName": "installer_id",
            "type": "number"
        },
        {
            "name": "jobId",
            "baseName": "job_id",
            "type": "number"
        },
        {
            "name": "licensedRuns",
            "baseName": "licensed_runs",
            "type": "number"
        },
        {
            "name": "outputLocationId",
            "baseName": "output_location_id",
            "type": "number"
        },
        {
            "name": "pauseDate",
            "baseName": "pause_date",
            "type": "Date"
        },
        {
            "name": "probability",
            "baseName": "probability",
            "type": "number"
        },
        {
            "name": "productTypeId",
            "baseName": "product_type_id",
            "type": "number"
        },
        {
            "name": "runs",
            "baseName": "runs",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "stationId",
            "baseName": "station_id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCharactersCharacterIdIndustryJobs200Ok.StatusEnum"
        },
        {
            "name": "successfulRuns",
            "baseName": "successful_runs",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdIndustryJobs200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdIndustryJobs200Ok {
    export enum StatusEnum {
        Active = <any> 'active',
        Cancelled = <any> 'cancelled',
        Delivered = <any> 'delivered',
        Paused = <any> 'paused',
        Ready = <any> 'ready',
        Reverted = <any> 'reverted'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdKillmailsRecent200Ok {
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
    /**
    * ID of this killmail
    */
    'killmailId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "killmailHash",
            "baseName": "killmail_hash",
            "type": "string"
        },
        {
            "name": "killmailId",
            "baseName": "killmail_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdKillmailsRecent200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdLocationOk {
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * station_id integer
    */
    'stationId'?: number;
    /**
    * structure_id integer
    */
    'structureId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "stationId",
            "baseName": "station_id",
            "type": "number"
        },
        {
            "name": "structureId",
            "baseName": "structure_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdLocationOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdLoyaltyPoints200Ok {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * loyalty_points integer
    */
    'loyaltyPoints': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "loyaltyPoints",
            "baseName": "loyalty_points",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdLoyaltyPoints200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMail200Ok {
    /**
    * From whom the mail was sent
    */
    'from'?: number;
    /**
    * is_read boolean
    */
    'isRead'?: boolean;
    /**
    * labels array
    */
    'labels'?: Array<number>;
    /**
    * mail_id integer
    */
    'mailId'?: number;
    /**
    * Recipients of the mail
    */
    'recipients'?: Array<GetCharactersCharacterIdMailRecipient>;
    /**
    * Mail subject
    */
    'subject'?: string;
    /**
    * When the mail was sent
    */
    'timestamp'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "isRead",
            "baseName": "is_read",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<number>"
        },
        {
            "name": "mailId",
            "baseName": "mail_id",
            "type": "number"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<GetCharactersCharacterIdMailRecipient>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMail200Ok.attributeTypeMap;
    }
}

/**
* label object
*/
export class GetCharactersCharacterIdMailLabelsLabel {
    /**
    * color string
    */
    'color'?: GetCharactersCharacterIdMailLabelsLabel.ColorEnum;
    /**
    * label_id integer
    */
    'labelId'?: number;
    /**
    * name string
    */
    'name'?: string;
    /**
    * unread_count integer
    */
    'unreadCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "GetCharactersCharacterIdMailLabelsLabel.ColorEnum"
        },
        {
            "name": "labelId",
            "baseName": "label_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "unreadCount",
            "baseName": "unread_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMailLabelsLabel.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdMailLabelsLabel {
    export enum ColorEnum {
        _0000fe = <any> '#0000fe',
        _006634 = <any> '#006634',
        _0099ff = <any> '#0099ff',
        _00ff33 = <any> '#00ff33',
        _01ffff = <any> '#01ffff',
        _349800 = <any> '#349800',
        _660066 = <any> '#660066',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        _99ffff = <any> '#99ffff',
        _9a0000 = <any> '#9a0000',
        Ccff9a = <any> '#ccff9a',
        E6e6e6 = <any> '#e6e6e6',
        Fe0000 = <any> '#fe0000',
        Ff6600 = <any> '#ff6600',
        Ffff01 = <any> '#ffff01',
        Ffffcd = <any> '#ffffcd',
        Ffffff = <any> '#ffffff'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailLabelsOk {
    /**
    * labels array
    */
    'labels'?: Array<GetCharactersCharacterIdMailLabelsLabel>;
    /**
    * total_unread_count integer
    */
    'totalUnreadCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<GetCharactersCharacterIdMailLabelsLabel>"
        },
        {
            "name": "totalUnreadCount",
            "baseName": "total_unread_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMailLabelsOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailLists200Ok {
    /**
    * Mailing list ID
    */
    'mailingListId': number;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mailingListId",
            "baseName": "mailing_list_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMailLists200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCharactersCharacterIdMailMailIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMailMailIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailMailIdOk {
    /**
    * Mail's body
    */
    'body'?: string;
    /**
    * From whom the mail was sent
    */
    'from'?: number;
    /**
    * Labels attached to the mail
    */
    'labels'?: Array<number>;
    /**
    * Whether the mail is flagged as read
    */
    'read'?: boolean;
    /**
    * Recipients of the mail
    */
    'recipients'?: Array<GetCharactersCharacterIdMailMailIdRecipient>;
    /**
    * Mail subject
    */
    'subject'?: string;
    /**
    * When the mail was sent
    */
    'timestamp'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<number>"
        },
        {
            "name": "read",
            "baseName": "read",
            "type": "boolean"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<GetCharactersCharacterIdMailMailIdRecipient>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMailMailIdOk.attributeTypeMap;
    }
}

/**
* recipient object
*/
export class GetCharactersCharacterIdMailMailIdRecipient {
    /**
    * recipient_id integer
    */
    'recipientId': number;
    /**
    * recipient_type string
    */
    'recipientType': GetCharactersCharacterIdMailMailIdRecipient.RecipientTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipientId",
            "baseName": "recipient_id",
            "type": "number"
        },
        {
            "name": "recipientType",
            "baseName": "recipient_type",
            "type": "GetCharactersCharacterIdMailMailIdRecipient.RecipientTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMailMailIdRecipient.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdMailMailIdRecipient {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* recipient object
*/
export class GetCharactersCharacterIdMailRecipient {
    /**
    * recipient_id integer
    */
    'recipientId': number;
    /**
    * recipient_type string
    */
    'recipientType': GetCharactersCharacterIdMailRecipient.RecipientTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipientId",
            "baseName": "recipient_id",
            "type": "number"
        },
        {
            "name": "recipientType",
            "baseName": "recipient_type",
            "type": "GetCharactersCharacterIdMailRecipient.RecipientTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMailRecipient.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdMailRecipient {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdMedals200Ok {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * date string
    */
    'date': Date;
    /**
    * description string
    */
    'description': string;
    /**
    * graphics array
    */
    'graphics': Array<GetCharactersCharacterIdMedalsGraphic>;
    /**
    * issuer_id integer
    */
    'issuerId': number;
    /**
    * medal_id integer
    */
    'medalId': number;
    /**
    * reason string
    */
    'reason': string;
    /**
    * status string
    */
    'status': GetCharactersCharacterIdMedals200Ok.StatusEnum;
    /**
    * title string
    */
    'title': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "graphics",
            "baseName": "graphics",
            "type": "Array<GetCharactersCharacterIdMedalsGraphic>"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "number"
        },
        {
            "name": "medalId",
            "baseName": "medal_id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCharactersCharacterIdMedals200Ok.StatusEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMedals200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdMedals200Ok {
    export enum StatusEnum {
        Public = <any> 'public',
        Private = <any> 'private'
    }
}
/**
* graphic object
*/
export class GetCharactersCharacterIdMedalsGraphic {
    /**
    * color integer
    */
    'color'?: number;
    /**
    * graphic string
    */
    'graphic': string;
    /**
    * layer integer
    */
    'layer': number;
    /**
    * part integer
    */
    'part': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "number"
        },
        {
            "name": "graphic",
            "baseName": "graphic",
            "type": "string"
        },
        {
            "name": "layer",
            "baseName": "layer",
            "type": "number"
        },
        {
            "name": "part",
            "baseName": "part",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMedalsGraphic.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMining200Ok {
    /**
    * date string
    */
    'date': string;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdMining200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCharactersCharacterIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdNotifications200Ok {
    /**
    * is_read boolean
    */
    'isRead'?: boolean;
    /**
    * notification_id integer
    */
    'notificationId': number;
    /**
    * sender_id integer
    */
    'senderId': number;
    /**
    * sender_type string
    */
    'senderType': GetCharactersCharacterIdNotifications200Ok.SenderTypeEnum;
    /**
    * text string
    */
    'text'?: string;
    /**
    * timestamp string
    */
    'timestamp': Date;
    /**
    * type string
    */
    'type': GetCharactersCharacterIdNotifications200Ok.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isRead",
            "baseName": "is_read",
            "type": "boolean"
        },
        {
            "name": "notificationId",
            "baseName": "notification_id",
            "type": "number"
        },
        {
            "name": "senderId",
            "baseName": "sender_id",
            "type": "number"
        },
        {
            "name": "senderType",
            "baseName": "sender_type",
            "type": "GetCharactersCharacterIdNotifications200Ok.SenderTypeEnum"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetCharactersCharacterIdNotifications200Ok.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdNotifications200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdNotifications200Ok {
    export enum SenderTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction',
        Other = <any> 'other'
    }
    export enum TypeEnum {
        AcceptedAlly = <any> 'AcceptedAlly',
        AcceptedSurrender = <any> 'AcceptedSurrender',
        AllAnchoringMsg = <any> 'AllAnchoringMsg',
        AllMaintenanceBillMsg = <any> 'AllMaintenanceBillMsg',
        AllStrucInvulnerableMsg = <any> 'AllStrucInvulnerableMsg',
        AllStructVulnerableMsg = <any> 'AllStructVulnerableMsg',
        AllWarCorpJoinedAllianceMsg = <any> 'AllWarCorpJoinedAllianceMsg',
        AllWarDeclaredMsg = <any> 'AllWarDeclaredMsg',
        AllWarInvalidatedMsg = <any> 'AllWarInvalidatedMsg',
        AllWarRetractedMsg = <any> 'AllWarRetractedMsg',
        AllWarSurrenderMsg = <any> 'AllWarSurrenderMsg',
        AllianceCapitalChanged = <any> 'AllianceCapitalChanged',
        AllianceWarDeclaredV2 = <any> 'AllianceWarDeclaredV2',
        AllyContractCancelled = <any> 'AllyContractCancelled',
        AllyJoinedWarAggressorMsg = <any> 'AllyJoinedWarAggressorMsg',
        AllyJoinedWarAllyMsg = <any> 'AllyJoinedWarAllyMsg',
        AllyJoinedWarDefenderMsg = <any> 'AllyJoinedWarDefenderMsg',
        BattlePunishFriendlyFire = <any> 'BattlePunishFriendlyFire',
        BillOutOfMoneyMsg = <any> 'BillOutOfMoneyMsg',
        BillPaidCorpAllMsg = <any> 'BillPaidCorpAllMsg',
        BountyClaimMsg = <any> 'BountyClaimMsg',
        BountyESSShared = <any> 'BountyESSShared',
        BountyESSTaken = <any> 'BountyESSTaken',
        BountyPlacedAlliance = <any> 'BountyPlacedAlliance',
        BountyPlacedChar = <any> 'BountyPlacedChar',
        BountyPlacedCorp = <any> 'BountyPlacedCorp',
        BountyYourBountyClaimed = <any> 'BountyYourBountyClaimed',
        BuddyConnectContactAdd = <any> 'BuddyConnectContactAdd',
        CharAppAcceptMsg = <any> 'CharAppAcceptMsg',
        CharAppRejectMsg = <any> 'CharAppRejectMsg',
        CharAppWithdrawMsg = <any> 'CharAppWithdrawMsg',
        CharLeftCorpMsg = <any> 'CharLeftCorpMsg',
        CharMedalMsg = <any> 'CharMedalMsg',
        CharTerminationMsg = <any> 'CharTerminationMsg',
        CloneActivationMsg = <any> 'CloneActivationMsg',
        CloneActivationMsg2 = <any> 'CloneActivationMsg2',
        CloneMovedMsg = <any> 'CloneMovedMsg',
        CloneRevokedMsg1 = <any> 'CloneRevokedMsg1',
        CloneRevokedMsg2 = <any> 'CloneRevokedMsg2',
        CombatOperationFinished = <any> 'CombatOperationFinished',
        ContactAdd = <any> 'ContactAdd',
        ContactEdit = <any> 'ContactEdit',
        ContainerPasswordMsg = <any> 'ContainerPasswordMsg',
        CorpAllBillMsg = <any> 'CorpAllBillMsg',
        CorpAppAcceptMsg = <any> 'CorpAppAcceptMsg',
        CorpAppInvitedMsg = <any> 'CorpAppInvitedMsg',
        CorpAppNewMsg = <any> 'CorpAppNewMsg',
        CorpAppRejectCustomMsg = <any> 'CorpAppRejectCustomMsg',
        CorpAppRejectMsg = <any> 'CorpAppRejectMsg',
        CorpBecameWarEligible = <any> 'CorpBecameWarEligible',
        CorpDividendMsg = <any> 'CorpDividendMsg',
        CorpFriendlyFireDisableTimerCompleted = <any> 'CorpFriendlyFireDisableTimerCompleted',
        CorpFriendlyFireDisableTimerStarted = <any> 'CorpFriendlyFireDisableTimerStarted',
        CorpFriendlyFireEnableTimerCompleted = <any> 'CorpFriendlyFireEnableTimerCompleted',
        CorpFriendlyFireEnableTimerStarted = <any> 'CorpFriendlyFireEnableTimerStarted',
        CorpKicked = <any> 'CorpKicked',
        CorpLiquidationMsg = <any> 'CorpLiquidationMsg',
        CorpNewCEOMsg = <any> 'CorpNewCEOMsg',
        CorpNewsMsg = <any> 'CorpNewsMsg',
        CorpNoLongerWarEligible = <any> 'CorpNoLongerWarEligible',
        CorpOfficeExpirationMsg = <any> 'CorpOfficeExpirationMsg',
        CorpStructLostMsg = <any> 'CorpStructLostMsg',
        CorpTaxChangeMsg = <any> 'CorpTaxChangeMsg',
        CorpVoteCEORevokedMsg = <any> 'CorpVoteCEORevokedMsg',
        CorpVoteMsg = <any> 'CorpVoteMsg',
        CorpWarDeclaredMsg = <any> 'CorpWarDeclaredMsg',
        CorpWarDeclaredV2 = <any> 'CorpWarDeclaredV2',
        CorpWarFightingLegalMsg = <any> 'CorpWarFightingLegalMsg',
        CorpWarInvalidatedMsg = <any> 'CorpWarInvalidatedMsg',
        CorpWarRetractedMsg = <any> 'CorpWarRetractedMsg',
        CorpWarSurrenderMsg = <any> 'CorpWarSurrenderMsg',
        CustomsMsg = <any> 'CustomsMsg',
        DeclareWar = <any> 'DeclareWar',
        DistrictAttacked = <any> 'DistrictAttacked',
        DustAppAcceptedMsg = <any> 'DustAppAcceptedMsg',
        EntosisCaptureStarted = <any> 'EntosisCaptureStarted',
        FWAllianceKickMsg = <any> 'FWAllianceKickMsg',
        FWAllianceWarningMsg = <any> 'FWAllianceWarningMsg',
        FWCharKickMsg = <any> 'FWCharKickMsg',
        FWCharRankGainMsg = <any> 'FWCharRankGainMsg',
        FWCharRankLossMsg = <any> 'FWCharRankLossMsg',
        FWCharWarningMsg = <any> 'FWCharWarningMsg',
        FWCorpJoinMsg = <any> 'FWCorpJoinMsg',
        FWCorpKickMsg = <any> 'FWCorpKickMsg',
        FWCorpLeaveMsg = <any> 'FWCorpLeaveMsg',
        FWCorpWarningMsg = <any> 'FWCorpWarningMsg',
        FacWarCorpJoinRequestMsg = <any> 'FacWarCorpJoinRequestMsg',
        FacWarCorpJoinWithdrawMsg = <any> 'FacWarCorpJoinWithdrawMsg',
        FacWarCorpLeaveRequestMsg = <any> 'FacWarCorpLeaveRequestMsg',
        FacWarCorpLeaveWithdrawMsg = <any> 'FacWarCorpLeaveWithdrawMsg',
        FacWarLPDisqualifiedEvent = <any> 'FacWarLPDisqualifiedEvent',
        FacWarLPDisqualifiedKill = <any> 'FacWarLPDisqualifiedKill',
        FacWarLPPayoutEvent = <any> 'FacWarLPPayoutEvent',
        FacWarLPPayoutKill = <any> 'FacWarLPPayoutKill',
        GameTimeAdded = <any> 'GameTimeAdded',
        GameTimeReceived = <any> 'GameTimeReceived',
        GameTimeSent = <any> 'GameTimeSent',
        GiftReceived = <any> 'GiftReceived',
        IHubDestroyedByBillFailure = <any> 'IHubDestroyedByBillFailure',
        IncursionCompletedMsg = <any> 'IncursionCompletedMsg',
        IndustryOperationFinished = <any> 'IndustryOperationFinished',
        IndustryTeamAuctionLost = <any> 'IndustryTeamAuctionLost',
        IndustryTeamAuctionWon = <any> 'IndustryTeamAuctionWon',
        InfrastructureHubBillAboutToExpire = <any> 'InfrastructureHubBillAboutToExpire',
        InsuranceExpirationMsg = <any> 'InsuranceExpirationMsg',
        InsuranceFirstShipMsg = <any> 'InsuranceFirstShipMsg',
        InsuranceInvalidatedMsg = <any> 'InsuranceInvalidatedMsg',
        InsuranceIssuedMsg = <any> 'InsuranceIssuedMsg',
        InsurancePayoutMsg = <any> 'InsurancePayoutMsg',
        InvasionSystemLogin = <any> 'InvasionSystemLogin',
        JumpCloneDeletedMsg1 = <any> 'JumpCloneDeletedMsg1',
        JumpCloneDeletedMsg2 = <any> 'JumpCloneDeletedMsg2',
        KillReportFinalBlow = <any> 'KillReportFinalBlow',
        KillReportVictim = <any> 'KillReportVictim',
        KillRightAvailable = <any> 'KillRightAvailable',
        KillRightAvailableOpen = <any> 'KillRightAvailableOpen',
        KillRightEarned = <any> 'KillRightEarned',
        KillRightUnavailable = <any> 'KillRightUnavailable',
        KillRightUnavailableOpen = <any> 'KillRightUnavailableOpen',
        KillRightUsed = <any> 'KillRightUsed',
        LocateCharMsg = <any> 'LocateCharMsg',
        MadeWarMutual = <any> 'MadeWarMutual',
        MercOfferRetractedMsg = <any> 'MercOfferRetractedMsg',
        MercOfferedNegotiationMsg = <any> 'MercOfferedNegotiationMsg',
        MissionOfferExpirationMsg = <any> 'MissionOfferExpirationMsg',
        MissionTimeoutMsg = <any> 'MissionTimeoutMsg',
        MoonminingAutomaticFracture = <any> 'MoonminingAutomaticFracture',
        MoonminingExtractionCancelled = <any> 'MoonminingExtractionCancelled',
        MoonminingExtractionFinished = <any> 'MoonminingExtractionFinished',
        MoonminingExtractionStarted = <any> 'MoonminingExtractionStarted',
        MoonminingLaserFired = <any> 'MoonminingLaserFired',
        MutualWarExpired = <any> 'MutualWarExpired',
        MutualWarInviteAccepted = <any> 'MutualWarInviteAccepted',
        MutualWarInviteRejected = <any> 'MutualWarInviteRejected',
        MutualWarInviteSent = <any> 'MutualWarInviteSent',
        NPCStandingsGained = <any> 'NPCStandingsGained',
        NPCStandingsLost = <any> 'NPCStandingsLost',
        OfferToAllyRetracted = <any> 'OfferToAllyRetracted',
        OfferedSurrender = <any> 'OfferedSurrender',
        OfferedToAlly = <any> 'OfferedToAlly',
        OldLscMessages = <any> 'OldLscMessages',
        OperationFinished = <any> 'OperationFinished',
        OrbitalAttacked = <any> 'OrbitalAttacked',
        OrbitalReinforced = <any> 'OrbitalReinforced',
        OwnershipTransferred = <any> 'OwnershipTransferred',
        RaffleCreated = <any> 'RaffleCreated',
        RaffleExpired = <any> 'RaffleExpired',
        RaffleFinished = <any> 'RaffleFinished',
        ReimbursementMsg = <any> 'ReimbursementMsg',
        ResearchMissionAvailableMsg = <any> 'ResearchMissionAvailableMsg',
        RetractsWar = <any> 'RetractsWar',
        SeasonalChallengeCompleted = <any> 'SeasonalChallengeCompleted',
        SovAllClaimAquiredMsg = <any> 'SovAllClaimAquiredMsg',
        SovAllClaimLostMsg = <any> 'SovAllClaimLostMsg',
        SovCommandNodeEventStarted = <any> 'SovCommandNodeEventStarted',
        SovCorpBillLateMsg = <any> 'SovCorpBillLateMsg',
        SovCorpClaimFailMsg = <any> 'SovCorpClaimFailMsg',
        SovDisruptorMsg = <any> 'SovDisruptorMsg',
        SovStationEnteredFreeport = <any> 'SovStationEnteredFreeport',
        SovStructureDestroyed = <any> 'SovStructureDestroyed',
        SovStructureReinforced = <any> 'SovStructureReinforced',
        SovStructureSelfDestructCancel = <any> 'SovStructureSelfDestructCancel',
        SovStructureSelfDestructFinished = <any> 'SovStructureSelfDestructFinished',
        SovStructureSelfDestructRequested = <any> 'SovStructureSelfDestructRequested',
        SovereigntyIHDamageMsg = <any> 'SovereigntyIHDamageMsg',
        SovereigntySBUDamageMsg = <any> 'SovereigntySBUDamageMsg',
        SovereigntyTCUDamageMsg = <any> 'SovereigntyTCUDamageMsg',
        StationAggressionMsg1 = <any> 'StationAggressionMsg1',
        StationAggressionMsg2 = <any> 'StationAggressionMsg2',
        StationConquerMsg = <any> 'StationConquerMsg',
        StationServiceDisabled = <any> 'StationServiceDisabled',
        StationServiceEnabled = <any> 'StationServiceEnabled',
        StationStateChangeMsg = <any> 'StationStateChangeMsg',
        StoryLineMissionAvailableMsg = <any> 'StoryLineMissionAvailableMsg',
        StructureAnchoring = <any> 'StructureAnchoring',
        StructureCourierContractChanged = <any> 'StructureCourierContractChanged',
        StructureDestroyed = <any> 'StructureDestroyed',
        StructureFuelAlert = <any> 'StructureFuelAlert',
        StructureItemsDelivered = <any> 'StructureItemsDelivered',
        StructureItemsMovedToSafety = <any> 'StructureItemsMovedToSafety',
        StructureLostArmor = <any> 'StructureLostArmor',
        StructureLostShields = <any> 'StructureLostShields',
        StructureOnline = <any> 'StructureOnline',
        StructureServicesOffline = <any> 'StructureServicesOffline',
        StructureUnanchoring = <any> 'StructureUnanchoring',
        StructureUnderAttack = <any> 'StructureUnderAttack',
        StructureWentHighPower = <any> 'StructureWentHighPower',
        StructureWentLowPower = <any> 'StructureWentLowPower',
        StructuresJobsCancelled = <any> 'StructuresJobsCancelled',
        StructuresJobsPaused = <any> 'StructuresJobsPaused',
        StructuresReinforcementChanged = <any> 'StructuresReinforcementChanged',
        TowerAlertMsg = <any> 'TowerAlertMsg',
        TowerResourceAlertMsg = <any> 'TowerResourceAlertMsg',
        TransactionReversalMsg = <any> 'TransactionReversalMsg',
        TutorialMsg = <any> 'TutorialMsg',
        WarAdopted = <any> 'WarAdopted ',
        WarAllyInherited = <any> 'WarAllyInherited',
        WarAllyOfferDeclinedMsg = <any> 'WarAllyOfferDeclinedMsg',
        WarConcordInvalidates = <any> 'WarConcordInvalidates',
        WarDeclared = <any> 'WarDeclared',
        WarHQRemovedFromSpace = <any> 'WarHQRemovedFromSpace',
        WarInherited = <any> 'WarInherited',
        WarInvalid = <any> 'WarInvalid',
        WarRetracted = <any> 'WarRetracted',
        WarRetractedByConcord = <any> 'WarRetractedByConcord',
        WarSurrenderDeclinedMsg = <any> 'WarSurrenderDeclinedMsg',
        WarSurrenderOfferMsg = <any> 'WarSurrenderOfferMsg'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdNotificationsContacts200Ok {
    /**
    * message string
    */
    'message': string;
    /**
    * notification_id integer
    */
    'notificationId': number;
    /**
    * send_date string
    */
    'sendDate': Date;
    /**
    * sender_character_id integer
    */
    'senderCharacterId': number;
    /**
    * A number representing the standing level the receiver has been added at by the sender. The standing levels are as follows: -10 -> Terrible | -5 -> Bad |  0 -> Neutral |  5 -> Good |  10 -> Excellent
    */
    'standingLevel': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "notificationId",
            "baseName": "notification_id",
            "type": "number"
        },
        {
            "name": "sendDate",
            "baseName": "send_date",
            "type": "Date"
        },
        {
            "name": "senderCharacterId",
            "baseName": "sender_character_id",
            "type": "number"
        },
        {
            "name": "standingLevel",
            "baseName": "standing_level",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdNotificationsContacts200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdOk {
    /**
    * The character's alliance ID
    */
    'allianceId'?: number;
    /**
    * ancestry_id integer
    */
    'ancestryId'?: number;
    /**
    * Creation date of the character
    */
    'birthday': Date;
    /**
    * bloodline_id integer
    */
    'bloodlineId': number;
    /**
    * The character's corporation ID
    */
    'corporationId': number;
    /**
    * description string
    */
    'description'?: string;
    /**
    * ID of the faction the character is fighting for, if the character is enlisted in Factional Warfare
    */
    'factionId'?: number;
    /**
    * gender string
    */
    'gender': GetCharactersCharacterIdOk.GenderEnum;
    /**
    * name string
    */
    'name': string;
    /**
    * race_id integer
    */
    'raceId': number;
    /**
    * security_status number
    */
    'securityStatus'?: number;
    /**
    * The individual title of the character
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "ancestryId",
            "baseName": "ancestry_id",
            "type": "number"
        },
        {
            "name": "birthday",
            "baseName": "birthday",
            "type": "Date"
        },
        {
            "name": "bloodlineId",
            "baseName": "bloodline_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "GetCharactersCharacterIdOk.GenderEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "raceId",
            "baseName": "race_id",
            "type": "number"
        },
        {
            "name": "securityStatus",
            "baseName": "security_status",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdOk.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdOk {
    export enum GenderEnum {
        Female = <any> 'female',
        Male = <any> 'male'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdOnlineOk {
    /**
    * Timestamp of the last login
    */
    'lastLogin'?: Date;
    /**
    * Timestamp of the last logout
    */
    'lastLogout'?: Date;
    /**
    * Total number of times the character has logged in
    */
    'logins'?: number;
    /**
    * If the character is online
    */
    'online': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastLogin",
            "baseName": "last_login",
            "type": "Date"
        },
        {
            "name": "lastLogout",
            "baseName": "last_logout",
            "type": "Date"
        },
        {
            "name": "logins",
            "baseName": "logins",
            "type": "number"
        },
        {
            "name": "online",
            "baseName": "online",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdOnlineOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdOpportunities200Ok {
    /**
    * completed_at string
    */
    'completedAt': Date;
    /**
    * task_id integer
    */
    'taskId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "completedAt",
            "baseName": "completed_at",
            "type": "Date"
        },
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdOpportunities200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdOrders200Ok {
    /**
    * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
    */
    'duration': number;
    /**
    * For buy orders, the amount of ISK in escrow
    */
    'escrow'?: number;
    /**
    * True if the order is a bid (buy) order
    */
    'isBuyOrder'?: boolean;
    /**
    * Signifies whether the buy/sell order was placed on behalf of a corporation.
    */
    'isCorporation': boolean;
    /**
    * Date and time when this order was issued
    */
    'issued': Date;
    /**
    * ID of the location where order was placed
    */
    'locationId': number;
    /**
    * For buy orders, the minimum quantity that will be accepted in a matching sell order
    */
    'minVolume'?: number;
    /**
    * Unique order ID
    */
    'orderId': number;
    /**
    * Cost per unit for this order
    */
    'price': number;
    /**
    * Valid order range, numbers are ranges in jumps
    */
    'range': GetCharactersCharacterIdOrders200Ok.RangeEnum;
    /**
    * ID of the region where order was placed
    */
    'regionId': number;
    /**
    * The type ID of the item transacted in this order
    */
    'typeId': number;
    /**
    * Quantity of items still required or offered
    */
    'volumeRemain': number;
    /**
    * Quantity of items required or offered at time order was placed
    */
    'volumeTotal': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "escrow",
            "baseName": "escrow",
            "type": "number"
        },
        {
            "name": "isBuyOrder",
            "baseName": "is_buy_order",
            "type": "boolean"
        },
        {
            "name": "isCorporation",
            "baseName": "is_corporation",
            "type": "boolean"
        },
        {
            "name": "issued",
            "baseName": "issued",
            "type": "Date"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "minVolume",
            "baseName": "min_volume",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "range",
            "baseName": "range",
            "type": "GetCharactersCharacterIdOrders200Ok.RangeEnum"
        },
        {
            "name": "regionId",
            "baseName": "region_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "volumeRemain",
            "baseName": "volume_remain",
            "type": "number"
        },
        {
            "name": "volumeTotal",
            "baseName": "volume_total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdOrders200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdOrders200Ok {
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdOrdersHistory200Ok {
    /**
    * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
    */
    'duration': number;
    /**
    * For buy orders, the amount of ISK in escrow
    */
    'escrow'?: number;
    /**
    * True if the order is a bid (buy) order
    */
    'isBuyOrder'?: boolean;
    /**
    * Signifies whether the buy/sell order was placed on behalf of a corporation.
    */
    'isCorporation': boolean;
    /**
    * Date and time when this order was issued
    */
    'issued': Date;
    /**
    * ID of the location where order was placed
    */
    'locationId': number;
    /**
    * For buy orders, the minimum quantity that will be accepted in a matching sell order
    */
    'minVolume'?: number;
    /**
    * Unique order ID
    */
    'orderId': number;
    /**
    * Cost per unit for this order
    */
    'price': number;
    /**
    * Valid order range, numbers are ranges in jumps
    */
    'range': GetCharactersCharacterIdOrdersHistory200Ok.RangeEnum;
    /**
    * ID of the region where order was placed
    */
    'regionId': number;
    /**
    * Current order state
    */
    'state': GetCharactersCharacterIdOrdersHistory200Ok.StateEnum;
    /**
    * The type ID of the item transacted in this order
    */
    'typeId': number;
    /**
    * Quantity of items still required or offered
    */
    'volumeRemain': number;
    /**
    * Quantity of items required or offered at time order was placed
    */
    'volumeTotal': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "escrow",
            "baseName": "escrow",
            "type": "number"
        },
        {
            "name": "isBuyOrder",
            "baseName": "is_buy_order",
            "type": "boolean"
        },
        {
            "name": "isCorporation",
            "baseName": "is_corporation",
            "type": "boolean"
        },
        {
            "name": "issued",
            "baseName": "issued",
            "type": "Date"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "minVolume",
            "baseName": "min_volume",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "range",
            "baseName": "range",
            "type": "GetCharactersCharacterIdOrdersHistory200Ok.RangeEnum"
        },
        {
            "name": "regionId",
            "baseName": "region_id",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "GetCharactersCharacterIdOrdersHistory200Ok.StateEnum"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "volumeRemain",
            "baseName": "volume_remain",
            "type": "number"
        },
        {
            "name": "volumeTotal",
            "baseName": "volume_total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdOrdersHistory200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdOrdersHistory200Ok {
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
    export enum StateEnum {
        Cancelled = <any> 'cancelled',
        Expired = <any> 'expired'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdPlanets200Ok {
    /**
    * last_update string
    */
    'lastUpdate': Date;
    /**
    * num_pins integer
    */
    'numPins': number;
    /**
    * owner_id integer
    */
    'ownerId': number;
    /**
    * planet_id integer
    */
    'planetId': number;
    /**
    * planet_type string
    */
    'planetType': GetCharactersCharacterIdPlanets200Ok.PlanetTypeEnum;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * upgrade_level integer
    */
    'upgradeLevel': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastUpdate",
            "baseName": "last_update",
            "type": "Date"
        },
        {
            "name": "numPins",
            "baseName": "num_pins",
            "type": "number"
        },
        {
            "name": "ownerId",
            "baseName": "owner_id",
            "type": "number"
        },
        {
            "name": "planetId",
            "baseName": "planet_id",
            "type": "number"
        },
        {
            "name": "planetType",
            "baseName": "planet_type",
            "type": "GetCharactersCharacterIdPlanets200Ok.PlanetTypeEnum"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "upgradeLevel",
            "baseName": "upgrade_level",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanets200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdPlanets200Ok {
    export enum PlanetTypeEnum {
        Temperate = <any> 'temperate',
        Barren = <any> 'barren',
        Oceanic = <any> 'oceanic',
        Ice = <any> 'ice',
        Gas = <any> 'gas',
        Lava = <any> 'lava',
        Storm = <any> 'storm',
        Plasma = <any> 'plasma'
    }
}
/**
* content object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdContent {
    /**
    * amount integer
    */
    'amount': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdContent.attributeTypeMap;
    }
}

/**
* extractor_details object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails {
    /**
    * in seconds
    */
    'cycleTime'?: number;
    /**
    * head_radius number
    */
    'headRadius'?: number;
    /**
    * heads array
    */
    'heads': Array<GetCharactersCharacterIdPlanetsPlanetIdHead>;
    /**
    * product_type_id integer
    */
    'productTypeId'?: number;
    /**
    * qty_per_cycle integer
    */
    'qtyPerCycle'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cycleTime",
            "baseName": "cycle_time",
            "type": "number"
        },
        {
            "name": "headRadius",
            "baseName": "head_radius",
            "type": "number"
        },
        {
            "name": "heads",
            "baseName": "heads",
            "type": "Array<GetCharactersCharacterIdPlanetsPlanetIdHead>"
        },
        {
            "name": "productTypeId",
            "baseName": "product_type_id",
            "type": "number"
        },
        {
            "name": "qtyPerCycle",
            "baseName": "qty_per_cycle",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails.attributeTypeMap;
    }
}

/**
* factory_details object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails {
    /**
    * schematic_id integer
    */
    'schematicId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schematicId",
            "baseName": "schematic_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails.attributeTypeMap;
    }
}

/**
* head object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdHead {
    /**
    * head_id integer
    */
    'headId': number;
    /**
    * latitude number
    */
    'latitude': number;
    /**
    * longitude number
    */
    'longitude': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "headId",
            "baseName": "head_id",
            "type": "number"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdHead.attributeTypeMap;
    }
}

/**
* link object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdLink {
    /**
    * destination_pin_id integer
    */
    'destinationPinId': number;
    /**
    * link_level integer
    */
    'linkLevel': number;
    /**
    * source_pin_id integer
    */
    'sourcePinId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "destinationPinId",
            "baseName": "destination_pin_id",
            "type": "number"
        },
        {
            "name": "linkLevel",
            "baseName": "link_level",
            "type": "number"
        },
        {
            "name": "sourcePinId",
            "baseName": "source_pin_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdLink.attributeTypeMap;
    }
}

/**
* Colony not found
*/
export class GetCharactersCharacterIdPlanetsPlanetIdNotFound {
    /**
    * error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOk {
    /**
    * links array
    */
    'links': Array<GetCharactersCharacterIdPlanetsPlanetIdLink>;
    /**
    * pins array
    */
    'pins': Array<GetCharactersCharacterIdPlanetsPlanetIdPin>;
    /**
    * routes array
    */
    'routes': Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<GetCharactersCharacterIdPlanetsPlanetIdLink>"
        },
        {
            "name": "pins",
            "baseName": "pins",
            "type": "Array<GetCharactersCharacterIdPlanetsPlanetIdPin>"
        },
        {
            "name": "routes",
            "baseName": "routes",
            "type": "Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdOk.attributeTypeMap;
    }
}

/**
* pin object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdPin {
    /**
    * contents array
    */
    'contents'?: Array<GetCharactersCharacterIdPlanetsPlanetIdContent>;
    /**
    * expiry_time string
    */
    'expiryTime'?: Date;
    'extractorDetails'?: GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails;
    'factoryDetails'?: GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails;
    /**
    * install_time string
    */
    'installTime'?: Date;
    /**
    * last_cycle_start string
    */
    'lastCycleStart'?: Date;
    /**
    * latitude number
    */
    'latitude': number;
    /**
    * longitude number
    */
    'longitude': number;
    /**
    * pin_id integer
    */
    'pinId': number;
    /**
    * schematic_id integer
    */
    'schematicId'?: number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contents",
            "baseName": "contents",
            "type": "Array<GetCharactersCharacterIdPlanetsPlanetIdContent>"
        },
        {
            "name": "expiryTime",
            "baseName": "expiry_time",
            "type": "Date"
        },
        {
            "name": "extractorDetails",
            "baseName": "extractor_details",
            "type": "GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails"
        },
        {
            "name": "factoryDetails",
            "baseName": "factory_details",
            "type": "GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails"
        },
        {
            "name": "installTime",
            "baseName": "install_time",
            "type": "Date"
        },
        {
            "name": "lastCycleStart",
            "baseName": "last_cycle_start",
            "type": "Date"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "pinId",
            "baseName": "pin_id",
            "type": "number"
        },
        {
            "name": "schematicId",
            "baseName": "schematic_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdPin.attributeTypeMap;
    }
}

/**
* route object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdRoute {
    /**
    * content_type_id integer
    */
    'contentTypeId': number;
    /**
    * destination_pin_id integer
    */
    'destinationPinId': number;
    /**
    * quantity number
    */
    'quantity': number;
    /**
    * route_id integer
    */
    'routeId': number;
    /**
    * source_pin_id integer
    */
    'sourcePinId': number;
    /**
    * list of pin ID waypoints
    */
    'waypoints'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contentTypeId",
            "baseName": "content_type_id",
            "type": "number"
        },
        {
            "name": "destinationPinId",
            "baseName": "destination_pin_id",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "routeId",
            "baseName": "route_id",
            "type": "number"
        },
        {
            "name": "sourcePinId",
            "baseName": "source_pin_id",
            "type": "number"
        },
        {
            "name": "waypoints",
            "baseName": "waypoints",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPlanetsPlanetIdRoute.attributeTypeMap;
    }
}

/**
* No image server for this datasource
*/
export class GetCharactersCharacterIdPortraitNotFound {
    /**
    * error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPortraitNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdPortraitOk {
    /**
    * px128x128 string
    */
    'px128x128'?: string;
    /**
    * px256x256 string
    */
    'px256x256'?: string;
    /**
    * px512x512 string
    */
    'px512x512'?: string;
    /**
    * px64x64 string
    */
    'px64x64'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "px128x128",
            "baseName": "px128x128",
            "type": "string"
        },
        {
            "name": "px256x256",
            "baseName": "px256x256",
            "type": "string"
        },
        {
            "name": "px512x512",
            "baseName": "px512x512",
            "type": "string"
        },
        {
            "name": "px64x64",
            "baseName": "px64x64",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdPortraitOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdRolesOk {
    /**
    * roles array
    */
    'roles'?: Array<GetCharactersCharacterIdRolesOk.RolesEnum>;
    /**
    * roles_at_base array
    */
    'rolesAtBase'?: Array<GetCharactersCharacterIdRolesOk.RolesAtBaseEnum>;
    /**
    * roles_at_hq array
    */
    'rolesAtHq'?: Array<GetCharactersCharacterIdRolesOk.RolesAtHqEnum>;
    /**
    * roles_at_other array
    */
    'rolesAtOther'?: Array<GetCharactersCharacterIdRolesOk.RolesAtOtherEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<GetCharactersCharacterIdRolesOk.RolesEnum>"
        },
        {
            "name": "rolesAtBase",
            "baseName": "roles_at_base",
            "type": "Array<GetCharactersCharacterIdRolesOk.RolesAtBaseEnum>"
        },
        {
            "name": "rolesAtHq",
            "baseName": "roles_at_hq",
            "type": "Array<GetCharactersCharacterIdRolesOk.RolesAtHqEnum>"
        },
        {
            "name": "rolesAtOther",
            "baseName": "roles_at_other",
            "type": "Array<GetCharactersCharacterIdRolesOk.RolesAtOtherEnum>"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdRolesOk.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdRolesOk {
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdSearchOk {
    /**
    * agent array
    */
    'agent'?: Array<number>;
    /**
    * alliance array
    */
    'alliance'?: Array<number>;
    /**
    * character array
    */
    'character'?: Array<number>;
    /**
    * constellation array
    */
    'constellation'?: Array<number>;
    /**
    * corporation array
    */
    'corporation'?: Array<number>;
    /**
    * faction array
    */
    'faction'?: Array<number>;
    /**
    * inventory_type array
    */
    'inventoryType'?: Array<number>;
    /**
    * region array
    */
    'region'?: Array<number>;
    /**
    * solar_system array
    */
    'solarSystem'?: Array<number>;
    /**
    * station array
    */
    'station'?: Array<number>;
    /**
    * structure array
    */
    'structure'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agent",
            "baseName": "agent",
            "type": "Array<number>"
        },
        {
            "name": "alliance",
            "baseName": "alliance",
            "type": "Array<number>"
        },
        {
            "name": "character",
            "baseName": "character",
            "type": "Array<number>"
        },
        {
            "name": "constellation",
            "baseName": "constellation",
            "type": "Array<number>"
        },
        {
            "name": "corporation",
            "baseName": "corporation",
            "type": "Array<number>"
        },
        {
            "name": "faction",
            "baseName": "faction",
            "type": "Array<number>"
        },
        {
            "name": "inventoryType",
            "baseName": "inventory_type",
            "type": "Array<number>"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "Array<number>"
        },
        {
            "name": "solarSystem",
            "baseName": "solar_system",
            "type": "Array<number>"
        },
        {
            "name": "station",
            "baseName": "station",
            "type": "Array<number>"
        },
        {
            "name": "structure",
            "baseName": "structure",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdSearchOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdShipOk {
    /**
    * Item id's are unique to a ship and persist until it is repackaged. This value can be used to track repeated uses of a ship, or detect when a pilot changes into a different instance of the same ship type.
    */
    'shipItemId': number;
    /**
    * ship_name string
    */
    'shipName': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shipItemId",
            "baseName": "ship_item_id",
            "type": "number"
        },
        {
            "name": "shipName",
            "baseName": "ship_name",
            "type": "string"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdShipOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdSkillqueue200Ok {
    /**
    * Date on which training of the skill will complete. Omitted if the skill queue is paused.
    */
    'finishDate'?: Date;
    /**
    * finished_level integer
    */
    'finishedLevel': number;
    /**
    * level_end_sp integer
    */
    'levelEndSp'?: number;
    /**
    * Amount of SP that was in the skill when it started training it's current level. Used to calculate % of current level complete.
    */
    'levelStartSp'?: number;
    /**
    * queue_position integer
    */
    'queuePosition': number;
    /**
    * skill_id integer
    */
    'skillId': number;
    /**
    * start_date string
    */
    'startDate'?: Date;
    /**
    * training_start_sp integer
    */
    'trainingStartSp'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "finishDate",
            "baseName": "finish_date",
            "type": "Date"
        },
        {
            "name": "finishedLevel",
            "baseName": "finished_level",
            "type": "number"
        },
        {
            "name": "levelEndSp",
            "baseName": "level_end_sp",
            "type": "number"
        },
        {
            "name": "levelStartSp",
            "baseName": "level_start_sp",
            "type": "number"
        },
        {
            "name": "queuePosition",
            "baseName": "queue_position",
            "type": "number"
        },
        {
            "name": "skillId",
            "baseName": "skill_id",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "trainingStartSp",
            "baseName": "training_start_sp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdSkillqueue200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdSkillsOk {
    /**
    * skills array
    */
    'skills': Array<GetCharactersCharacterIdSkillsSkill>;
    /**
    * total_sp integer
    */
    'totalSp': number;
    /**
    * Skill points available to be assigned
    */
    'unallocatedSp'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "skills",
            "baseName": "skills",
            "type": "Array<GetCharactersCharacterIdSkillsSkill>"
        },
        {
            "name": "totalSp",
            "baseName": "total_sp",
            "type": "number"
        },
        {
            "name": "unallocatedSp",
            "baseName": "unallocated_sp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdSkillsOk.attributeTypeMap;
    }
}

/**
* skill object
*/
export class GetCharactersCharacterIdSkillsSkill {
    /**
    * active_skill_level integer
    */
    'activeSkillLevel': number;
    /**
    * skill_id integer
    */
    'skillId': number;
    /**
    * skillpoints_in_skill integer
    */
    'skillpointsInSkill': number;
    /**
    * trained_skill_level integer
    */
    'trainedSkillLevel': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeSkillLevel",
            "baseName": "active_skill_level",
            "type": "number"
        },
        {
            "name": "skillId",
            "baseName": "skill_id",
            "type": "number"
        },
        {
            "name": "skillpointsInSkill",
            "baseName": "skillpoints_in_skill",
            "type": "number"
        },
        {
            "name": "trainedSkillLevel",
            "baseName": "trained_skill_level",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdSkillsSkill.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdStandings200Ok {
    /**
    * from_id integer
    */
    'fromId': number;
    /**
    * from_type string
    */
    'fromType': GetCharactersCharacterIdStandings200Ok.FromTypeEnum;
    /**
    * standing number
    */
    'standing': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fromId",
            "baseName": "from_id",
            "type": "number"
        },
        {
            "name": "fromType",
            "baseName": "from_type",
            "type": "GetCharactersCharacterIdStandings200Ok.FromTypeEnum"
        },
        {
            "name": "standing",
            "baseName": "standing",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStandings200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdStandings200Ok {
    export enum FromTypeEnum {
        Agent = <any> 'agent',
        NpcCorp = <any> 'npc_corp',
        Faction = <any> 'faction'
    }
}
/**
* Aggregate stats for a year
*/
export class GetCharactersCharacterIdStats200Ok {
    'character'?: GetCharactersCharacterIdStatsCharacter;
    'combat'?: GetCharactersCharacterIdStatsCombat;
    'industry'?: GetCharactersCharacterIdStatsIndustry;
    'inventory'?: GetCharactersCharacterIdStatsInventory;
    'isk'?: GetCharactersCharacterIdStatsIsk;
    'market'?: GetCharactersCharacterIdStatsMarket;
    'mining'?: GetCharactersCharacterIdStatsMining;
    'module'?: GetCharactersCharacterIdStatsModule;
    'orbital'?: GetCharactersCharacterIdStatsOrbital;
    'pve'?: GetCharactersCharacterIdStatsPve;
    'social'?: GetCharactersCharacterIdStatsSocial;
    'travel'?: GetCharactersCharacterIdStatsTravel;
    /**
    * Gregorian year for this set of aggregates
    */
    'year': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "character",
            "baseName": "character",
            "type": "GetCharactersCharacterIdStatsCharacter"
        },
        {
            "name": "combat",
            "baseName": "combat",
            "type": "GetCharactersCharacterIdStatsCombat"
        },
        {
            "name": "industry",
            "baseName": "industry",
            "type": "GetCharactersCharacterIdStatsIndustry"
        },
        {
            "name": "inventory",
            "baseName": "inventory",
            "type": "GetCharactersCharacterIdStatsInventory"
        },
        {
            "name": "isk",
            "baseName": "isk",
            "type": "GetCharactersCharacterIdStatsIsk"
        },
        {
            "name": "market",
            "baseName": "market",
            "type": "GetCharactersCharacterIdStatsMarket"
        },
        {
            "name": "mining",
            "baseName": "mining",
            "type": "GetCharactersCharacterIdStatsMining"
        },
        {
            "name": "module",
            "baseName": "module",
            "type": "GetCharactersCharacterIdStatsModule"
        },
        {
            "name": "orbital",
            "baseName": "orbital",
            "type": "GetCharactersCharacterIdStatsOrbital"
        },
        {
            "name": "pve",
            "baseName": "pve",
            "type": "GetCharactersCharacterIdStatsPve"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "GetCharactersCharacterIdStatsSocial"
        },
        {
            "name": "travel",
            "baseName": "travel",
            "type": "GetCharactersCharacterIdStatsTravel"
        },
        {
            "name": "year",
            "baseName": "year",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStats200Ok.attributeTypeMap;
    }
}

/**
* character object
*/
export class GetCharactersCharacterIdStatsCharacter {
    /**
    * days_of_activity integer
    */
    'daysOfActivity'?: number;
    /**
    * minutes integer
    */
    'minutes'?: number;
    /**
    * sessions_started integer
    */
    'sessionsStarted'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "daysOfActivity",
            "baseName": "days_of_activity",
            "type": "number"
        },
        {
            "name": "minutes",
            "baseName": "minutes",
            "type": "number"
        },
        {
            "name": "sessionsStarted",
            "baseName": "sessions_started",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsCharacter.attributeTypeMap;
    }
}

/**
* combat object
*/
export class GetCharactersCharacterIdStatsCombat {
    /**
    * cap_drainedby_npc integer
    */
    'capDrainedbyNpc'?: number;
    /**
    * cap_drainedby_pc integer
    */
    'capDrainedbyPc'?: number;
    /**
    * cap_draining_pc integer
    */
    'capDrainingPc'?: number;
    /**
    * criminal_flag_set integer
    */
    'criminalFlagSet'?: number;
    /**
    * damage_from_np_cs_amount integer
    */
    'damageFromNpCsAmount'?: number;
    /**
    * damage_from_np_cs_num_shots integer
    */
    'damageFromNpCsNumShots'?: number;
    /**
    * damage_from_players_bomb_amount integer
    */
    'damageFromPlayersBombAmount'?: number;
    /**
    * damage_from_players_bomb_num_shots integer
    */
    'damageFromPlayersBombNumShots'?: number;
    /**
    * damage_from_players_combat_drone_amount integer
    */
    'damageFromPlayersCombatDroneAmount'?: number;
    /**
    * damage_from_players_combat_drone_num_shots integer
    */
    'damageFromPlayersCombatDroneNumShots'?: number;
    /**
    * damage_from_players_energy_amount integer
    */
    'damageFromPlayersEnergyAmount'?: number;
    /**
    * damage_from_players_energy_num_shots integer
    */
    'damageFromPlayersEnergyNumShots'?: number;
    /**
    * damage_from_players_fighter_bomber_amount integer
    */
    'damageFromPlayersFighterBomberAmount'?: number;
    /**
    * damage_from_players_fighter_bomber_num_shots integer
    */
    'damageFromPlayersFighterBomberNumShots'?: number;
    /**
    * damage_from_players_fighter_drone_amount integer
    */
    'damageFromPlayersFighterDroneAmount'?: number;
    /**
    * damage_from_players_fighter_drone_num_shots integer
    */
    'damageFromPlayersFighterDroneNumShots'?: number;
    /**
    * damage_from_players_hybrid_amount integer
    */
    'damageFromPlayersHybridAmount'?: number;
    /**
    * damage_from_players_hybrid_num_shots integer
    */
    'damageFromPlayersHybridNumShots'?: number;
    /**
    * damage_from_players_missile_amount integer
    */
    'damageFromPlayersMissileAmount'?: number;
    /**
    * damage_from_players_missile_num_shots integer
    */
    'damageFromPlayersMissileNumShots'?: number;
    /**
    * damage_from_players_projectile_amount integer
    */
    'damageFromPlayersProjectileAmount'?: number;
    /**
    * damage_from_players_projectile_num_shots integer
    */
    'damageFromPlayersProjectileNumShots'?: number;
    /**
    * damage_from_players_smart_bomb_amount integer
    */
    'damageFromPlayersSmartBombAmount'?: number;
    /**
    * damage_from_players_smart_bomb_num_shots integer
    */
    'damageFromPlayersSmartBombNumShots'?: number;
    /**
    * damage_from_players_super_amount integer
    */
    'damageFromPlayersSuperAmount'?: number;
    /**
    * damage_from_players_super_num_shots integer
    */
    'damageFromPlayersSuperNumShots'?: number;
    /**
    * damage_from_structures_total_amount integer
    */
    'damageFromStructuresTotalAmount'?: number;
    /**
    * damage_from_structures_total_num_shots integer
    */
    'damageFromStructuresTotalNumShots'?: number;
    /**
    * damage_to_players_bomb_amount integer
    */
    'damageToPlayersBombAmount'?: number;
    /**
    * damage_to_players_bomb_num_shots integer
    */
    'damageToPlayersBombNumShots'?: number;
    /**
    * damage_to_players_combat_drone_amount integer
    */
    'damageToPlayersCombatDroneAmount'?: number;
    /**
    * damage_to_players_combat_drone_num_shots integer
    */
    'damageToPlayersCombatDroneNumShots'?: number;
    /**
    * damage_to_players_energy_amount integer
    */
    'damageToPlayersEnergyAmount'?: number;
    /**
    * damage_to_players_energy_num_shots integer
    */
    'damageToPlayersEnergyNumShots'?: number;
    /**
    * damage_to_players_fighter_bomber_amount integer
    */
    'damageToPlayersFighterBomberAmount'?: number;
    /**
    * damage_to_players_fighter_bomber_num_shots integer
    */
    'damageToPlayersFighterBomberNumShots'?: number;
    /**
    * damage_to_players_fighter_drone_amount integer
    */
    'damageToPlayersFighterDroneAmount'?: number;
    /**
    * damage_to_players_fighter_drone_num_shots integer
    */
    'damageToPlayersFighterDroneNumShots'?: number;
    /**
    * damage_to_players_hybrid_amount integer
    */
    'damageToPlayersHybridAmount'?: number;
    /**
    * damage_to_players_hybrid_num_shots integer
    */
    'damageToPlayersHybridNumShots'?: number;
    /**
    * damage_to_players_missile_amount integer
    */
    'damageToPlayersMissileAmount'?: number;
    /**
    * damage_to_players_missile_num_shots integer
    */
    'damageToPlayersMissileNumShots'?: number;
    /**
    * damage_to_players_projectile_amount integer
    */
    'damageToPlayersProjectileAmount'?: number;
    /**
    * damage_to_players_projectile_num_shots integer
    */
    'damageToPlayersProjectileNumShots'?: number;
    /**
    * damage_to_players_smart_bomb_amount integer
    */
    'damageToPlayersSmartBombAmount'?: number;
    /**
    * damage_to_players_smart_bomb_num_shots integer
    */
    'damageToPlayersSmartBombNumShots'?: number;
    /**
    * damage_to_players_super_amount integer
    */
    'damageToPlayersSuperAmount'?: number;
    /**
    * damage_to_players_super_num_shots integer
    */
    'damageToPlayersSuperNumShots'?: number;
    /**
    * damage_to_structures_total_amount integer
    */
    'damageToStructuresTotalAmount'?: number;
    /**
    * damage_to_structures_total_num_shots integer
    */
    'damageToStructuresTotalNumShots'?: number;
    /**
    * deaths_high_sec integer
    */
    'deathsHighSec'?: number;
    /**
    * deaths_low_sec integer
    */
    'deathsLowSec'?: number;
    /**
    * deaths_null_sec integer
    */
    'deathsNullSec'?: number;
    /**
    * deaths_pod_high_sec integer
    */
    'deathsPodHighSec'?: number;
    /**
    * deaths_pod_low_sec integer
    */
    'deathsPodLowSec'?: number;
    /**
    * deaths_pod_null_sec integer
    */
    'deathsPodNullSec'?: number;
    /**
    * deaths_pod_wormhole integer
    */
    'deathsPodWormhole'?: number;
    /**
    * deaths_wormhole integer
    */
    'deathsWormhole'?: number;
    /**
    * drone_engage integer
    */
    'droneEngage'?: number;
    /**
    * dscans integer
    */
    'dscans'?: number;
    /**
    * duel_requested integer
    */
    'duelRequested'?: number;
    /**
    * engagement_register integer
    */
    'engagementRegister'?: number;
    /**
    * kills_assists integer
    */
    'killsAssists'?: number;
    /**
    * kills_high_sec integer
    */
    'killsHighSec'?: number;
    /**
    * kills_low_sec integer
    */
    'killsLowSec'?: number;
    /**
    * kills_null_sec integer
    */
    'killsNullSec'?: number;
    /**
    * kills_pod_high_sec integer
    */
    'killsPodHighSec'?: number;
    /**
    * kills_pod_low_sec integer
    */
    'killsPodLowSec'?: number;
    /**
    * kills_pod_null_sec integer
    */
    'killsPodNullSec'?: number;
    /**
    * kills_pod_wormhole integer
    */
    'killsPodWormhole'?: number;
    /**
    * kills_wormhole integer
    */
    'killsWormhole'?: number;
    /**
    * npc_flag_set integer
    */
    'npcFlagSet'?: number;
    /**
    * probe_scans integer
    */
    'probeScans'?: number;
    /**
    * pvp_flag_set integer
    */
    'pvpFlagSet'?: number;
    /**
    * repair_armor_by_remote_amount integer
    */
    'repairArmorByRemoteAmount'?: number;
    /**
    * repair_armor_remote_amount integer
    */
    'repairArmorRemoteAmount'?: number;
    /**
    * repair_armor_self_amount integer
    */
    'repairArmorSelfAmount'?: number;
    /**
    * repair_capacitor_by_remote_amount integer
    */
    'repairCapacitorByRemoteAmount'?: number;
    /**
    * repair_capacitor_remote_amount integer
    */
    'repairCapacitorRemoteAmount'?: number;
    /**
    * repair_capacitor_self_amount integer
    */
    'repairCapacitorSelfAmount'?: number;
    /**
    * repair_hull_by_remote_amount integer
    */
    'repairHullByRemoteAmount'?: number;
    /**
    * repair_hull_remote_amount integer
    */
    'repairHullRemoteAmount'?: number;
    /**
    * repair_hull_self_amount integer
    */
    'repairHullSelfAmount'?: number;
    /**
    * repair_shield_by_remote_amount integer
    */
    'repairShieldByRemoteAmount'?: number;
    /**
    * repair_shield_remote_amount integer
    */
    'repairShieldRemoteAmount'?: number;
    /**
    * repair_shield_self_amount integer
    */
    'repairShieldSelfAmount'?: number;
    /**
    * self_destructs integer
    */
    'selfDestructs'?: number;
    /**
    * warp_scramble_pc integer
    */
    'warpScramblePc'?: number;
    /**
    * warp_scrambledby_npc integer
    */
    'warpScrambledbyNpc'?: number;
    /**
    * warp_scrambledby_pc integer
    */
    'warpScrambledbyPc'?: number;
    /**
    * weapon_flag_set integer
    */
    'weaponFlagSet'?: number;
    /**
    * webifiedby_npc integer
    */
    'webifiedbyNpc'?: number;
    /**
    * webifiedby_pc integer
    */
    'webifiedbyPc'?: number;
    /**
    * webifying_pc integer
    */
    'webifyingPc'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "capDrainedbyNpc",
            "baseName": "cap_drainedby_npc",
            "type": "number"
        },
        {
            "name": "capDrainedbyPc",
            "baseName": "cap_drainedby_pc",
            "type": "number"
        },
        {
            "name": "capDrainingPc",
            "baseName": "cap_draining_pc",
            "type": "number"
        },
        {
            "name": "criminalFlagSet",
            "baseName": "criminal_flag_set",
            "type": "number"
        },
        {
            "name": "damageFromNpCsAmount",
            "baseName": "damage_from_np_cs_amount",
            "type": "number"
        },
        {
            "name": "damageFromNpCsNumShots",
            "baseName": "damage_from_np_cs_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersBombAmount",
            "baseName": "damage_from_players_bomb_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersBombNumShots",
            "baseName": "damage_from_players_bomb_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersCombatDroneAmount",
            "baseName": "damage_from_players_combat_drone_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersCombatDroneNumShots",
            "baseName": "damage_from_players_combat_drone_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersEnergyAmount",
            "baseName": "damage_from_players_energy_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersEnergyNumShots",
            "baseName": "damage_from_players_energy_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersFighterBomberAmount",
            "baseName": "damage_from_players_fighter_bomber_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersFighterBomberNumShots",
            "baseName": "damage_from_players_fighter_bomber_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersFighterDroneAmount",
            "baseName": "damage_from_players_fighter_drone_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersFighterDroneNumShots",
            "baseName": "damage_from_players_fighter_drone_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersHybridAmount",
            "baseName": "damage_from_players_hybrid_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersHybridNumShots",
            "baseName": "damage_from_players_hybrid_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersMissileAmount",
            "baseName": "damage_from_players_missile_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersMissileNumShots",
            "baseName": "damage_from_players_missile_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersProjectileAmount",
            "baseName": "damage_from_players_projectile_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersProjectileNumShots",
            "baseName": "damage_from_players_projectile_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersSmartBombAmount",
            "baseName": "damage_from_players_smart_bomb_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersSmartBombNumShots",
            "baseName": "damage_from_players_smart_bomb_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromPlayersSuperAmount",
            "baseName": "damage_from_players_super_amount",
            "type": "number"
        },
        {
            "name": "damageFromPlayersSuperNumShots",
            "baseName": "damage_from_players_super_num_shots",
            "type": "number"
        },
        {
            "name": "damageFromStructuresTotalAmount",
            "baseName": "damage_from_structures_total_amount",
            "type": "number"
        },
        {
            "name": "damageFromStructuresTotalNumShots",
            "baseName": "damage_from_structures_total_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersBombAmount",
            "baseName": "damage_to_players_bomb_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersBombNumShots",
            "baseName": "damage_to_players_bomb_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersCombatDroneAmount",
            "baseName": "damage_to_players_combat_drone_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersCombatDroneNumShots",
            "baseName": "damage_to_players_combat_drone_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersEnergyAmount",
            "baseName": "damage_to_players_energy_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersEnergyNumShots",
            "baseName": "damage_to_players_energy_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersFighterBomberAmount",
            "baseName": "damage_to_players_fighter_bomber_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersFighterBomberNumShots",
            "baseName": "damage_to_players_fighter_bomber_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersFighterDroneAmount",
            "baseName": "damage_to_players_fighter_drone_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersFighterDroneNumShots",
            "baseName": "damage_to_players_fighter_drone_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersHybridAmount",
            "baseName": "damage_to_players_hybrid_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersHybridNumShots",
            "baseName": "damage_to_players_hybrid_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersMissileAmount",
            "baseName": "damage_to_players_missile_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersMissileNumShots",
            "baseName": "damage_to_players_missile_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersProjectileAmount",
            "baseName": "damage_to_players_projectile_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersProjectileNumShots",
            "baseName": "damage_to_players_projectile_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersSmartBombAmount",
            "baseName": "damage_to_players_smart_bomb_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersSmartBombNumShots",
            "baseName": "damage_to_players_smart_bomb_num_shots",
            "type": "number"
        },
        {
            "name": "damageToPlayersSuperAmount",
            "baseName": "damage_to_players_super_amount",
            "type": "number"
        },
        {
            "name": "damageToPlayersSuperNumShots",
            "baseName": "damage_to_players_super_num_shots",
            "type": "number"
        },
        {
            "name": "damageToStructuresTotalAmount",
            "baseName": "damage_to_structures_total_amount",
            "type": "number"
        },
        {
            "name": "damageToStructuresTotalNumShots",
            "baseName": "damage_to_structures_total_num_shots",
            "type": "number"
        },
        {
            "name": "deathsHighSec",
            "baseName": "deaths_high_sec",
            "type": "number"
        },
        {
            "name": "deathsLowSec",
            "baseName": "deaths_low_sec",
            "type": "number"
        },
        {
            "name": "deathsNullSec",
            "baseName": "deaths_null_sec",
            "type": "number"
        },
        {
            "name": "deathsPodHighSec",
            "baseName": "deaths_pod_high_sec",
            "type": "number"
        },
        {
            "name": "deathsPodLowSec",
            "baseName": "deaths_pod_low_sec",
            "type": "number"
        },
        {
            "name": "deathsPodNullSec",
            "baseName": "deaths_pod_null_sec",
            "type": "number"
        },
        {
            "name": "deathsPodWormhole",
            "baseName": "deaths_pod_wormhole",
            "type": "number"
        },
        {
            "name": "deathsWormhole",
            "baseName": "deaths_wormhole",
            "type": "number"
        },
        {
            "name": "droneEngage",
            "baseName": "drone_engage",
            "type": "number"
        },
        {
            "name": "dscans",
            "baseName": "dscans",
            "type": "number"
        },
        {
            "name": "duelRequested",
            "baseName": "duel_requested",
            "type": "number"
        },
        {
            "name": "engagementRegister",
            "baseName": "engagement_register",
            "type": "number"
        },
        {
            "name": "killsAssists",
            "baseName": "kills_assists",
            "type": "number"
        },
        {
            "name": "killsHighSec",
            "baseName": "kills_high_sec",
            "type": "number"
        },
        {
            "name": "killsLowSec",
            "baseName": "kills_low_sec",
            "type": "number"
        },
        {
            "name": "killsNullSec",
            "baseName": "kills_null_sec",
            "type": "number"
        },
        {
            "name": "killsPodHighSec",
            "baseName": "kills_pod_high_sec",
            "type": "number"
        },
        {
            "name": "killsPodLowSec",
            "baseName": "kills_pod_low_sec",
            "type": "number"
        },
        {
            "name": "killsPodNullSec",
            "baseName": "kills_pod_null_sec",
            "type": "number"
        },
        {
            "name": "killsPodWormhole",
            "baseName": "kills_pod_wormhole",
            "type": "number"
        },
        {
            "name": "killsWormhole",
            "baseName": "kills_wormhole",
            "type": "number"
        },
        {
            "name": "npcFlagSet",
            "baseName": "npc_flag_set",
            "type": "number"
        },
        {
            "name": "probeScans",
            "baseName": "probe_scans",
            "type": "number"
        },
        {
            "name": "pvpFlagSet",
            "baseName": "pvp_flag_set",
            "type": "number"
        },
        {
            "name": "repairArmorByRemoteAmount",
            "baseName": "repair_armor_by_remote_amount",
            "type": "number"
        },
        {
            "name": "repairArmorRemoteAmount",
            "baseName": "repair_armor_remote_amount",
            "type": "number"
        },
        {
            "name": "repairArmorSelfAmount",
            "baseName": "repair_armor_self_amount",
            "type": "number"
        },
        {
            "name": "repairCapacitorByRemoteAmount",
            "baseName": "repair_capacitor_by_remote_amount",
            "type": "number"
        },
        {
            "name": "repairCapacitorRemoteAmount",
            "baseName": "repair_capacitor_remote_amount",
            "type": "number"
        },
        {
            "name": "repairCapacitorSelfAmount",
            "baseName": "repair_capacitor_self_amount",
            "type": "number"
        },
        {
            "name": "repairHullByRemoteAmount",
            "baseName": "repair_hull_by_remote_amount",
            "type": "number"
        },
        {
            "name": "repairHullRemoteAmount",
            "baseName": "repair_hull_remote_amount",
            "type": "number"
        },
        {
            "name": "repairHullSelfAmount",
            "baseName": "repair_hull_self_amount",
            "type": "number"
        },
        {
            "name": "repairShieldByRemoteAmount",
            "baseName": "repair_shield_by_remote_amount",
            "type": "number"
        },
        {
            "name": "repairShieldRemoteAmount",
            "baseName": "repair_shield_remote_amount",
            "type": "number"
        },
        {
            "name": "repairShieldSelfAmount",
            "baseName": "repair_shield_self_amount",
            "type": "number"
        },
        {
            "name": "selfDestructs",
            "baseName": "self_destructs",
            "type": "number"
        },
        {
            "name": "warpScramblePc",
            "baseName": "warp_scramble_pc",
            "type": "number"
        },
        {
            "name": "warpScrambledbyNpc",
            "baseName": "warp_scrambledby_npc",
            "type": "number"
        },
        {
            "name": "warpScrambledbyPc",
            "baseName": "warp_scrambledby_pc",
            "type": "number"
        },
        {
            "name": "weaponFlagSet",
            "baseName": "weapon_flag_set",
            "type": "number"
        },
        {
            "name": "webifiedbyNpc",
            "baseName": "webifiedby_npc",
            "type": "number"
        },
        {
            "name": "webifiedbyPc",
            "baseName": "webifiedby_pc",
            "type": "number"
        },
        {
            "name": "webifyingPc",
            "baseName": "webifying_pc",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsCombat.attributeTypeMap;
    }
}

/**
* industry object
*/
export class GetCharactersCharacterIdStatsIndustry {
    /**
    * hacking_successes integer
    */
    'hackingSuccesses'?: number;
    /**
    * jobs_cancelled integer
    */
    'jobsCancelled'?: number;
    /**
    * jobs_completed_copy_blueprint integer
    */
    'jobsCompletedCopyBlueprint'?: number;
    /**
    * jobs_completed_invention integer
    */
    'jobsCompletedInvention'?: number;
    /**
    * jobs_completed_manufacture integer
    */
    'jobsCompletedManufacture'?: number;
    /**
    * jobs_completed_manufacture_asteroid integer
    */
    'jobsCompletedManufactureAsteroid'?: number;
    /**
    * jobs_completed_manufacture_asteroid_quantity integer
    */
    'jobsCompletedManufactureAsteroidQuantity'?: number;
    /**
    * jobs_completed_manufacture_charge integer
    */
    'jobsCompletedManufactureCharge'?: number;
    /**
    * jobs_completed_manufacture_charge_quantity integer
    */
    'jobsCompletedManufactureChargeQuantity'?: number;
    /**
    * jobs_completed_manufacture_commodity integer
    */
    'jobsCompletedManufactureCommodity'?: number;
    /**
    * jobs_completed_manufacture_commodity_quantity integer
    */
    'jobsCompletedManufactureCommodityQuantity'?: number;
    /**
    * jobs_completed_manufacture_deployable integer
    */
    'jobsCompletedManufactureDeployable'?: number;
    /**
    * jobs_completed_manufacture_deployable_quantity integer
    */
    'jobsCompletedManufactureDeployableQuantity'?: number;
    /**
    * jobs_completed_manufacture_drone integer
    */
    'jobsCompletedManufactureDrone'?: number;
    /**
    * jobs_completed_manufacture_drone_quantity integer
    */
    'jobsCompletedManufactureDroneQuantity'?: number;
    /**
    * jobs_completed_manufacture_implant integer
    */
    'jobsCompletedManufactureImplant'?: number;
    /**
    * jobs_completed_manufacture_implant_quantity integer
    */
    'jobsCompletedManufactureImplantQuantity'?: number;
    /**
    * jobs_completed_manufacture_module integer
    */
    'jobsCompletedManufactureModule'?: number;
    /**
    * jobs_completed_manufacture_module_quantity integer
    */
    'jobsCompletedManufactureModuleQuantity'?: number;
    /**
    * jobs_completed_manufacture_other integer
    */
    'jobsCompletedManufactureOther'?: number;
    /**
    * jobs_completed_manufacture_other_quantity integer
    */
    'jobsCompletedManufactureOtherQuantity'?: number;
    /**
    * jobs_completed_manufacture_ship integer
    */
    'jobsCompletedManufactureShip'?: number;
    /**
    * jobs_completed_manufacture_ship_quantity integer
    */
    'jobsCompletedManufactureShipQuantity'?: number;
    /**
    * jobs_completed_manufacture_structure integer
    */
    'jobsCompletedManufactureStructure'?: number;
    /**
    * jobs_completed_manufacture_structure_quantity integer
    */
    'jobsCompletedManufactureStructureQuantity'?: number;
    /**
    * jobs_completed_manufacture_subsystem integer
    */
    'jobsCompletedManufactureSubsystem'?: number;
    /**
    * jobs_completed_manufacture_subsystem_quantity integer
    */
    'jobsCompletedManufactureSubsystemQuantity'?: number;
    /**
    * jobs_completed_material_productivity integer
    */
    'jobsCompletedMaterialProductivity'?: number;
    /**
    * jobs_completed_time_productivity integer
    */
    'jobsCompletedTimeProductivity'?: number;
    /**
    * jobs_started_copy_blueprint integer
    */
    'jobsStartedCopyBlueprint'?: number;
    /**
    * jobs_started_invention integer
    */
    'jobsStartedInvention'?: number;
    /**
    * jobs_started_manufacture integer
    */
    'jobsStartedManufacture'?: number;
    /**
    * jobs_started_material_productivity integer
    */
    'jobsStartedMaterialProductivity'?: number;
    /**
    * jobs_started_time_productivity integer
    */
    'jobsStartedTimeProductivity'?: number;
    /**
    * reprocess_item integer
    */
    'reprocessItem'?: number;
    /**
    * reprocess_item_quantity integer
    */
    'reprocessItemQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hackingSuccesses",
            "baseName": "hacking_successes",
            "type": "number"
        },
        {
            "name": "jobsCancelled",
            "baseName": "jobs_cancelled",
            "type": "number"
        },
        {
            "name": "jobsCompletedCopyBlueprint",
            "baseName": "jobs_completed_copy_blueprint",
            "type": "number"
        },
        {
            "name": "jobsCompletedInvention",
            "baseName": "jobs_completed_invention",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufacture",
            "baseName": "jobs_completed_manufacture",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureAsteroid",
            "baseName": "jobs_completed_manufacture_asteroid",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureAsteroidQuantity",
            "baseName": "jobs_completed_manufacture_asteroid_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureCharge",
            "baseName": "jobs_completed_manufacture_charge",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureChargeQuantity",
            "baseName": "jobs_completed_manufacture_charge_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureCommodity",
            "baseName": "jobs_completed_manufacture_commodity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureCommodityQuantity",
            "baseName": "jobs_completed_manufacture_commodity_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureDeployable",
            "baseName": "jobs_completed_manufacture_deployable",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureDeployableQuantity",
            "baseName": "jobs_completed_manufacture_deployable_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureDrone",
            "baseName": "jobs_completed_manufacture_drone",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureDroneQuantity",
            "baseName": "jobs_completed_manufacture_drone_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureImplant",
            "baseName": "jobs_completed_manufacture_implant",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureImplantQuantity",
            "baseName": "jobs_completed_manufacture_implant_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureModule",
            "baseName": "jobs_completed_manufacture_module",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureModuleQuantity",
            "baseName": "jobs_completed_manufacture_module_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureOther",
            "baseName": "jobs_completed_manufacture_other",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureOtherQuantity",
            "baseName": "jobs_completed_manufacture_other_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureShip",
            "baseName": "jobs_completed_manufacture_ship",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureShipQuantity",
            "baseName": "jobs_completed_manufacture_ship_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureStructure",
            "baseName": "jobs_completed_manufacture_structure",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureStructureQuantity",
            "baseName": "jobs_completed_manufacture_structure_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureSubsystem",
            "baseName": "jobs_completed_manufacture_subsystem",
            "type": "number"
        },
        {
            "name": "jobsCompletedManufactureSubsystemQuantity",
            "baseName": "jobs_completed_manufacture_subsystem_quantity",
            "type": "number"
        },
        {
            "name": "jobsCompletedMaterialProductivity",
            "baseName": "jobs_completed_material_productivity",
            "type": "number"
        },
        {
            "name": "jobsCompletedTimeProductivity",
            "baseName": "jobs_completed_time_productivity",
            "type": "number"
        },
        {
            "name": "jobsStartedCopyBlueprint",
            "baseName": "jobs_started_copy_blueprint",
            "type": "number"
        },
        {
            "name": "jobsStartedInvention",
            "baseName": "jobs_started_invention",
            "type": "number"
        },
        {
            "name": "jobsStartedManufacture",
            "baseName": "jobs_started_manufacture",
            "type": "number"
        },
        {
            "name": "jobsStartedMaterialProductivity",
            "baseName": "jobs_started_material_productivity",
            "type": "number"
        },
        {
            "name": "jobsStartedTimeProductivity",
            "baseName": "jobs_started_time_productivity",
            "type": "number"
        },
        {
            "name": "reprocessItem",
            "baseName": "reprocess_item",
            "type": "number"
        },
        {
            "name": "reprocessItemQuantity",
            "baseName": "reprocess_item_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsIndustry.attributeTypeMap;
    }
}

/**
* inventory object
*/
export class GetCharactersCharacterIdStatsInventory {
    /**
    * abandon_loot_quantity integer
    */
    'abandonLootQuantity'?: number;
    /**
    * trash_item_quantity integer
    */
    'trashItemQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "abandonLootQuantity",
            "baseName": "abandon_loot_quantity",
            "type": "number"
        },
        {
            "name": "trashItemQuantity",
            "baseName": "trash_item_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsInventory.attributeTypeMap;
    }
}

/**
* isk object
*/
export class GetCharactersCharacterIdStatsIsk {
    /**
    * in integer
    */
    '_in'?: number;
    /**
    * out integer
    */
    'out'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_in",
            "baseName": "in",
            "type": "number"
        },
        {
            "name": "out",
            "baseName": "out",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsIsk.attributeTypeMap;
    }
}

/**
* market object
*/
export class GetCharactersCharacterIdStatsMarket {
    /**
    * accept_contracts_courier integer
    */
    'acceptContractsCourier'?: number;
    /**
    * accept_contracts_item_exchange integer
    */
    'acceptContractsItemExchange'?: number;
    /**
    * buy_orders_placed integer
    */
    'buyOrdersPlaced'?: number;
    /**
    * cancel_market_order integer
    */
    'cancelMarketOrder'?: number;
    /**
    * create_contracts_auction integer
    */
    'createContractsAuction'?: number;
    /**
    * create_contracts_courier integer
    */
    'createContractsCourier'?: number;
    /**
    * create_contracts_item_exchange integer
    */
    'createContractsItemExchange'?: number;
    /**
    * deliver_courier_contract integer
    */
    'deliverCourierContract'?: number;
    /**
    * isk_gained integer
    */
    'iskGained'?: number;
    /**
    * isk_spent integer
    */
    'iskSpent'?: number;
    /**
    * modify_market_order integer
    */
    'modifyMarketOrder'?: number;
    /**
    * search_contracts integer
    */
    'searchContracts'?: number;
    /**
    * sell_orders_placed integer
    */
    'sellOrdersPlaced'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acceptContractsCourier",
            "baseName": "accept_contracts_courier",
            "type": "number"
        },
        {
            "name": "acceptContractsItemExchange",
            "baseName": "accept_contracts_item_exchange",
            "type": "number"
        },
        {
            "name": "buyOrdersPlaced",
            "baseName": "buy_orders_placed",
            "type": "number"
        },
        {
            "name": "cancelMarketOrder",
            "baseName": "cancel_market_order",
            "type": "number"
        },
        {
            "name": "createContractsAuction",
            "baseName": "create_contracts_auction",
            "type": "number"
        },
        {
            "name": "createContractsCourier",
            "baseName": "create_contracts_courier",
            "type": "number"
        },
        {
            "name": "createContractsItemExchange",
            "baseName": "create_contracts_item_exchange",
            "type": "number"
        },
        {
            "name": "deliverCourierContract",
            "baseName": "deliver_courier_contract",
            "type": "number"
        },
        {
            "name": "iskGained",
            "baseName": "isk_gained",
            "type": "number"
        },
        {
            "name": "iskSpent",
            "baseName": "isk_spent",
            "type": "number"
        },
        {
            "name": "modifyMarketOrder",
            "baseName": "modify_market_order",
            "type": "number"
        },
        {
            "name": "searchContracts",
            "baseName": "search_contracts",
            "type": "number"
        },
        {
            "name": "sellOrdersPlaced",
            "baseName": "sell_orders_placed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsMarket.attributeTypeMap;
    }
}

/**
* mining object
*/
export class GetCharactersCharacterIdStatsMining {
    /**
    * drone_mine integer
    */
    'droneMine'?: number;
    /**
    * ore_arkonor integer
    */
    'oreArkonor'?: number;
    /**
    * ore_bistot integer
    */
    'oreBistot'?: number;
    /**
    * ore_crokite integer
    */
    'oreCrokite'?: number;
    /**
    * ore_dark_ochre integer
    */
    'oreDarkOchre'?: number;
    /**
    * ore_gneiss integer
    */
    'oreGneiss'?: number;
    /**
    * ore_harvestable_cloud integer
    */
    'oreHarvestableCloud'?: number;
    /**
    * ore_hedbergite integer
    */
    'oreHedbergite'?: number;
    /**
    * ore_hemorphite integer
    */
    'oreHemorphite'?: number;
    /**
    * ore_ice integer
    */
    'oreIce'?: number;
    /**
    * ore_jaspet integer
    */
    'oreJaspet'?: number;
    /**
    * ore_kernite integer
    */
    'oreKernite'?: number;
    /**
    * ore_mercoxit integer
    */
    'oreMercoxit'?: number;
    /**
    * ore_omber integer
    */
    'oreOmber'?: number;
    /**
    * ore_plagioclase integer
    */
    'orePlagioclase'?: number;
    /**
    * ore_pyroxeres integer
    */
    'orePyroxeres'?: number;
    /**
    * ore_scordite integer
    */
    'oreScordite'?: number;
    /**
    * ore_spodumain integer
    */
    'oreSpodumain'?: number;
    /**
    * ore_veldspar integer
    */
    'oreVeldspar'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "droneMine",
            "baseName": "drone_mine",
            "type": "number"
        },
        {
            "name": "oreArkonor",
            "baseName": "ore_arkonor",
            "type": "number"
        },
        {
            "name": "oreBistot",
            "baseName": "ore_bistot",
            "type": "number"
        },
        {
            "name": "oreCrokite",
            "baseName": "ore_crokite",
            "type": "number"
        },
        {
            "name": "oreDarkOchre",
            "baseName": "ore_dark_ochre",
            "type": "number"
        },
        {
            "name": "oreGneiss",
            "baseName": "ore_gneiss",
            "type": "number"
        },
        {
            "name": "oreHarvestableCloud",
            "baseName": "ore_harvestable_cloud",
            "type": "number"
        },
        {
            "name": "oreHedbergite",
            "baseName": "ore_hedbergite",
            "type": "number"
        },
        {
            "name": "oreHemorphite",
            "baseName": "ore_hemorphite",
            "type": "number"
        },
        {
            "name": "oreIce",
            "baseName": "ore_ice",
            "type": "number"
        },
        {
            "name": "oreJaspet",
            "baseName": "ore_jaspet",
            "type": "number"
        },
        {
            "name": "oreKernite",
            "baseName": "ore_kernite",
            "type": "number"
        },
        {
            "name": "oreMercoxit",
            "baseName": "ore_mercoxit",
            "type": "number"
        },
        {
            "name": "oreOmber",
            "baseName": "ore_omber",
            "type": "number"
        },
        {
            "name": "orePlagioclase",
            "baseName": "ore_plagioclase",
            "type": "number"
        },
        {
            "name": "orePyroxeres",
            "baseName": "ore_pyroxeres",
            "type": "number"
        },
        {
            "name": "oreScordite",
            "baseName": "ore_scordite",
            "type": "number"
        },
        {
            "name": "oreSpodumain",
            "baseName": "ore_spodumain",
            "type": "number"
        },
        {
            "name": "oreVeldspar",
            "baseName": "ore_veldspar",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsMining.attributeTypeMap;
    }
}

/**
* module object
*/
export class GetCharactersCharacterIdStatsModule {
    /**
    * activations_armor_hardener integer
    */
    'activationsArmorHardener'?: number;
    /**
    * activations_armor_repair_unit integer
    */
    'activationsArmorRepairUnit'?: number;
    /**
    * activations_armor_resistance_shift_hardener integer
    */
    'activationsArmorResistanceShiftHardener'?: number;
    /**
    * activations_automated_targeting_system integer
    */
    'activationsAutomatedTargetingSystem'?: number;
    /**
    * activations_bastion integer
    */
    'activationsBastion'?: number;
    /**
    * activations_bomb_launcher integer
    */
    'activationsBombLauncher'?: number;
    /**
    * activations_capacitor_booster integer
    */
    'activationsCapacitorBooster'?: number;
    /**
    * activations_cargo_scanner integer
    */
    'activationsCargoScanner'?: number;
    /**
    * activations_cloaking_device integer
    */
    'activationsCloakingDevice'?: number;
    /**
    * activations_clone_vat_bay integer
    */
    'activationsCloneVatBay'?: number;
    /**
    * activations_cynosural_field integer
    */
    'activationsCynosuralField'?: number;
    /**
    * activations_damage_control integer
    */
    'activationsDamageControl'?: number;
    /**
    * activations_data_miners integer
    */
    'activationsDataMiners'?: number;
    /**
    * activations_drone_control_unit integer
    */
    'activationsDroneControlUnit'?: number;
    /**
    * activations_drone_tracking_modules integer
    */
    'activationsDroneTrackingModules'?: number;
    /**
    * activations_eccm integer
    */
    'activationsEccm'?: number;
    /**
    * activations_ecm integer
    */
    'activationsEcm'?: number;
    /**
    * activations_ecm_burst integer
    */
    'activationsEcmBurst'?: number;
    /**
    * activations_energy_destabilizer integer
    */
    'activationsEnergyDestabilizer'?: number;
    /**
    * activations_energy_vampire integer
    */
    'activationsEnergyVampire'?: number;
    /**
    * activations_energy_weapon integer
    */
    'activationsEnergyWeapon'?: number;
    /**
    * activations_festival_launcher integer
    */
    'activationsFestivalLauncher'?: number;
    /**
    * activations_frequency_mining_laser integer
    */
    'activationsFrequencyMiningLaser'?: number;
    /**
    * activations_fueled_armor_repairer integer
    */
    'activationsFueledArmorRepairer'?: number;
    /**
    * activations_fueled_shield_booster integer
    */
    'activationsFueledShieldBooster'?: number;
    /**
    * activations_gang_coordinator integer
    */
    'activationsGangCoordinator'?: number;
    /**
    * activations_gas_cloud_harvester integer
    */
    'activationsGasCloudHarvester'?: number;
    /**
    * activations_hull_repair_unit integer
    */
    'activationsHullRepairUnit'?: number;
    /**
    * activations_hybrid_weapon integer
    */
    'activationsHybridWeapon'?: number;
    /**
    * activations_industrial_core integer
    */
    'activationsIndustrialCore'?: number;
    /**
    * activations_interdiction_sphere_launcher integer
    */
    'activationsInterdictionSphereLauncher'?: number;
    /**
    * activations_micro_jump_drive integer
    */
    'activationsMicroJumpDrive'?: number;
    /**
    * activations_mining_laser integer
    */
    'activationsMiningLaser'?: number;
    /**
    * activations_missile_launcher integer
    */
    'activationsMissileLauncher'?: number;
    /**
    * activations_passive_targeting_system integer
    */
    'activationsPassiveTargetingSystem'?: number;
    /**
    * activations_probe_launcher integer
    */
    'activationsProbeLauncher'?: number;
    /**
    * activations_projected_eccm integer
    */
    'activationsProjectedEccm'?: number;
    /**
    * activations_projectile_weapon integer
    */
    'activationsProjectileWeapon'?: number;
    /**
    * activations_propulsion_module integer
    */
    'activationsPropulsionModule'?: number;
    /**
    * activations_remote_armor_repairer integer
    */
    'activationsRemoteArmorRepairer'?: number;
    /**
    * activations_remote_capacitor_transmitter integer
    */
    'activationsRemoteCapacitorTransmitter'?: number;
    /**
    * activations_remote_ecm_burst integer
    */
    'activationsRemoteEcmBurst'?: number;
    /**
    * activations_remote_hull_repairer integer
    */
    'activationsRemoteHullRepairer'?: number;
    /**
    * activations_remote_sensor_booster integer
    */
    'activationsRemoteSensorBooster'?: number;
    /**
    * activations_remote_sensor_damper integer
    */
    'activationsRemoteSensorDamper'?: number;
    /**
    * activations_remote_shield_booster integer
    */
    'activationsRemoteShieldBooster'?: number;
    /**
    * activations_remote_tracking_computer integer
    */
    'activationsRemoteTrackingComputer'?: number;
    /**
    * activations_salvager integer
    */
    'activationsSalvager'?: number;
    /**
    * activations_sensor_booster integer
    */
    'activationsSensorBooster'?: number;
    /**
    * activations_shield_booster integer
    */
    'activationsShieldBooster'?: number;
    /**
    * activations_shield_hardener integer
    */
    'activationsShieldHardener'?: number;
    /**
    * activations_ship_scanner integer
    */
    'activationsShipScanner'?: number;
    /**
    * activations_siege integer
    */
    'activationsSiege'?: number;
    /**
    * activations_smart_bomb integer
    */
    'activationsSmartBomb'?: number;
    /**
    * activations_stasis_web integer
    */
    'activationsStasisWeb'?: number;
    /**
    * activations_strip_miner integer
    */
    'activationsStripMiner'?: number;
    /**
    * activations_super_weapon integer
    */
    'activationsSuperWeapon'?: number;
    /**
    * activations_survey_scanner integer
    */
    'activationsSurveyScanner'?: number;
    /**
    * activations_target_breaker integer
    */
    'activationsTargetBreaker'?: number;
    /**
    * activations_target_painter integer
    */
    'activationsTargetPainter'?: number;
    /**
    * activations_tracking_computer integer
    */
    'activationsTrackingComputer'?: number;
    /**
    * activations_tracking_disruptor integer
    */
    'activationsTrackingDisruptor'?: number;
    /**
    * activations_tractor_beam integer
    */
    'activationsTractorBeam'?: number;
    /**
    * activations_triage integer
    */
    'activationsTriage'?: number;
    /**
    * activations_warp_disrupt_field_generator integer
    */
    'activationsWarpDisruptFieldGenerator'?: number;
    /**
    * activations_warp_scrambler integer
    */
    'activationsWarpScrambler'?: number;
    /**
    * link_weapons integer
    */
    'linkWeapons'?: number;
    /**
    * overload integer
    */
    'overload'?: number;
    /**
    * repairs integer
    */
    'repairs'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activationsArmorHardener",
            "baseName": "activations_armor_hardener",
            "type": "number"
        },
        {
            "name": "activationsArmorRepairUnit",
            "baseName": "activations_armor_repair_unit",
            "type": "number"
        },
        {
            "name": "activationsArmorResistanceShiftHardener",
            "baseName": "activations_armor_resistance_shift_hardener",
            "type": "number"
        },
        {
            "name": "activationsAutomatedTargetingSystem",
            "baseName": "activations_automated_targeting_system",
            "type": "number"
        },
        {
            "name": "activationsBastion",
            "baseName": "activations_bastion",
            "type": "number"
        },
        {
            "name": "activationsBombLauncher",
            "baseName": "activations_bomb_launcher",
            "type": "number"
        },
        {
            "name": "activationsCapacitorBooster",
            "baseName": "activations_capacitor_booster",
            "type": "number"
        },
        {
            "name": "activationsCargoScanner",
            "baseName": "activations_cargo_scanner",
            "type": "number"
        },
        {
            "name": "activationsCloakingDevice",
            "baseName": "activations_cloaking_device",
            "type": "number"
        },
        {
            "name": "activationsCloneVatBay",
            "baseName": "activations_clone_vat_bay",
            "type": "number"
        },
        {
            "name": "activationsCynosuralField",
            "baseName": "activations_cynosural_field",
            "type": "number"
        },
        {
            "name": "activationsDamageControl",
            "baseName": "activations_damage_control",
            "type": "number"
        },
        {
            "name": "activationsDataMiners",
            "baseName": "activations_data_miners",
            "type": "number"
        },
        {
            "name": "activationsDroneControlUnit",
            "baseName": "activations_drone_control_unit",
            "type": "number"
        },
        {
            "name": "activationsDroneTrackingModules",
            "baseName": "activations_drone_tracking_modules",
            "type": "number"
        },
        {
            "name": "activationsEccm",
            "baseName": "activations_eccm",
            "type": "number"
        },
        {
            "name": "activationsEcm",
            "baseName": "activations_ecm",
            "type": "number"
        },
        {
            "name": "activationsEcmBurst",
            "baseName": "activations_ecm_burst",
            "type": "number"
        },
        {
            "name": "activationsEnergyDestabilizer",
            "baseName": "activations_energy_destabilizer",
            "type": "number"
        },
        {
            "name": "activationsEnergyVampire",
            "baseName": "activations_energy_vampire",
            "type": "number"
        },
        {
            "name": "activationsEnergyWeapon",
            "baseName": "activations_energy_weapon",
            "type": "number"
        },
        {
            "name": "activationsFestivalLauncher",
            "baseName": "activations_festival_launcher",
            "type": "number"
        },
        {
            "name": "activationsFrequencyMiningLaser",
            "baseName": "activations_frequency_mining_laser",
            "type": "number"
        },
        {
            "name": "activationsFueledArmorRepairer",
            "baseName": "activations_fueled_armor_repairer",
            "type": "number"
        },
        {
            "name": "activationsFueledShieldBooster",
            "baseName": "activations_fueled_shield_booster",
            "type": "number"
        },
        {
            "name": "activationsGangCoordinator",
            "baseName": "activations_gang_coordinator",
            "type": "number"
        },
        {
            "name": "activationsGasCloudHarvester",
            "baseName": "activations_gas_cloud_harvester",
            "type": "number"
        },
        {
            "name": "activationsHullRepairUnit",
            "baseName": "activations_hull_repair_unit",
            "type": "number"
        },
        {
            "name": "activationsHybridWeapon",
            "baseName": "activations_hybrid_weapon",
            "type": "number"
        },
        {
            "name": "activationsIndustrialCore",
            "baseName": "activations_industrial_core",
            "type": "number"
        },
        {
            "name": "activationsInterdictionSphereLauncher",
            "baseName": "activations_interdiction_sphere_launcher",
            "type": "number"
        },
        {
            "name": "activationsMicroJumpDrive",
            "baseName": "activations_micro_jump_drive",
            "type": "number"
        },
        {
            "name": "activationsMiningLaser",
            "baseName": "activations_mining_laser",
            "type": "number"
        },
        {
            "name": "activationsMissileLauncher",
            "baseName": "activations_missile_launcher",
            "type": "number"
        },
        {
            "name": "activationsPassiveTargetingSystem",
            "baseName": "activations_passive_targeting_system",
            "type": "number"
        },
        {
            "name": "activationsProbeLauncher",
            "baseName": "activations_probe_launcher",
            "type": "number"
        },
        {
            "name": "activationsProjectedEccm",
            "baseName": "activations_projected_eccm",
            "type": "number"
        },
        {
            "name": "activationsProjectileWeapon",
            "baseName": "activations_projectile_weapon",
            "type": "number"
        },
        {
            "name": "activationsPropulsionModule",
            "baseName": "activations_propulsion_module",
            "type": "number"
        },
        {
            "name": "activationsRemoteArmorRepairer",
            "baseName": "activations_remote_armor_repairer",
            "type": "number"
        },
        {
            "name": "activationsRemoteCapacitorTransmitter",
            "baseName": "activations_remote_capacitor_transmitter",
            "type": "number"
        },
        {
            "name": "activationsRemoteEcmBurst",
            "baseName": "activations_remote_ecm_burst",
            "type": "number"
        },
        {
            "name": "activationsRemoteHullRepairer",
            "baseName": "activations_remote_hull_repairer",
            "type": "number"
        },
        {
            "name": "activationsRemoteSensorBooster",
            "baseName": "activations_remote_sensor_booster",
            "type": "number"
        },
        {
            "name": "activationsRemoteSensorDamper",
            "baseName": "activations_remote_sensor_damper",
            "type": "number"
        },
        {
            "name": "activationsRemoteShieldBooster",
            "baseName": "activations_remote_shield_booster",
            "type": "number"
        },
        {
            "name": "activationsRemoteTrackingComputer",
            "baseName": "activations_remote_tracking_computer",
            "type": "number"
        },
        {
            "name": "activationsSalvager",
            "baseName": "activations_salvager",
            "type": "number"
        },
        {
            "name": "activationsSensorBooster",
            "baseName": "activations_sensor_booster",
            "type": "number"
        },
        {
            "name": "activationsShieldBooster",
            "baseName": "activations_shield_booster",
            "type": "number"
        },
        {
            "name": "activationsShieldHardener",
            "baseName": "activations_shield_hardener",
            "type": "number"
        },
        {
            "name": "activationsShipScanner",
            "baseName": "activations_ship_scanner",
            "type": "number"
        },
        {
            "name": "activationsSiege",
            "baseName": "activations_siege",
            "type": "number"
        },
        {
            "name": "activationsSmartBomb",
            "baseName": "activations_smart_bomb",
            "type": "number"
        },
        {
            "name": "activationsStasisWeb",
            "baseName": "activations_stasis_web",
            "type": "number"
        },
        {
            "name": "activationsStripMiner",
            "baseName": "activations_strip_miner",
            "type": "number"
        },
        {
            "name": "activationsSuperWeapon",
            "baseName": "activations_super_weapon",
            "type": "number"
        },
        {
            "name": "activationsSurveyScanner",
            "baseName": "activations_survey_scanner",
            "type": "number"
        },
        {
            "name": "activationsTargetBreaker",
            "baseName": "activations_target_breaker",
            "type": "number"
        },
        {
            "name": "activationsTargetPainter",
            "baseName": "activations_target_painter",
            "type": "number"
        },
        {
            "name": "activationsTrackingComputer",
            "baseName": "activations_tracking_computer",
            "type": "number"
        },
        {
            "name": "activationsTrackingDisruptor",
            "baseName": "activations_tracking_disruptor",
            "type": "number"
        },
        {
            "name": "activationsTractorBeam",
            "baseName": "activations_tractor_beam",
            "type": "number"
        },
        {
            "name": "activationsTriage",
            "baseName": "activations_triage",
            "type": "number"
        },
        {
            "name": "activationsWarpDisruptFieldGenerator",
            "baseName": "activations_warp_disrupt_field_generator",
            "type": "number"
        },
        {
            "name": "activationsWarpScrambler",
            "baseName": "activations_warp_scrambler",
            "type": "number"
        },
        {
            "name": "linkWeapons",
            "baseName": "link_weapons",
            "type": "number"
        },
        {
            "name": "overload",
            "baseName": "overload",
            "type": "number"
        },
        {
            "name": "repairs",
            "baseName": "repairs",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsModule.attributeTypeMap;
    }
}

/**
* orbital object
*/
export class GetCharactersCharacterIdStatsOrbital {
    /**
    * strike_characters_killed integer
    */
    'strikeCharactersKilled'?: number;
    /**
    * strike_damage_to_players_armor_amount integer
    */
    'strikeDamageToPlayersArmorAmount'?: number;
    /**
    * strike_damage_to_players_shield_amount integer
    */
    'strikeDamageToPlayersShieldAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "strikeCharactersKilled",
            "baseName": "strike_characters_killed",
            "type": "number"
        },
        {
            "name": "strikeDamageToPlayersArmorAmount",
            "baseName": "strike_damage_to_players_armor_amount",
            "type": "number"
        },
        {
            "name": "strikeDamageToPlayersShieldAmount",
            "baseName": "strike_damage_to_players_shield_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsOrbital.attributeTypeMap;
    }
}

/**
* pve object
*/
export class GetCharactersCharacterIdStatsPve {
    /**
    * dungeons_completed_agent integer
    */
    'dungeonsCompletedAgent'?: number;
    /**
    * dungeons_completed_distribution integer
    */
    'dungeonsCompletedDistribution'?: number;
    /**
    * missions_succeeded integer
    */
    'missionsSucceeded'?: number;
    /**
    * missions_succeeded_epic_arc integer
    */
    'missionsSucceededEpicArc'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dungeonsCompletedAgent",
            "baseName": "dungeons_completed_agent",
            "type": "number"
        },
        {
            "name": "dungeonsCompletedDistribution",
            "baseName": "dungeons_completed_distribution",
            "type": "number"
        },
        {
            "name": "missionsSucceeded",
            "baseName": "missions_succeeded",
            "type": "number"
        },
        {
            "name": "missionsSucceededEpicArc",
            "baseName": "missions_succeeded_epic_arc",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsPve.attributeTypeMap;
    }
}

/**
* social object
*/
export class GetCharactersCharacterIdStatsSocial {
    /**
    * add_contact_bad integer
    */
    'addContactBad'?: number;
    /**
    * add_contact_good integer
    */
    'addContactGood'?: number;
    /**
    * add_contact_high integer
    */
    'addContactHigh'?: number;
    /**
    * add_contact_horrible integer
    */
    'addContactHorrible'?: number;
    /**
    * add_contact_neutral integer
    */
    'addContactNeutral'?: number;
    /**
    * add_note integer
    */
    'addNote'?: number;
    /**
    * added_as_contact_bad integer
    */
    'addedAsContactBad'?: number;
    /**
    * added_as_contact_good integer
    */
    'addedAsContactGood'?: number;
    /**
    * added_as_contact_high integer
    */
    'addedAsContactHigh'?: number;
    /**
    * added_as_contact_horrible integer
    */
    'addedAsContactHorrible'?: number;
    /**
    * added_as_contact_neutral integer
    */
    'addedAsContactNeutral'?: number;
    /**
    * calendar_event_created integer
    */
    'calendarEventCreated'?: number;
    /**
    * chat_messages_alliance integer
    */
    'chatMessagesAlliance'?: number;
    /**
    * chat_messages_constellation integer
    */
    'chatMessagesConstellation'?: number;
    /**
    * chat_messages_corporation integer
    */
    'chatMessagesCorporation'?: number;
    /**
    * chat_messages_fleet integer
    */
    'chatMessagesFleet'?: number;
    /**
    * chat_messages_region integer
    */
    'chatMessagesRegion'?: number;
    /**
    * chat_messages_solarsystem integer
    */
    'chatMessagesSolarsystem'?: number;
    /**
    * chat_messages_warfaction integer
    */
    'chatMessagesWarfaction'?: number;
    /**
    * chat_total_message_length integer
    */
    'chatTotalMessageLength'?: number;
    /**
    * direct_trades integer
    */
    'directTrades'?: number;
    /**
    * fleet_broadcasts integer
    */
    'fleetBroadcasts'?: number;
    /**
    * fleet_joins integer
    */
    'fleetJoins'?: number;
    /**
    * mails_received integer
    */
    'mailsReceived'?: number;
    /**
    * mails_sent integer
    */
    'mailsSent'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addContactBad",
            "baseName": "add_contact_bad",
            "type": "number"
        },
        {
            "name": "addContactGood",
            "baseName": "add_contact_good",
            "type": "number"
        },
        {
            "name": "addContactHigh",
            "baseName": "add_contact_high",
            "type": "number"
        },
        {
            "name": "addContactHorrible",
            "baseName": "add_contact_horrible",
            "type": "number"
        },
        {
            "name": "addContactNeutral",
            "baseName": "add_contact_neutral",
            "type": "number"
        },
        {
            "name": "addNote",
            "baseName": "add_note",
            "type": "number"
        },
        {
            "name": "addedAsContactBad",
            "baseName": "added_as_contact_bad",
            "type": "number"
        },
        {
            "name": "addedAsContactGood",
            "baseName": "added_as_contact_good",
            "type": "number"
        },
        {
            "name": "addedAsContactHigh",
            "baseName": "added_as_contact_high",
            "type": "number"
        },
        {
            "name": "addedAsContactHorrible",
            "baseName": "added_as_contact_horrible",
            "type": "number"
        },
        {
            "name": "addedAsContactNeutral",
            "baseName": "added_as_contact_neutral",
            "type": "number"
        },
        {
            "name": "calendarEventCreated",
            "baseName": "calendar_event_created",
            "type": "number"
        },
        {
            "name": "chatMessagesAlliance",
            "baseName": "chat_messages_alliance",
            "type": "number"
        },
        {
            "name": "chatMessagesConstellation",
            "baseName": "chat_messages_constellation",
            "type": "number"
        },
        {
            "name": "chatMessagesCorporation",
            "baseName": "chat_messages_corporation",
            "type": "number"
        },
        {
            "name": "chatMessagesFleet",
            "baseName": "chat_messages_fleet",
            "type": "number"
        },
        {
            "name": "chatMessagesRegion",
            "baseName": "chat_messages_region",
            "type": "number"
        },
        {
            "name": "chatMessagesSolarsystem",
            "baseName": "chat_messages_solarsystem",
            "type": "number"
        },
        {
            "name": "chatMessagesWarfaction",
            "baseName": "chat_messages_warfaction",
            "type": "number"
        },
        {
            "name": "chatTotalMessageLength",
            "baseName": "chat_total_message_length",
            "type": "number"
        },
        {
            "name": "directTrades",
            "baseName": "direct_trades",
            "type": "number"
        },
        {
            "name": "fleetBroadcasts",
            "baseName": "fleet_broadcasts",
            "type": "number"
        },
        {
            "name": "fleetJoins",
            "baseName": "fleet_joins",
            "type": "number"
        },
        {
            "name": "mailsReceived",
            "baseName": "mails_received",
            "type": "number"
        },
        {
            "name": "mailsSent",
            "baseName": "mails_sent",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsSocial.attributeTypeMap;
    }
}

/**
* travel object
*/
export class GetCharactersCharacterIdStatsTravel {
    /**
    * acceleration_gate_activations integer
    */
    'accelerationGateActivations'?: number;
    /**
    * align_to integer
    */
    'alignTo'?: number;
    /**
    * distance_warped_high_sec integer
    */
    'distanceWarpedHighSec'?: number;
    /**
    * distance_warped_low_sec integer
    */
    'distanceWarpedLowSec'?: number;
    /**
    * distance_warped_null_sec integer
    */
    'distanceWarpedNullSec'?: number;
    /**
    * distance_warped_wormhole integer
    */
    'distanceWarpedWormhole'?: number;
    /**
    * docks_high_sec integer
    */
    'docksHighSec'?: number;
    /**
    * docks_low_sec integer
    */
    'docksLowSec'?: number;
    /**
    * docks_null_sec integer
    */
    'docksNullSec'?: number;
    /**
    * jumps_stargate_high_sec integer
    */
    'jumpsStargateHighSec'?: number;
    /**
    * jumps_stargate_low_sec integer
    */
    'jumpsStargateLowSec'?: number;
    /**
    * jumps_stargate_null_sec integer
    */
    'jumpsStargateNullSec'?: number;
    /**
    * jumps_wormhole integer
    */
    'jumpsWormhole'?: number;
    /**
    * warps_high_sec integer
    */
    'warpsHighSec'?: number;
    /**
    * warps_low_sec integer
    */
    'warpsLowSec'?: number;
    /**
    * warps_null_sec integer
    */
    'warpsNullSec'?: number;
    /**
    * warps_to_bookmark integer
    */
    'warpsToBookmark'?: number;
    /**
    * warps_to_celestial integer
    */
    'warpsToCelestial'?: number;
    /**
    * warps_to_fleet_member integer
    */
    'warpsToFleetMember'?: number;
    /**
    * warps_to_scan_result integer
    */
    'warpsToScanResult'?: number;
    /**
    * warps_wormhole integer
    */
    'warpsWormhole'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accelerationGateActivations",
            "baseName": "acceleration_gate_activations",
            "type": "number"
        },
        {
            "name": "alignTo",
            "baseName": "align_to",
            "type": "number"
        },
        {
            "name": "distanceWarpedHighSec",
            "baseName": "distance_warped_high_sec",
            "type": "number"
        },
        {
            "name": "distanceWarpedLowSec",
            "baseName": "distance_warped_low_sec",
            "type": "number"
        },
        {
            "name": "distanceWarpedNullSec",
            "baseName": "distance_warped_null_sec",
            "type": "number"
        },
        {
            "name": "distanceWarpedWormhole",
            "baseName": "distance_warped_wormhole",
            "type": "number"
        },
        {
            "name": "docksHighSec",
            "baseName": "docks_high_sec",
            "type": "number"
        },
        {
            "name": "docksLowSec",
            "baseName": "docks_low_sec",
            "type": "number"
        },
        {
            "name": "docksNullSec",
            "baseName": "docks_null_sec",
            "type": "number"
        },
        {
            "name": "jumpsStargateHighSec",
            "baseName": "jumps_stargate_high_sec",
            "type": "number"
        },
        {
            "name": "jumpsStargateLowSec",
            "baseName": "jumps_stargate_low_sec",
            "type": "number"
        },
        {
            "name": "jumpsStargateNullSec",
            "baseName": "jumps_stargate_null_sec",
            "type": "number"
        },
        {
            "name": "jumpsWormhole",
            "baseName": "jumps_wormhole",
            "type": "number"
        },
        {
            "name": "warpsHighSec",
            "baseName": "warps_high_sec",
            "type": "number"
        },
        {
            "name": "warpsLowSec",
            "baseName": "warps_low_sec",
            "type": "number"
        },
        {
            "name": "warpsNullSec",
            "baseName": "warps_null_sec",
            "type": "number"
        },
        {
            "name": "warpsToBookmark",
            "baseName": "warps_to_bookmark",
            "type": "number"
        },
        {
            "name": "warpsToCelestial",
            "baseName": "warps_to_celestial",
            "type": "number"
        },
        {
            "name": "warpsToFleetMember",
            "baseName": "warps_to_fleet_member",
            "type": "number"
        },
        {
            "name": "warpsToScanResult",
            "baseName": "warps_to_scan_result",
            "type": "number"
        },
        {
            "name": "warpsWormhole",
            "baseName": "warps_wormhole",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdStatsTravel.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdTitles200Ok {
    /**
    * name string
    */
    'name'?: string;
    /**
    * title_id integer
    */
    'titleId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "titleId",
            "baseName": "title_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdTitles200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdWalletJournal200Ok {
    /**
    * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
    */
    'amount'?: number;
    /**
    * Wallet balance after transaction occurred
    */
    'balance'?: number;
    /**
    * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
    */
    'contextId'?: number;
    /**
    * The type of the given context_id if present
    */
    'contextIdType'?: GetCharactersCharacterIdWalletJournal200Ok.ContextIdTypeEnum;
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * The reason for the transaction, mirrors what is seen in the client
    */
    'description': string;
    /**
    * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
    */
    'firstPartyId'?: number;
    /**
    * Unique journal reference ID
    */
    'id': number;
    /**
    * The user stated reason for the transaction. Only applies to some ref_types
    */
    'reason'?: string;
    /**
    * \"The transaction type for the given. transaction. Different transaction types will populate different attributes.\"
    */
    'refType': GetCharactersCharacterIdWalletJournal200Ok.RefTypeEnum;
    /**
    * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
    */
    'secondPartyId'?: number;
    /**
    * Tax amount received. Only applies to tax related transactions
    */
    'tax'?: number;
    /**
    * The corporation ID receiving any tax paid. Only applies to tax related transactions
    */
    'taxReceiverId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "number"
        },
        {
            "name": "contextIdType",
            "baseName": "context_id_type",
            "type": "GetCharactersCharacterIdWalletJournal200Ok.ContextIdTypeEnum"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "firstPartyId",
            "baseName": "first_party_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "refType",
            "baseName": "ref_type",
            "type": "GetCharactersCharacterIdWalletJournal200Ok.RefTypeEnum"
        },
        {
            "name": "secondPartyId",
            "baseName": "second_party_id",
            "type": "number"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "number"
        },
        {
            "name": "taxReceiverId",
            "baseName": "tax_receiver_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdWalletJournal200Ok.attributeTypeMap;
    }
}

export namespace GetCharactersCharacterIdWalletJournal200Ok {
    export enum ContextIdTypeEnum {
        StructureId = <any> 'structure_id',
        StationId = <any> 'station_id',
        MarketTransactionId = <any> 'market_transaction_id',
        CharacterId = <any> 'character_id',
        CorporationId = <any> 'corporation_id',
        AllianceId = <any> 'alliance_id',
        EveSystem = <any> 'eve_system',
        IndustryJobId = <any> 'industry_job_id',
        ContractId = <any> 'contract_id',
        PlanetId = <any> 'planet_id',
        SystemId = <any> 'system_id',
        TypeId = <any> 'type_id'
    }
    export enum RefTypeEnum {
        AccelerationGateFee = <any> 'acceleration_gate_fee',
        AdvertisementListingFee = <any> 'advertisement_listing_fee',
        AgentDonation = <any> 'agent_donation',
        AgentLocationServices = <any> 'agent_location_services',
        AgentMiscellaneous = <any> 'agent_miscellaneous',
        AgentMissionCollateralPaid = <any> 'agent_mission_collateral_paid',
        AgentMissionCollateralRefunded = <any> 'agent_mission_collateral_refunded',
        AgentMissionReward = <any> 'agent_mission_reward',
        AgentMissionRewardCorporationTax = <any> 'agent_mission_reward_corporation_tax',
        AgentMissionTimeBonusReward = <any> 'agent_mission_time_bonus_reward',
        AgentMissionTimeBonusRewardCorporationTax = <any> 'agent_mission_time_bonus_reward_corporation_tax',
        AgentSecurityServices = <any> 'agent_security_services',
        AgentServicesRendered = <any> 'agent_services_rendered',
        AgentsPreward = <any> 'agents_preward',
        AllianceMaintainanceFee = <any> 'alliance_maintainance_fee',
        AllianceRegistrationFee = <any> 'alliance_registration_fee',
        AssetSafetyRecoveryTax = <any> 'asset_safety_recovery_tax',
        Bounty = <any> 'bounty',
        BountyPrize = <any> 'bounty_prize',
        BountyPrizeCorporationTax = <any> 'bounty_prize_corporation_tax',
        BountyPrizes = <any> 'bounty_prizes',
        BountyReimbursement = <any> 'bounty_reimbursement',
        BountySurcharge = <any> 'bounty_surcharge',
        BrokersFee = <any> 'brokers_fee',
        CloneActivation = <any> 'clone_activation',
        CloneTransfer = <any> 'clone_transfer',
        ContrabandFine = <any> 'contraband_fine',
        ContractAuctionBid = <any> 'contract_auction_bid',
        ContractAuctionBidCorp = <any> 'contract_auction_bid_corp',
        ContractAuctionBidRefund = <any> 'contract_auction_bid_refund',
        ContractAuctionSold = <any> 'contract_auction_sold',
        ContractBrokersFee = <any> 'contract_brokers_fee',
        ContractBrokersFeeCorp = <any> 'contract_brokers_fee_corp',
        ContractCollateral = <any> 'contract_collateral',
        ContractCollateralDepositedCorp = <any> 'contract_collateral_deposited_corp',
        ContractCollateralPayout = <any> 'contract_collateral_payout',
        ContractCollateralRefund = <any> 'contract_collateral_refund',
        ContractDeposit = <any> 'contract_deposit',
        ContractDepositCorp = <any> 'contract_deposit_corp',
        ContractDepositRefund = <any> 'contract_deposit_refund',
        ContractDepositSalesTax = <any> 'contract_deposit_sales_tax',
        ContractPrice = <any> 'contract_price',
        ContractPricePaymentCorp = <any> 'contract_price_payment_corp',
        ContractReversal = <any> 'contract_reversal',
        ContractReward = <any> 'contract_reward',
        ContractRewardDeposited = <any> 'contract_reward_deposited',
        ContractRewardDepositedCorp = <any> 'contract_reward_deposited_corp',
        ContractRewardRefund = <any> 'contract_reward_refund',
        ContractSalesTax = <any> 'contract_sales_tax',
        Copying = <any> 'copying',
        CorporateRewardPayout = <any> 'corporate_reward_payout',
        CorporateRewardTax = <any> 'corporate_reward_tax',
        CorporationAccountWithdrawal = <any> 'corporation_account_withdrawal',
        CorporationBulkPayment = <any> 'corporation_bulk_payment',
        CorporationDividendPayment = <any> 'corporation_dividend_payment',
        CorporationLiquidation = <any> 'corporation_liquidation',
        CorporationLogoChangeCost = <any> 'corporation_logo_change_cost',
        CorporationPayment = <any> 'corporation_payment',
        CorporationRegistrationFee = <any> 'corporation_registration_fee',
        CourierMissionEscrow = <any> 'courier_mission_escrow',
        Cspa = <any> 'cspa',
        Cspaofflinerefund = <any> 'cspaofflinerefund',
        DatacoreFee = <any> 'datacore_fee',
        DnaModificationFee = <any> 'dna_modification_fee',
        DockingFee = <any> 'docking_fee',
        DuelWagerEscrow = <any> 'duel_wager_escrow',
        DuelWagerPayment = <any> 'duel_wager_payment',
        DuelWagerRefund = <any> 'duel_wager_refund',
        FactorySlotRentalFee = <any> 'factory_slot_rental_fee',
        GmCashTransfer = <any> 'gm_cash_transfer',
        IndustryJobTax = <any> 'industry_job_tax',
        InfrastructureHubMaintenance = <any> 'infrastructure_hub_maintenance',
        Inheritance = <any> 'inheritance',
        Insurance = <any> 'insurance',
        ItemTraderPayment = <any> 'item_trader_payment',
        JumpCloneActivationFee = <any> 'jump_clone_activation_fee',
        JumpCloneInstallationFee = <any> 'jump_clone_installation_fee',
        KillRightFee = <any> 'kill_right_fee',
        LpStore = <any> 'lp_store',
        Manufacturing = <any> 'manufacturing',
        MarketEscrow = <any> 'market_escrow',
        MarketFinePaid = <any> 'market_fine_paid',
        MarketTransaction = <any> 'market_transaction',
        MedalCreation = <any> 'medal_creation',
        MedalIssued = <any> 'medal_issued',
        MissionCompletion = <any> 'mission_completion',
        MissionCost = <any> 'mission_cost',
        MissionExpiration = <any> 'mission_expiration',
        MissionReward = <any> 'mission_reward',
        OfficeRentalFee = <any> 'office_rental_fee',
        OperationBonus = <any> 'operation_bonus',
        OpportunityReward = <any> 'opportunity_reward',
        PlanetaryConstruction = <any> 'planetary_construction',
        PlanetaryExportTax = <any> 'planetary_export_tax',
        PlanetaryImportTax = <any> 'planetary_import_tax',
        PlayerDonation = <any> 'player_donation',
        PlayerTrading = <any> 'player_trading',
        ProjectDiscoveryReward = <any> 'project_discovery_reward',
        ProjectDiscoveryTax = <any> 'project_discovery_tax',
        Reaction = <any> 'reaction',
        ReleaseOfImpoundedProperty = <any> 'release_of_impounded_property',
        RepairBill = <any> 'repair_bill',
        ReprocessingTax = <any> 'reprocessing_tax',
        ResearchingMaterialProductivity = <any> 'researching_material_productivity',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeProductivity = <any> 'researching_time_productivity',
        ResourceWarsReward = <any> 'resource_wars_reward',
        ReverseEngineering = <any> 'reverse_engineering',
        SecurityProcessingFee = <any> 'security_processing_fee',
        Shares = <any> 'shares',
        SkillPurchase = <any> 'skill_purchase',
        SovereignityBill = <any> 'sovereignity_bill',
        StorePurchase = <any> 'store_purchase',
        StorePurchaseRefund = <any> 'store_purchase_refund',
        StructureGateJump = <any> 'structure_gate_jump',
        TransactionTax = <any> 'transaction_tax',
        UpkeepAdjustmentFee = <any> 'upkeep_adjustment_fee',
        WarAllyContract = <any> 'war_ally_contract',
        WarFee = <any> 'war_fee',
        WarFeeSurrender = <any> 'war_fee_surrender'
    }
}
/**
* wallet transaction
*/
export class GetCharactersCharacterIdWalletTransactions200Ok {
    /**
    * client_id integer
    */
    'clientId': number;
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * is_buy boolean
    */
    'isBuy': boolean;
    /**
    * is_personal boolean
    */
    'isPersonal': boolean;
    /**
    * journal_ref_id integer
    */
    'journalRefId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * Unique transaction ID
    */
    'transactionId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * Amount paid per unit
    */
    'unitPrice': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "isBuy",
            "baseName": "is_buy",
            "type": "boolean"
        },
        {
            "name": "isPersonal",
            "baseName": "is_personal",
            "type": "boolean"
        },
        {
            "name": "journalRefId",
            "baseName": "journal_ref_id",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unit_price",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCharactersCharacterIdWalletTransactions200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetContractsPublicBidsContractId200Ok {
    /**
    * The amount bid, in ISK
    */
    'amount': number;
    /**
    * Unique ID for the bid
    */
    'bidId': number;
    /**
    * Datetime when the bid was placed
    */
    'dateBid': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "bidId",
            "baseName": "bid_id",
            "type": "number"
        },
        {
            "name": "dateBid",
            "baseName": "date_bid",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicBidsContractId200Ok.attributeTypeMap;
    }
}

/**
* Forbidden
*/
export class GetContractsPublicBidsContractIdForbidden {
    /**
    * Forbidden message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicBidsContractIdForbidden.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetContractsPublicBidsContractIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicBidsContractIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetContractsPublicItemsContractId200Ok {
    /**
    * is_blueprint_copy boolean
    */
    'isBlueprintCopy'?: boolean;
    /**
    * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
    */
    'isIncluded': boolean;
    /**
    * Unique ID for the item being sold. Not present if item is being requested by contract rather than sold with contract
    */
    'itemId'?: number;
    /**
    * Material Efficiency Level of the blueprint
    */
    'materialEfficiency'?: number;
    /**
    * Number of items in the stack
    */
    'quantity': number;
    /**
    * Unique ID for the item, used by the contract system
    */
    'recordId': number;
    /**
    * Number of runs remaining if the blueprint is a copy, -1 if it is an original
    */
    'runs'?: number;
    /**
    * Time Efficiency Level of the blueprint
    */
    'timeEfficiency'?: number;
    /**
    * Type ID for item
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isBlueprintCopy",
            "baseName": "is_blueprint_copy",
            "type": "boolean"
        },
        {
            "name": "isIncluded",
            "baseName": "is_included",
            "type": "boolean"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "materialEfficiency",
            "baseName": "material_efficiency",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "number"
        },
        {
            "name": "runs",
            "baseName": "runs",
            "type": "number"
        },
        {
            "name": "timeEfficiency",
            "baseName": "time_efficiency",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicItemsContractId200Ok.attributeTypeMap;
    }
}

/**
* Forbidden
*/
export class GetContractsPublicItemsContractIdForbidden {
    /**
    * Forbidden message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicItemsContractIdForbidden.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetContractsPublicItemsContractIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicItemsContractIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetContractsPublicRegionId200Ok {
    /**
    * Buyout price (for Auctions only)
    */
    'buyout'?: number;
    /**
    * Collateral price (for Couriers only)
    */
    'collateral'?: number;
    /**
    * contract_id integer
    */
    'contractId': number;
    /**
    * Expiration date of the contract
    */
    'dateExpired': Date;
    /**
    * Сreation date of the contract
    */
    'dateIssued': Date;
    /**
    * Number of days to perform the contract
    */
    'daysToComplete'?: number;
    /**
    * End location ID (for Couriers contract)
    */
    'endLocationId'?: number;
    /**
    * true if the contract was issued on behalf of the issuer's corporation
    */
    'forCorporation'?: boolean;
    /**
    * Character's corporation ID for the issuer
    */
    'issuerCorporationId': number;
    /**
    * Character ID for the issuer
    */
    'issuerId': number;
    /**
    * Price of contract (for ItemsExchange and Auctions)
    */
    'price'?: number;
    /**
    * Remuneration for contract (for Couriers only)
    */
    'reward'?: number;
    /**
    * Start location ID (for Couriers contract)
    */
    'startLocationId'?: number;
    /**
    * Title of the contract
    */
    'title'?: string;
    /**
    * Type of the contract
    */
    'type': GetContractsPublicRegionId200Ok.TypeEnum;
    /**
    * Volume of items in the contract
    */
    'volume'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "buyout",
            "baseName": "buyout",
            "type": "number"
        },
        {
            "name": "collateral",
            "baseName": "collateral",
            "type": "number"
        },
        {
            "name": "contractId",
            "baseName": "contract_id",
            "type": "number"
        },
        {
            "name": "dateExpired",
            "baseName": "date_expired",
            "type": "Date"
        },
        {
            "name": "dateIssued",
            "baseName": "date_issued",
            "type": "Date"
        },
        {
            "name": "daysToComplete",
            "baseName": "days_to_complete",
            "type": "number"
        },
        {
            "name": "endLocationId",
            "baseName": "end_location_id",
            "type": "number"
        },
        {
            "name": "forCorporation",
            "baseName": "for_corporation",
            "type": "boolean"
        },
        {
            "name": "issuerCorporationId",
            "baseName": "issuer_corporation_id",
            "type": "number"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "reward",
            "baseName": "reward",
            "type": "number"
        },
        {
            "name": "startLocationId",
            "baseName": "start_location_id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetContractsPublicRegionId200Ok.TypeEnum"
        },
        {
            "name": "volume",
            "baseName": "volume",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicRegionId200Ok.attributeTypeMap;
    }
}

export namespace GetContractsPublicRegionId200Ok {
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
}
/**
* Not found
*/
export class GetContractsPublicRegionIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetContractsPublicRegionIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationCorporationIdMiningExtractions200Ok {
    /**
    * The time at which the chunk being extracted will arrive and can be fractured by the moon mining drill. 
    */
    'chunkArrivalTime': Date;
    /**
    * The time at which the current extraction was initiated. 
    */
    'extractionStartTime': Date;
    /**
    * moon_id integer
    */
    'moonId': number;
    /**
    * The time at which the chunk being extracted will naturally fracture if it is not first fractured by the moon mining drill. 
    */
    'naturalDecayTime': Date;
    /**
    * structure_id integer
    */
    'structureId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "chunkArrivalTime",
            "baseName": "chunk_arrival_time",
            "type": "Date"
        },
        {
            "name": "extractionStartTime",
            "baseName": "extraction_start_time",
            "type": "Date"
        },
        {
            "name": "moonId",
            "baseName": "moon_id",
            "type": "number"
        },
        {
            "name": "naturalDecayTime",
            "baseName": "natural_decay_time",
            "type": "Date"
        },
        {
            "name": "structureId",
            "baseName": "structure_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationCorporationIdMiningExtractions200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationCorporationIdMiningObservers200Ok {
    /**
    * last_updated string
    */
    'lastUpdated': string;
    /**
    * The entity that was observing the asteroid field when it was mined. 
    */
    'observerId': number;
    /**
    * The category of the observing entity
    */
    'observerType': GetCorporationCorporationIdMiningObservers200Ok.ObserverTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastUpdated",
            "baseName": "last_updated",
            "type": "string"
        },
        {
            "name": "observerId",
            "baseName": "observer_id",
            "type": "number"
        },
        {
            "name": "observerType",
            "baseName": "observer_type",
            "type": "GetCorporationCorporationIdMiningObservers200Ok.ObserverTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationCorporationIdMiningObservers200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationCorporationIdMiningObservers200Ok {
    export enum ObserverTypeEnum {
        Structure = <any> 'structure'
    }
}
/**
* 200 ok object
*/
export class GetCorporationCorporationIdMiningObserversObserverId200Ok {
    /**
    * The character that did the mining 
    */
    'characterId': number;
    /**
    * last_updated string
    */
    'lastUpdated': string;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * The corporation id of the character at the time data was recorded. 
    */
    'recordedCorporationId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "lastUpdated",
            "baseName": "last_updated",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "recordedCorporationId",
            "baseName": "recorded_corporation_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationCorporationIdMiningObserversObserverId200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdAlliancehistory200Ok {
    /**
    * alliance_id integer
    */
    'allianceId'?: number;
    /**
    * True if the alliance has been closed
    */
    'isDeleted'?: boolean;
    /**
    * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
    */
    'recordId': number;
    /**
    * start_date string
    */
    'startDate': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "isDeleted",
            "baseName": "is_deleted",
            "type": "boolean"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdAlliancehistory200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdAssets200Ok {
    /**
    * is_blueprint_copy boolean
    */
    'isBlueprintCopy'?: boolean;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * location_flag string
    */
    'locationFlag': GetCorporationsCorporationIdAssets200Ok.LocationFlagEnum;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCorporationsCorporationIdAssets200Ok.LocationTypeEnum;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isBlueprintCopy",
            "baseName": "is_blueprint_copy",
            "type": "boolean"
        },
        {
            "name": "isSingleton",
            "baseName": "is_singleton",
            "type": "boolean"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "locationFlag",
            "baseName": "location_flag",
            "type": "GetCorporationsCorporationIdAssets200Ok.LocationFlagEnum"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "locationType",
            "baseName": "location_type",
            "type": "GetCorporationsCorporationIdAssets200Ok.LocationTypeEnum"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdAssets200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdAssets200Ok {
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
    export enum LocationTypeEnum {
        Station = <any> 'station',
        SolarSystem = <any> 'solar_system',
        Item = <any> 'item',
        Other = <any> 'other'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdBlueprints200Ok {
    /**
    * Unique ID for this item.
    */
    'itemId': number;
    /**
    * Type of the location_id
    */
    'locationFlag': GetCorporationsCorporationIdBlueprints200Ok.LocationFlagEnum;
    /**
    * References a station, a ship or an item_id if this blueprint is located within a container.
    */
    'locationId': number;
    /**
    * Material Efficiency Level of the blueprint.
    */
    'materialEfficiency': number;
    /**
    * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
    */
    'quantity': number;
    /**
    * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
    */
    'runs': number;
    /**
    * Time Efficiency Level of the blueprint.
    */
    'timeEfficiency': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "locationFlag",
            "baseName": "location_flag",
            "type": "GetCorporationsCorporationIdBlueprints200Ok.LocationFlagEnum"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "materialEfficiency",
            "baseName": "material_efficiency",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "runs",
            "baseName": "runs",
            "type": "number"
        },
        {
            "name": "timeEfficiency",
            "baseName": "time_efficiency",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdBlueprints200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdBlueprints200Ok {
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdBookmarks200Ok {
    /**
    * bookmark_id integer
    */
    'bookmarkId': number;
    'coordinates'?: GetCorporationsCorporationIdBookmarksCoordinates;
    /**
    * created string
    */
    'created': Date;
    /**
    * creator_id integer
    */
    'creatorId': number;
    /**
    * folder_id integer
    */
    'folderId'?: number;
    'item'?: GetCorporationsCorporationIdBookmarksItem;
    /**
    * label string
    */
    'label': string;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * notes string
    */
    'notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bookmarkId",
            "baseName": "bookmark_id",
            "type": "number"
        },
        {
            "name": "coordinates",
            "baseName": "coordinates",
            "type": "GetCorporationsCorporationIdBookmarksCoordinates"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "number"
        },
        {
            "name": "folderId",
            "baseName": "folder_id",
            "type": "number"
        },
        {
            "name": "item",
            "baseName": "item",
            "type": "GetCorporationsCorporationIdBookmarksItem"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdBookmarks200Ok.attributeTypeMap;
    }
}

/**
* Optional object that is returned if a bookmark was made on a planet or a random location in space.
*/
export class GetCorporationsCorporationIdBookmarksCoordinates {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdBookmarksCoordinates.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdBookmarksFolders200Ok {
    /**
    * creator_id integer
    */
    'creatorId'?: number;
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "number"
        },
        {
            "name": "folderId",
            "baseName": "folder_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdBookmarksFolders200Ok.attributeTypeMap;
    }
}

/**
* Optional object that is returned if a bookmark was made on a particular item.
*/
export class GetCorporationsCorporationIdBookmarksItem {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdBookmarksItem.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContacts200Ok {
    /**
    * contact_id integer
    */
    'contactId': number;
    /**
    * contact_type string
    */
    'contactType': GetCorporationsCorporationIdContacts200Ok.ContactTypeEnum;
    /**
    * Whether this contact is being watched
    */
    'isWatched'?: boolean;
    /**
    * label_ids array
    */
    'labelIds'?: Array<number>;
    /**
    * Standing of the contact
    */
    'standing': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contactId",
            "baseName": "contact_id",
            "type": "number"
        },
        {
            "name": "contactType",
            "baseName": "contact_type",
            "type": "GetCorporationsCorporationIdContacts200Ok.ContactTypeEnum"
        },
        {
            "name": "isWatched",
            "baseName": "is_watched",
            "type": "boolean"
        },
        {
            "name": "labelIds",
            "baseName": "label_ids",
            "type": "Array<number>"
        },
        {
            "name": "standing",
            "baseName": "standing",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContacts200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdContacts200Ok {
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContactsLabels200Ok {
    /**
    * label_id integer
    */
    'labelId': number;
    /**
    * label_name string
    */
    'labelName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "labelId",
            "baseName": "label_id",
            "type": "number"
        },
        {
            "name": "labelName",
            "baseName": "label_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContactsLabels200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContainersLogs200Ok {
    /**
    * action string
    */
    'action': GetCorporationsCorporationIdContainersLogs200Ok.ActionEnum;
    /**
    * ID of the character who performed the action.
    */
    'characterId': number;
    /**
    * ID of the container
    */
    'containerId': number;
    /**
    * Type ID of the container
    */
    'containerTypeId': number;
    /**
    * location_flag string
    */
    'locationFlag': GetCorporationsCorporationIdContainersLogs200Ok.LocationFlagEnum;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * Timestamp when this log was created
    */
    'loggedAt': Date;
    /**
    * new_config_bitmask integer
    */
    'newConfigBitmask'?: number;
    /**
    * old_config_bitmask integer
    */
    'oldConfigBitmask'?: number;
    /**
    * Type of password set if action is of type SetPassword or EnterPassword
    */
    'passwordType'?: GetCorporationsCorporationIdContainersLogs200Ok.PasswordTypeEnum;
    /**
    * Quantity of the item being acted upon
    */
    'quantity'?: number;
    /**
    * Type ID of the item being acted upon
    */
    'typeId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "GetCorporationsCorporationIdContainersLogs200Ok.ActionEnum"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "containerId",
            "baseName": "container_id",
            "type": "number"
        },
        {
            "name": "containerTypeId",
            "baseName": "container_type_id",
            "type": "number"
        },
        {
            "name": "locationFlag",
            "baseName": "location_flag",
            "type": "GetCorporationsCorporationIdContainersLogs200Ok.LocationFlagEnum"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "loggedAt",
            "baseName": "logged_at",
            "type": "Date"
        },
        {
            "name": "newConfigBitmask",
            "baseName": "new_config_bitmask",
            "type": "number"
        },
        {
            "name": "oldConfigBitmask",
            "baseName": "old_config_bitmask",
            "type": "number"
        },
        {
            "name": "passwordType",
            "baseName": "password_type",
            "type": "GetCorporationsCorporationIdContainersLogs200Ok.PasswordTypeEnum"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContainersLogs200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdContainersLogs200Ok {
    export enum ActionEnum {
        Add = <any> 'add',
        Assemble = <any> 'assemble',
        Configure = <any> 'configure',
        EnterPassword = <any> 'enter_password',
        Lock = <any> 'lock',
        Move = <any> 'move',
        Repackage = <any> 'repackage',
        SetName = <any> 'set_name',
        SetPassword = <any> 'set_password',
        Unlock = <any> 'unlock'
    }
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
    export enum PasswordTypeEnum {
        Config = <any> 'config',
        General = <any> 'general'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContracts200Ok {
    /**
    * Who will accept the contract
    */
    'acceptorId': number;
    /**
    * ID to whom the contract is assigned, can be corporation or character ID
    */
    'assigneeId': number;
    /**
    * To whom the contract is available
    */
    'availability': GetCorporationsCorporationIdContracts200Ok.AvailabilityEnum;
    /**
    * Buyout price (for Auctions only)
    */
    'buyout'?: number;
    /**
    * Collateral price (for Couriers only)
    */
    'collateral'?: number;
    /**
    * contract_id integer
    */
    'contractId': number;
    /**
    * Date of confirmation of contract
    */
    'dateAccepted'?: Date;
    /**
    * Date of completed of contract
    */
    'dateCompleted'?: Date;
    /**
    * Expiration date of the contract
    */
    'dateExpired': Date;
    /**
    * Сreation date of the contract
    */
    'dateIssued': Date;
    /**
    * Number of days to perform the contract
    */
    'daysToComplete'?: number;
    /**
    * End location ID (for Couriers contract)
    */
    'endLocationId'?: number;
    /**
    * true if the contract was issued on behalf of the issuer's corporation
    */
    'forCorporation': boolean;
    /**
    * Character's corporation ID for the issuer
    */
    'issuerCorporationId': number;
    /**
    * Character ID for the issuer
    */
    'issuerId': number;
    /**
    * Price of contract (for ItemsExchange and Auctions)
    */
    'price'?: number;
    /**
    * Remuneration for contract (for Couriers only)
    */
    'reward'?: number;
    /**
    * Start location ID (for Couriers contract)
    */
    'startLocationId'?: number;
    /**
    * Status of the the contract
    */
    'status': GetCorporationsCorporationIdContracts200Ok.StatusEnum;
    /**
    * Title of the contract
    */
    'title'?: string;
    /**
    * Type of the contract
    */
    'type': GetCorporationsCorporationIdContracts200Ok.TypeEnum;
    /**
    * Volume of items in the contract
    */
    'volume'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acceptorId",
            "baseName": "acceptor_id",
            "type": "number"
        },
        {
            "name": "assigneeId",
            "baseName": "assignee_id",
            "type": "number"
        },
        {
            "name": "availability",
            "baseName": "availability",
            "type": "GetCorporationsCorporationIdContracts200Ok.AvailabilityEnum"
        },
        {
            "name": "buyout",
            "baseName": "buyout",
            "type": "number"
        },
        {
            "name": "collateral",
            "baseName": "collateral",
            "type": "number"
        },
        {
            "name": "contractId",
            "baseName": "contract_id",
            "type": "number"
        },
        {
            "name": "dateAccepted",
            "baseName": "date_accepted",
            "type": "Date"
        },
        {
            "name": "dateCompleted",
            "baseName": "date_completed",
            "type": "Date"
        },
        {
            "name": "dateExpired",
            "baseName": "date_expired",
            "type": "Date"
        },
        {
            "name": "dateIssued",
            "baseName": "date_issued",
            "type": "Date"
        },
        {
            "name": "daysToComplete",
            "baseName": "days_to_complete",
            "type": "number"
        },
        {
            "name": "endLocationId",
            "baseName": "end_location_id",
            "type": "number"
        },
        {
            "name": "forCorporation",
            "baseName": "for_corporation",
            "type": "boolean"
        },
        {
            "name": "issuerCorporationId",
            "baseName": "issuer_corporation_id",
            "type": "number"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "reward",
            "baseName": "reward",
            "type": "number"
        },
        {
            "name": "startLocationId",
            "baseName": "start_location_id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCorporationsCorporationIdContracts200Ok.StatusEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetCorporationsCorporationIdContracts200Ok.TypeEnum"
        },
        {
            "name": "volume",
            "baseName": "volume",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContracts200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdContracts200Ok {
    export enum AvailabilityEnum {
        Public = <any> 'public',
        Personal = <any> 'personal',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
    export enum StatusEnum {
        Outstanding = <any> 'outstanding',
        InProgress = <any> 'in_progress',
        FinishedIssuer = <any> 'finished_issuer',
        FinishedContractor = <any> 'finished_contractor',
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Rejected = <any> 'rejected',
        Failed = <any> 'failed',
        Deleted = <any> 'deleted',
        Reversed = <any> 'reversed'
    }
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContractsContractIdBids200Ok {
    /**
    * The amount bid, in ISK
    */
    'amount': number;
    /**
    * Unique ID for the bid
    */
    'bidId': number;
    /**
    * Character ID of the bidder
    */
    'bidderId': number;
    /**
    * Datetime when the bid was placed
    */
    'dateBid': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "bidId",
            "baseName": "bid_id",
            "type": "number"
        },
        {
            "name": "bidderId",
            "baseName": "bidder_id",
            "type": "number"
        },
        {
            "name": "dateBid",
            "baseName": "date_bid",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContractsContractIdBids200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCorporationsCorporationIdContractsContractIdBidsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContractsContractIdBidsNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContractsContractIdItems200Ok {
    /**
    * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
    */
    'isIncluded': boolean;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
    /**
    * Number of items in the stack
    */
    'quantity': number;
    /**
    * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
    */
    'rawQuantity'?: number;
    /**
    * Unique ID for the item
    */
    'recordId': number;
    /**
    * Type ID for item
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isIncluded",
            "baseName": "is_included",
            "type": "boolean"
        },
        {
            "name": "isSingleton",
            "baseName": "is_singleton",
            "type": "boolean"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "rawQuantity",
            "baseName": "raw_quantity",
            "type": "number"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContractsContractIdItems200Ok.attributeTypeMap;
    }
}

/**
* Error 520
*/
export class GetCorporationsCorporationIdContractsContractIdItemsError520 {
    /**
    * Error 520 message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContractsContractIdItemsError520.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCorporationsCorporationIdContractsContractIdItemsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdContractsContractIdItemsNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdCustomsOffices200Ok {
    /**
    * Only present if alliance access is allowed
    */
    'allianceTaxRate'?: number;
    /**
    * standing_level and any standing related tax rate only present when this is true
    */
    'allowAccessWithStandings': boolean;
    /**
    * allow_alliance_access boolean
    */
    'allowAllianceAccess': boolean;
    /**
    * bad_standing_tax_rate number
    */
    'badStandingTaxRate'?: number;
    /**
    * corporation_tax_rate number
    */
    'corporationTaxRate'?: number;
    /**
    * Tax rate for entities with excellent level of standing, only present if this level is allowed, same for all other standing related tax rates
    */
    'excellentStandingTaxRate'?: number;
    /**
    * good_standing_tax_rate number
    */
    'goodStandingTaxRate'?: number;
    /**
    * neutral_standing_tax_rate number
    */
    'neutralStandingTaxRate'?: number;
    /**
    * unique ID of this customs office
    */
    'officeId': number;
    /**
    * reinforce_exit_end integer
    */
    'reinforceExitEnd': number;
    /**
    * Together with reinforce_exit_end, marks a 2-hour period where this customs office could exit reinforcement mode during the day after initial attack
    */
    'reinforceExitStart': number;
    /**
    * Access is allowed only for entities with this level of standing or better
    */
    'standingLevel'?: GetCorporationsCorporationIdCustomsOffices200Ok.StandingLevelEnum;
    /**
    * ID of the solar system this customs office is located in
    */
    'systemId': number;
    /**
    * terrible_standing_tax_rate number
    */
    'terribleStandingTaxRate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceTaxRate",
            "baseName": "alliance_tax_rate",
            "type": "number"
        },
        {
            "name": "allowAccessWithStandings",
            "baseName": "allow_access_with_standings",
            "type": "boolean"
        },
        {
            "name": "allowAllianceAccess",
            "baseName": "allow_alliance_access",
            "type": "boolean"
        },
        {
            "name": "badStandingTaxRate",
            "baseName": "bad_standing_tax_rate",
            "type": "number"
        },
        {
            "name": "corporationTaxRate",
            "baseName": "corporation_tax_rate",
            "type": "number"
        },
        {
            "name": "excellentStandingTaxRate",
            "baseName": "excellent_standing_tax_rate",
            "type": "number"
        },
        {
            "name": "goodStandingTaxRate",
            "baseName": "good_standing_tax_rate",
            "type": "number"
        },
        {
            "name": "neutralStandingTaxRate",
            "baseName": "neutral_standing_tax_rate",
            "type": "number"
        },
        {
            "name": "officeId",
            "baseName": "office_id",
            "type": "number"
        },
        {
            "name": "reinforceExitEnd",
            "baseName": "reinforce_exit_end",
            "type": "number"
        },
        {
            "name": "reinforceExitStart",
            "baseName": "reinforce_exit_start",
            "type": "number"
        },
        {
            "name": "standingLevel",
            "baseName": "standing_level",
            "type": "GetCorporationsCorporationIdCustomsOffices200Ok.StandingLevelEnum"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "terribleStandingTaxRate",
            "baseName": "terrible_standing_tax_rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdCustomsOffices200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdCustomsOffices200Ok {
    export enum StandingLevelEnum {
        Bad = <any> 'bad',
        Excellent = <any> 'excellent',
        Good = <any> 'good',
        Neutral = <any> 'neutral',
        Terrible = <any> 'terrible'
    }
}
/**
* hangar object
*/
export class GetCorporationsCorporationIdDivisionsHangarHangar {
    /**
    * division integer
    */
    'division'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "division",
            "baseName": "division",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdDivisionsHangarHangar.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdDivisionsOk {
    /**
    * hangar array
    */
    'hangar'?: Array<GetCorporationsCorporationIdDivisionsHangarHangar>;
    /**
    * wallet array
    */
    'wallet'?: Array<GetCorporationsCorporationIdDivisionsWalletWallet>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hangar",
            "baseName": "hangar",
            "type": "Array<GetCorporationsCorporationIdDivisionsHangarHangar>"
        },
        {
            "name": "wallet",
            "baseName": "wallet",
            "type": "Array<GetCorporationsCorporationIdDivisionsWalletWallet>"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdDivisionsOk.attributeTypeMap;
    }
}

/**
* wallet object
*/
export class GetCorporationsCorporationIdDivisionsWalletWallet {
    /**
    * division integer
    */
    'division'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "division",
            "baseName": "division",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdDivisionsWalletWallet.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdFacilities200Ok {
    /**
    * facility_id integer
    */
    'facilityId': number;
    /**
    * system_id integer
    */
    'systemId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "facilityId",
            "baseName": "facility_id",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdFacilities200Ok.attributeTypeMap;
    }
}

/**
* Summary of kills done by the given corporation against enemy factions
*/
export class GetCorporationsCorporationIdFwStatsKills {
    /**
    * Last week's total number of kills by members of the given corporation against enemy factions
    */
    'lastWeek': number;
    /**
    * Total number of kills by members of the given corporation against enemy factions since the corporation enlisted
    */
    'total': number;
    /**
    * Yesterday's total number of kills by members of the given corporation against enemy factions
    */
    'yesterday': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdFwStatsKills.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdFwStatsOk {
    /**
    * The enlistment date of the given corporation into faction warfare. Will not be included if corporation is not enlisted in faction warfare
    */
    'enlistedOn'?: Date;
    /**
    * The faction the given corporation is enlisted to fight for. Will not be included if corporation is not enlisted in faction warfare
    */
    'factionId'?: number;
    'kills': GetCorporationsCorporationIdFwStatsKills;
    /**
    * How many pilots the enlisted corporation has. Will not be included if corporation is not enlisted in faction warfare
    */
    'pilots'?: number;
    'victoryPoints': GetCorporationsCorporationIdFwStatsVictoryPoints;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enlistedOn",
            "baseName": "enlisted_on",
            "type": "Date"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "kills",
            "baseName": "kills",
            "type": "GetCorporationsCorporationIdFwStatsKills"
        },
        {
            "name": "pilots",
            "baseName": "pilots",
            "type": "number"
        },
        {
            "name": "victoryPoints",
            "baseName": "victory_points",
            "type": "GetCorporationsCorporationIdFwStatsVictoryPoints"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdFwStatsOk.attributeTypeMap;
    }
}

/**
* Summary of victory points gained by the given corporation for the enlisted faction
*/
export class GetCorporationsCorporationIdFwStatsVictoryPoints {
    /**
    * Last week's victory points gained by members of the given corporation
    */
    'lastWeek': number;
    /**
    * Total victory points gained since the given corporation enlisted
    */
    'total': number;
    /**
    * Yesterday's victory points gained by members of the given corporation
    */
    'yesterday': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdFwStatsVictoryPoints.attributeTypeMap;
    }
}

/**
* No image server for this datasource
*/
export class GetCorporationsCorporationIdIconsNotFound {
    /**
    * error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdIconsNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdIconsOk {
    /**
    * px128x128 string
    */
    'px128x128'?: string;
    /**
    * px256x256 string
    */
    'px256x256'?: string;
    /**
    * px64x64 string
    */
    'px64x64'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "px128x128",
            "baseName": "px128x128",
            "type": "string"
        },
        {
            "name": "px256x256",
            "baseName": "px256x256",
            "type": "string"
        },
        {
            "name": "px64x64",
            "baseName": "px64x64",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdIconsOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdIndustryJobs200Ok {
    /**
    * Job activity ID
    */
    'activityId': number;
    /**
    * blueprint_id integer
    */
    'blueprintId': number;
    /**
    * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
    */
    'blueprintLocationId': number;
    /**
    * blueprint_type_id integer
    */
    'blueprintTypeId': number;
    /**
    * ID of the character which completed this job
    */
    'completedCharacterId'?: number;
    /**
    * Date and time when this job was completed
    */
    'completedDate'?: Date;
    /**
    * The sume of job installation fee and industry facility tax
    */
    'cost'?: number;
    /**
    * Job duration in seconds
    */
    'duration': number;
    /**
    * Date and time when this job finished
    */
    'endDate': Date;
    /**
    * ID of the facility where this job is running
    */
    'facilityId': number;
    /**
    * ID of the character which installed this job
    */
    'installerId': number;
    /**
    * Unique job ID
    */
    'jobId': number;
    /**
    * Number of runs blueprint is licensed for
    */
    'licensedRuns'?: number;
    /**
    * ID of the location for the industry facility
    */
    'locationId': number;
    /**
    * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
    */
    'outputLocationId': number;
    /**
    * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
    */
    'pauseDate'?: Date;
    /**
    * Chance of success for invention
    */
    'probability'?: number;
    /**
    * Type ID of product (manufactured, copied or invented)
    */
    'productTypeId'?: number;
    /**
    * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
    */
    'runs': number;
    /**
    * Date and time when this job started
    */
    'startDate': Date;
    /**
    * status string
    */
    'status': GetCorporationsCorporationIdIndustryJobs200Ok.StatusEnum;
    /**
    * Number of successful runs for this job. Equal to runs unless this is an invention job
    */
    'successfulRuns'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activityId",
            "baseName": "activity_id",
            "type": "number"
        },
        {
            "name": "blueprintId",
            "baseName": "blueprint_id",
            "type": "number"
        },
        {
            "name": "blueprintLocationId",
            "baseName": "blueprint_location_id",
            "type": "number"
        },
        {
            "name": "blueprintTypeId",
            "baseName": "blueprint_type_id",
            "type": "number"
        },
        {
            "name": "completedCharacterId",
            "baseName": "completed_character_id",
            "type": "number"
        },
        {
            "name": "completedDate",
            "baseName": "completed_date",
            "type": "Date"
        },
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "Date"
        },
        {
            "name": "facilityId",
            "baseName": "facility_id",
            "type": "number"
        },
        {
            "name": "installerId",
            "baseName": "installer_id",
            "type": "number"
        },
        {
            "name": "jobId",
            "baseName": "job_id",
            "type": "number"
        },
        {
            "name": "licensedRuns",
            "baseName": "licensed_runs",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "outputLocationId",
            "baseName": "output_location_id",
            "type": "number"
        },
        {
            "name": "pauseDate",
            "baseName": "pause_date",
            "type": "Date"
        },
        {
            "name": "probability",
            "baseName": "probability",
            "type": "number"
        },
        {
            "name": "productTypeId",
            "baseName": "product_type_id",
            "type": "number"
        },
        {
            "name": "runs",
            "baseName": "runs",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCorporationsCorporationIdIndustryJobs200Ok.StatusEnum"
        },
        {
            "name": "successfulRuns",
            "baseName": "successful_runs",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdIndustryJobs200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdIndustryJobs200Ok {
    export enum StatusEnum {
        Active = <any> 'active',
        Cancelled = <any> 'cancelled',
        Delivered = <any> 'delivered',
        Paused = <any> 'paused',
        Ready = <any> 'ready',
        Reverted = <any> 'reverted'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdKillmailsRecent200Ok {
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
    /**
    * ID of this killmail
    */
    'killmailId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "killmailHash",
            "baseName": "killmail_hash",
            "type": "string"
        },
        {
            "name": "killmailId",
            "baseName": "killmail_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdKillmailsRecent200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMedals200Ok {
    /**
    * created_at string
    */
    'createdAt': Date;
    /**
    * ID of the character who created this medal
    */
    'creatorId': number;
    /**
    * description string
    */
    'description': string;
    /**
    * medal_id integer
    */
    'medalId': number;
    /**
    * title string
    */
    'title': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "medalId",
            "baseName": "medal_id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdMedals200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMedalsIssued200Ok {
    /**
    * ID of the character who was rewarded this medal
    */
    'characterId': number;
    /**
    * issued_at string
    */
    'issuedAt': Date;
    /**
    * ID of the character who issued the medal
    */
    'issuerId': number;
    /**
    * medal_id integer
    */
    'medalId': number;
    /**
    * reason string
    */
    'reason': string;
    /**
    * status string
    */
    'status': GetCorporationsCorporationIdMedalsIssued200Ok.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "issuedAt",
            "baseName": "issued_at",
            "type": "Date"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "number"
        },
        {
            "name": "medalId",
            "baseName": "medal_id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCorporationsCorporationIdMedalsIssued200Ok.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdMedalsIssued200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdMedalsIssued200Ok {
    export enum StatusEnum {
        Private = <any> 'private',
        Public = <any> 'public'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMembersTitles200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * A list of title_id
    */
    'titles': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "titles",
            "baseName": "titles",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdMembersTitles200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMembertracking200Ok {
    /**
    * base_id integer
    */
    'baseId'?: number;
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * location_id integer
    */
    'locationId'?: number;
    /**
    * logoff_date string
    */
    'logoffDate'?: Date;
    /**
    * logon_date string
    */
    'logonDate'?: Date;
    /**
    * ship_type_id integer
    */
    'shipTypeId'?: number;
    /**
    * start_date string
    */
    'startDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "baseId",
            "baseName": "base_id",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "logoffDate",
            "baseName": "logoff_date",
            "type": "Date"
        },
        {
            "name": "logonDate",
            "baseName": "logon_date",
            "type": "Date"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdMembertracking200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetCorporationsCorporationIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdOk {
    /**
    * ID of the alliance that corporation is a member of, if any
    */
    'allianceId'?: number;
    /**
    * ceo_id integer
    */
    'ceoId': number;
    /**
    * creator_id integer
    */
    'creatorId': number;
    /**
    * date_founded string
    */
    'dateFounded'?: Date;
    /**
    * description string
    */
    'description'?: string;
    /**
    * faction_id integer
    */
    'factionId'?: number;
    /**
    * home_station_id integer
    */
    'homeStationId'?: number;
    /**
    * member_count integer
    */
    'memberCount': number;
    /**
    * the full name of the corporation
    */
    'name': string;
    /**
    * shares integer
    */
    'shares'?: number;
    /**
    * tax_rate number
    */
    'taxRate': number;
    /**
    * the short name of the corporation
    */
    'ticker': string;
    /**
    * url string
    */
    'url'?: string;
    /**
    * war_eligible boolean
    */
    'warEligible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "ceoId",
            "baseName": "ceo_id",
            "type": "number"
        },
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "number"
        },
        {
            "name": "dateFounded",
            "baseName": "date_founded",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "homeStationId",
            "baseName": "home_station_id",
            "type": "number"
        },
        {
            "name": "memberCount",
            "baseName": "member_count",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shares",
            "baseName": "shares",
            "type": "number"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "warEligible",
            "baseName": "war_eligible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdOrders200Ok {
    /**
    * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
    */
    'duration': number;
    /**
    * For buy orders, the amount of ISK in escrow
    */
    'escrow'?: number;
    /**
    * True if the order is a bid (buy) order
    */
    'isBuyOrder'?: boolean;
    /**
    * Date and time when this order was issued
    */
    'issued': Date;
    /**
    * The character who issued this order
    */
    'issuedBy': number;
    /**
    * ID of the location where order was placed
    */
    'locationId': number;
    /**
    * For buy orders, the minimum quantity that will be accepted in a matching sell order
    */
    'minVolume'?: number;
    /**
    * Unique order ID
    */
    'orderId': number;
    /**
    * Cost per unit for this order
    */
    'price': number;
    /**
    * Valid order range, numbers are ranges in jumps
    */
    'range': GetCorporationsCorporationIdOrders200Ok.RangeEnum;
    /**
    * ID of the region where order was placed
    */
    'regionId': number;
    /**
    * The type ID of the item transacted in this order
    */
    'typeId': number;
    /**
    * Quantity of items still required or offered
    */
    'volumeRemain': number;
    /**
    * Quantity of items required or offered at time order was placed
    */
    'volumeTotal': number;
    /**
    * The corporation wallet division used for this order.
    */
    'walletDivision': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "escrow",
            "baseName": "escrow",
            "type": "number"
        },
        {
            "name": "isBuyOrder",
            "baseName": "is_buy_order",
            "type": "boolean"
        },
        {
            "name": "issued",
            "baseName": "issued",
            "type": "Date"
        },
        {
            "name": "issuedBy",
            "baseName": "issued_by",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "minVolume",
            "baseName": "min_volume",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "range",
            "baseName": "range",
            "type": "GetCorporationsCorporationIdOrders200Ok.RangeEnum"
        },
        {
            "name": "regionId",
            "baseName": "region_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "volumeRemain",
            "baseName": "volume_remain",
            "type": "number"
        },
        {
            "name": "volumeTotal",
            "baseName": "volume_total",
            "type": "number"
        },
        {
            "name": "walletDivision",
            "baseName": "wallet_division",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdOrders200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdOrders200Ok {
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdOrdersHistory200Ok {
    /**
    * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
    */
    'duration': number;
    /**
    * For buy orders, the amount of ISK in escrow
    */
    'escrow'?: number;
    /**
    * True if the order is a bid (buy) order
    */
    'isBuyOrder'?: boolean;
    /**
    * Date and time when this order was issued
    */
    'issued': Date;
    /**
    * The character who issued this order
    */
    'issuedBy'?: number;
    /**
    * ID of the location where order was placed
    */
    'locationId': number;
    /**
    * For buy orders, the minimum quantity that will be accepted in a matching sell order
    */
    'minVolume'?: number;
    /**
    * Unique order ID
    */
    'orderId': number;
    /**
    * Cost per unit for this order
    */
    'price': number;
    /**
    * Valid order range, numbers are ranges in jumps
    */
    'range': GetCorporationsCorporationIdOrdersHistory200Ok.RangeEnum;
    /**
    * ID of the region where order was placed
    */
    'regionId': number;
    /**
    * Current order state
    */
    'state': GetCorporationsCorporationIdOrdersHistory200Ok.StateEnum;
    /**
    * The type ID of the item transacted in this order
    */
    'typeId': number;
    /**
    * Quantity of items still required or offered
    */
    'volumeRemain': number;
    /**
    * Quantity of items required or offered at time order was placed
    */
    'volumeTotal': number;
    /**
    * The corporation wallet division used for this order
    */
    'walletDivision': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "escrow",
            "baseName": "escrow",
            "type": "number"
        },
        {
            "name": "isBuyOrder",
            "baseName": "is_buy_order",
            "type": "boolean"
        },
        {
            "name": "issued",
            "baseName": "issued",
            "type": "Date"
        },
        {
            "name": "issuedBy",
            "baseName": "issued_by",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "minVolume",
            "baseName": "min_volume",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "range",
            "baseName": "range",
            "type": "GetCorporationsCorporationIdOrdersHistory200Ok.RangeEnum"
        },
        {
            "name": "regionId",
            "baseName": "region_id",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "GetCorporationsCorporationIdOrdersHistory200Ok.StateEnum"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "volumeRemain",
            "baseName": "volume_remain",
            "type": "number"
        },
        {
            "name": "volumeTotal",
            "baseName": "volume_total",
            "type": "number"
        },
        {
            "name": "walletDivision",
            "baseName": "wallet_division",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdOrdersHistory200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdOrdersHistory200Ok {
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
    export enum StateEnum {
        Cancelled = <any> 'cancelled',
        Expired = <any> 'expired'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdRoles200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * grantable_roles array
    */
    'grantableRoles'?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesEnum>;
    /**
    * grantable_roles_at_base array
    */
    'grantableRolesAtBase'?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtBaseEnum>;
    /**
    * grantable_roles_at_hq array
    */
    'grantableRolesAtHq'?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtHqEnum>;
    /**
    * grantable_roles_at_other array
    */
    'grantableRolesAtOther'?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtOtherEnum>;
    /**
    * roles array
    */
    'roles'?: Array<GetCorporationsCorporationIdRoles200Ok.RolesEnum>;
    /**
    * roles_at_base array
    */
    'rolesAtBase'?: Array<GetCorporationsCorporationIdRoles200Ok.RolesAtBaseEnum>;
    /**
    * roles_at_hq array
    */
    'rolesAtHq'?: Array<GetCorporationsCorporationIdRoles200Ok.RolesAtHqEnum>;
    /**
    * roles_at_other array
    */
    'rolesAtOther'?: Array<GetCorporationsCorporationIdRoles200Ok.RolesAtOtherEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "grantableRoles",
            "baseName": "grantable_roles",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesEnum>"
        },
        {
            "name": "grantableRolesAtBase",
            "baseName": "grantable_roles_at_base",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtBaseEnum>"
        },
        {
            "name": "grantableRolesAtHq",
            "baseName": "grantable_roles_at_hq",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtHqEnum>"
        },
        {
            "name": "grantableRolesAtOther",
            "baseName": "grantable_roles_at_other",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtOtherEnum>"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.RolesEnum>"
        },
        {
            "name": "rolesAtBase",
            "baseName": "roles_at_base",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.RolesAtBaseEnum>"
        },
        {
            "name": "rolesAtHq",
            "baseName": "roles_at_hq",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.RolesAtHqEnum>"
        },
        {
            "name": "rolesAtOther",
            "baseName": "roles_at_other",
            "type": "Array<GetCorporationsCorporationIdRoles200Ok.RolesAtOtherEnum>"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdRoles200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdRoles200Ok {
    export enum GrantableRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdRolesHistory200Ok {
    /**
    * changed_at string
    */
    'changedAt': Date;
    /**
    * The character whose roles are changed
    */
    'characterId': number;
    /**
    * ID of the character who issued this change
    */
    'issuerId': number;
    /**
    * new_roles array
    */
    'newRoles': Array<GetCorporationsCorporationIdRolesHistory200Ok.NewRolesEnum>;
    /**
    * old_roles array
    */
    'oldRoles': Array<GetCorporationsCorporationIdRolesHistory200Ok.OldRolesEnum>;
    /**
    * role_type string
    */
    'roleType': GetCorporationsCorporationIdRolesHistory200Ok.RoleTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "changedAt",
            "baseName": "changed_at",
            "type": "Date"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "number"
        },
        {
            "name": "newRoles",
            "baseName": "new_roles",
            "type": "Array<GetCorporationsCorporationIdRolesHistory200Ok.NewRolesEnum>"
        },
        {
            "name": "oldRoles",
            "baseName": "old_roles",
            "type": "Array<GetCorporationsCorporationIdRolesHistory200Ok.OldRolesEnum>"
        },
        {
            "name": "roleType",
            "baseName": "role_type",
            "type": "GetCorporationsCorporationIdRolesHistory200Ok.RoleTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdRolesHistory200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdRolesHistory200Ok {
    export enum NewRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum OldRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RoleTypeEnum {
        GrantableRoles = <any> 'grantable_roles',
        GrantableRolesAtBase = <any> 'grantable_roles_at_base',
        GrantableRolesAtHq = <any> 'grantable_roles_at_hq',
        GrantableRolesAtOther = <any> 'grantable_roles_at_other',
        Roles = <any> 'roles',
        RolesAtBase = <any> 'roles_at_base',
        RolesAtHq = <any> 'roles_at_hq',
        RolesAtOther = <any> 'roles_at_other'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdShareholders200Ok {
    /**
    * share_count integer
    */
    'shareCount': number;
    /**
    * shareholder_id integer
    */
    'shareholderId': number;
    /**
    * shareholder_type string
    */
    'shareholderType': GetCorporationsCorporationIdShareholders200Ok.ShareholderTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shareCount",
            "baseName": "share_count",
            "type": "number"
        },
        {
            "name": "shareholderId",
            "baseName": "shareholder_id",
            "type": "number"
        },
        {
            "name": "shareholderType",
            "baseName": "shareholder_type",
            "type": "GetCorporationsCorporationIdShareholders200Ok.ShareholderTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdShareholders200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdShareholders200Ok {
    export enum ShareholderTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStandings200Ok {
    /**
    * from_id integer
    */
    'fromId': number;
    /**
    * from_type string
    */
    'fromType': GetCorporationsCorporationIdStandings200Ok.FromTypeEnum;
    /**
    * standing number
    */
    'standing': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fromId",
            "baseName": "from_id",
            "type": "number"
        },
        {
            "name": "fromType",
            "baseName": "from_type",
            "type": "GetCorporationsCorporationIdStandings200Ok.FromTypeEnum"
        },
        {
            "name": "standing",
            "baseName": "standing",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdStandings200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdStandings200Ok {
    export enum FromTypeEnum {
        Agent = <any> 'agent',
        NpcCorp = <any> 'npc_corp',
        Faction = <any> 'faction'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStarbases200Ok {
    /**
    * The moon this starbase (POS) is anchored on, unanchored POSes do not have this information
    */
    'moonId'?: number;
    /**
    * When the POS onlined, for starbases (POSes) in online state
    */
    'onlinedSince'?: Date;
    /**
    * When the POS will be out of reinforcement, for starbases (POSes) in reinforced state
    */
    'reinforcedUntil'?: Date;
    /**
    * Unique ID for this starbase (POS)
    */
    'starbaseId': number;
    /**
    * state string
    */
    'state'?: GetCorporationsCorporationIdStarbases200Ok.StateEnum;
    /**
    * The solar system this starbase (POS) is in, unanchored POSes have this information
    */
    'systemId': number;
    /**
    * Starbase (POS) type
    */
    'typeId': number;
    /**
    * When the POS started unanchoring, for starbases (POSes) in unanchoring state
    */
    'unanchorAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "moonId",
            "baseName": "moon_id",
            "type": "number"
        },
        {
            "name": "onlinedSince",
            "baseName": "onlined_since",
            "type": "Date"
        },
        {
            "name": "reinforcedUntil",
            "baseName": "reinforced_until",
            "type": "Date"
        },
        {
            "name": "starbaseId",
            "baseName": "starbase_id",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "GetCorporationsCorporationIdStarbases200Ok.StateEnum"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "unanchorAt",
            "baseName": "unanchor_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdStarbases200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdStarbases200Ok {
    export enum StateEnum {
        Offline = <any> 'offline',
        Online = <any> 'online',
        Onlining = <any> 'onlining',
        Reinforced = <any> 'reinforced',
        Unanchoring = <any> 'unanchoring'
    }
}
/**
* fuel object
*/
export class GetCorporationsCorporationIdStarbasesStarbaseIdFuel {
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdStarbasesStarbaseIdFuel.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStarbasesStarbaseIdOk {
    /**
    * allow_alliance_members boolean
    */
    'allowAllianceMembers': boolean;
    /**
    * allow_corporation_members boolean
    */
    'allowCorporationMembers': boolean;
    /**
    * Who can anchor starbase (POS) and its structures
    */
    'anchor': GetCorporationsCorporationIdStarbasesStarbaseIdOk.AnchorEnum;
    /**
    * attack_if_at_war boolean
    */
    'attackIfAtWar': boolean;
    /**
    * attack_if_other_security_status_dropping boolean
    */
    'attackIfOtherSecurityStatusDropping': boolean;
    /**
    * Starbase (POS) will attack if target's security standing is lower than this value
    */
    'attackSecurityStatusThreshold'?: number;
    /**
    * Starbase (POS) will attack if target's standing is lower than this value
    */
    'attackStandingThreshold'?: number;
    /**
    * Who can take fuel blocks out of the starbase (POS)'s fuel bay
    */
    'fuelBayTake': GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayTakeEnum;
    /**
    * Who can view the starbase (POS)'s fule bay. Characters either need to have required role or belong to the starbase (POS) owner's corporation or alliance, as described by the enum, all other access settings follows the same scheme
    */
    'fuelBayView': GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayViewEnum;
    /**
    * Fuel blocks and other things that will be consumed when operating a starbase (POS)
    */
    'fuels'?: Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>;
    /**
    * Who can offline starbase (POS) and its structures
    */
    'offline': GetCorporationsCorporationIdStarbasesStarbaseIdOk.OfflineEnum;
    /**
    * Who can online starbase (POS) and its structures
    */
    'online': GetCorporationsCorporationIdStarbasesStarbaseIdOk.OnlineEnum;
    /**
    * Who can unanchor starbase (POS) and its structures
    */
    'unanchor': GetCorporationsCorporationIdStarbasesStarbaseIdOk.UnanchorEnum;
    /**
    * True if the starbase (POS) is using alliance standings, otherwise using corporation's
    */
    'useAllianceStandings': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowAllianceMembers",
            "baseName": "allow_alliance_members",
            "type": "boolean"
        },
        {
            "name": "allowCorporationMembers",
            "baseName": "allow_corporation_members",
            "type": "boolean"
        },
        {
            "name": "anchor",
            "baseName": "anchor",
            "type": "GetCorporationsCorporationIdStarbasesStarbaseIdOk.AnchorEnum"
        },
        {
            "name": "attackIfAtWar",
            "baseName": "attack_if_at_war",
            "type": "boolean"
        },
        {
            "name": "attackIfOtherSecurityStatusDropping",
            "baseName": "attack_if_other_security_status_dropping",
            "type": "boolean"
        },
        {
            "name": "attackSecurityStatusThreshold",
            "baseName": "attack_security_status_threshold",
            "type": "number"
        },
        {
            "name": "attackStandingThreshold",
            "baseName": "attack_standing_threshold",
            "type": "number"
        },
        {
            "name": "fuelBayTake",
            "baseName": "fuel_bay_take",
            "type": "GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayTakeEnum"
        },
        {
            "name": "fuelBayView",
            "baseName": "fuel_bay_view",
            "type": "GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayViewEnum"
        },
        {
            "name": "fuels",
            "baseName": "fuels",
            "type": "Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>"
        },
        {
            "name": "offline",
            "baseName": "offline",
            "type": "GetCorporationsCorporationIdStarbasesStarbaseIdOk.OfflineEnum"
        },
        {
            "name": "online",
            "baseName": "online",
            "type": "GetCorporationsCorporationIdStarbasesStarbaseIdOk.OnlineEnum"
        },
        {
            "name": "unanchor",
            "baseName": "unanchor",
            "type": "GetCorporationsCorporationIdStarbasesStarbaseIdOk.UnanchorEnum"
        },
        {
            "name": "useAllianceStandings",
            "baseName": "use_alliance_standings",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdStarbasesStarbaseIdOk.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdStarbasesStarbaseIdOk {
    export enum AnchorEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum FuelBayTakeEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum FuelBayViewEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum OfflineEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum OnlineEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum UnanchorEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStructures200Ok {
    /**
    * ID of the corporation that owns the structure
    */
    'corporationId': number;
    /**
    * Date on which the structure will run out of fuel
    */
    'fuelExpires'?: Date;
    /**
    * The date and time when the structure's newly requested reinforcement times (e.g. next_reinforce_hour and next_reinforce_day) will take effect
    */
    'nextReinforceApply'?: Date;
    /**
    * The requested change to reinforce_hour that will take effect at the time shown by next_reinforce_apply
    */
    'nextReinforceHour'?: number;
    /**
    * The requested change to reinforce_weekday that will take effect at the time shown by next_reinforce_apply
    */
    'nextReinforceWeekday'?: number;
    /**
    * The id of the ACL profile for this citadel
    */
    'profileId': number;
    /**
    * The hour of day that determines the four hour window when the structure will randomly exit its reinforcement periods and become vulnerable to attack against its armor and/or hull. The structure will become vulnerable at a random time that is +/- 2 hours centered on the value of this property
    */
    'reinforceHour': number;
    /**
    * The day of the week when the structure exits its final reinforcement period and becomes vulnerable to attack against its hull. Monday is 0 and Sunday is 6
    */
    'reinforceWeekday'?: number;
    /**
    * Contains a list of service upgrades, and their state
    */
    'services'?: Array<GetCorporationsCorporationIdStructuresService>;
    /**
    * state string
    */
    'state': GetCorporationsCorporationIdStructures200Ok.StateEnum;
    /**
    * Date at which the structure will move to it's next state
    */
    'stateTimerEnd'?: Date;
    /**
    * Date at which the structure entered it's current state
    */
    'stateTimerStart'?: Date;
    /**
    * The Item ID of the structure
    */
    'structureId': number;
    /**
    * The solar system the structure is in
    */
    'systemId': number;
    /**
    * The type id of the structure
    */
    'typeId': number;
    /**
    * Date at which the structure will unanchor
    */
    'unanchorsAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "fuelExpires",
            "baseName": "fuel_expires",
            "type": "Date"
        },
        {
            "name": "nextReinforceApply",
            "baseName": "next_reinforce_apply",
            "type": "Date"
        },
        {
            "name": "nextReinforceHour",
            "baseName": "next_reinforce_hour",
            "type": "number"
        },
        {
            "name": "nextReinforceWeekday",
            "baseName": "next_reinforce_weekday",
            "type": "number"
        },
        {
            "name": "profileId",
            "baseName": "profile_id",
            "type": "number"
        },
        {
            "name": "reinforceHour",
            "baseName": "reinforce_hour",
            "type": "number"
        },
        {
            "name": "reinforceWeekday",
            "baseName": "reinforce_weekday",
            "type": "number"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<GetCorporationsCorporationIdStructuresService>"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "GetCorporationsCorporationIdStructures200Ok.StateEnum"
        },
        {
            "name": "stateTimerEnd",
            "baseName": "state_timer_end",
            "type": "Date"
        },
        {
            "name": "stateTimerStart",
            "baseName": "state_timer_start",
            "type": "Date"
        },
        {
            "name": "structureId",
            "baseName": "structure_id",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "unanchorsAt",
            "baseName": "unanchors_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdStructures200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdStructures200Ok {
    export enum StateEnum {
        AnchorVulnerable = <any> 'anchor_vulnerable',
        Anchoring = <any> 'anchoring',
        ArmorReinforce = <any> 'armor_reinforce',
        ArmorVulnerable = <any> 'armor_vulnerable',
        DeployVulnerable = <any> 'deploy_vulnerable',
        FittingInvulnerable = <any> 'fitting_invulnerable',
        HullReinforce = <any> 'hull_reinforce',
        HullVulnerable = <any> 'hull_vulnerable',
        OnlineDeprecated = <any> 'online_deprecated',
        OnliningVulnerable = <any> 'onlining_vulnerable',
        ShieldVulnerable = <any> 'shield_vulnerable',
        Unanchored = <any> 'unanchored',
        Unknown = <any> 'unknown'
    }
}
/**
* service object
*/
export class GetCorporationsCorporationIdStructuresService {
    /**
    * name string
    */
    'name': string;
    /**
    * state string
    */
    'state': GetCorporationsCorporationIdStructuresService.StateEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "GetCorporationsCorporationIdStructuresService.StateEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdStructuresService.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdStructuresService {
    export enum StateEnum {
        Online = <any> 'online',
        Offline = <any> 'offline',
        Cleanup = <any> 'cleanup'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdTitles200Ok {
    /**
    * grantable_roles array
    */
    'grantableRoles'?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesEnum>;
    /**
    * grantable_roles_at_base array
    */
    'grantableRolesAtBase'?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtBaseEnum>;
    /**
    * grantable_roles_at_hq array
    */
    'grantableRolesAtHq'?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtHqEnum>;
    /**
    * grantable_roles_at_other array
    */
    'grantableRolesAtOther'?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtOtherEnum>;
    /**
    * name string
    */
    'name'?: string;
    /**
    * roles array
    */
    'roles'?: Array<GetCorporationsCorporationIdTitles200Ok.RolesEnum>;
    /**
    * roles_at_base array
    */
    'rolesAtBase'?: Array<GetCorporationsCorporationIdTitles200Ok.RolesAtBaseEnum>;
    /**
    * roles_at_hq array
    */
    'rolesAtHq'?: Array<GetCorporationsCorporationIdTitles200Ok.RolesAtHqEnum>;
    /**
    * roles_at_other array
    */
    'rolesAtOther'?: Array<GetCorporationsCorporationIdTitles200Ok.RolesAtOtherEnum>;
    /**
    * title_id integer
    */
    'titleId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "grantableRoles",
            "baseName": "grantable_roles",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesEnum>"
        },
        {
            "name": "grantableRolesAtBase",
            "baseName": "grantable_roles_at_base",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtBaseEnum>"
        },
        {
            "name": "grantableRolesAtHq",
            "baseName": "grantable_roles_at_hq",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtHqEnum>"
        },
        {
            "name": "grantableRolesAtOther",
            "baseName": "grantable_roles_at_other",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtOtherEnum>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.RolesEnum>"
        },
        {
            "name": "rolesAtBase",
            "baseName": "roles_at_base",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.RolesAtBaseEnum>"
        },
        {
            "name": "rolesAtHq",
            "baseName": "roles_at_hq",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.RolesAtHqEnum>"
        },
        {
            "name": "rolesAtOther",
            "baseName": "roles_at_other",
            "type": "Array<GetCorporationsCorporationIdTitles200Ok.RolesAtOtherEnum>"
        },
        {
            "name": "titleId",
            "baseName": "title_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdTitles200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdTitles200Ok {
    export enum GrantableRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdWallets200Ok {
    /**
    * balance number
    */
    'balance': number;
    /**
    * division integer
    */
    'division': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "division",
            "baseName": "division",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdWallets200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
    /**
    * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
    */
    'amount'?: number;
    /**
    * Wallet balance after transaction occurred
    */
    'balance'?: number;
    /**
    * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
    */
    'contextId'?: number;
    /**
    * The type of the given context_id if present
    */
    'contextIdType'?: GetCorporationsCorporationIdWalletsDivisionJournal200Ok.ContextIdTypeEnum;
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * The reason for the transaction, mirrors what is seen in the client
    */
    'description': string;
    /**
    * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
    */
    'firstPartyId'?: number;
    /**
    * Unique journal reference ID
    */
    'id': number;
    /**
    * The user stated reason for the transaction. Only applies to some ref_types
    */
    'reason'?: string;
    /**
    * \"The transaction type for the given. transaction. Different transaction types will populate different attributes. Note: If you have an existing XML API application that is using ref_types, you will need to know which string ESI ref_type maps to which integer. You can look at the following file to see string->int mappings: https://github.com/ccpgames/eve-glue/blob/master/eve_glue/wallet_journal_ref.py\"
    */
    'refType': GetCorporationsCorporationIdWalletsDivisionJournal200Ok.RefTypeEnum;
    /**
    * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
    */
    'secondPartyId'?: number;
    /**
    * Tax amount received. Only applies to tax related transactions
    */
    'tax'?: number;
    /**
    * The corporation ID receiving any tax paid. Only applies to tax related transactions
    */
    'taxReceiverId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "number"
        },
        {
            "name": "contextIdType",
            "baseName": "context_id_type",
            "type": "GetCorporationsCorporationIdWalletsDivisionJournal200Ok.ContextIdTypeEnum"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "firstPartyId",
            "baseName": "first_party_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "refType",
            "baseName": "ref_type",
            "type": "GetCorporationsCorporationIdWalletsDivisionJournal200Ok.RefTypeEnum"
        },
        {
            "name": "secondPartyId",
            "baseName": "second_party_id",
            "type": "number"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "number"
        },
        {
            "name": "taxReceiverId",
            "baseName": "tax_receiver_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdWalletsDivisionJournal200Ok.attributeTypeMap;
    }
}

export namespace GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
    export enum ContextIdTypeEnum {
        StructureId = <any> 'structure_id',
        StationId = <any> 'station_id',
        MarketTransactionId = <any> 'market_transaction_id',
        CharacterId = <any> 'character_id',
        CorporationId = <any> 'corporation_id',
        AllianceId = <any> 'alliance_id',
        EveSystem = <any> 'eve_system',
        IndustryJobId = <any> 'industry_job_id',
        ContractId = <any> 'contract_id',
        PlanetId = <any> 'planet_id',
        SystemId = <any> 'system_id',
        TypeId = <any> 'type_id'
    }
    export enum RefTypeEnum {
        AccelerationGateFee = <any> 'acceleration_gate_fee',
        AdvertisementListingFee = <any> 'advertisement_listing_fee',
        AgentDonation = <any> 'agent_donation',
        AgentLocationServices = <any> 'agent_location_services',
        AgentMiscellaneous = <any> 'agent_miscellaneous',
        AgentMissionCollateralPaid = <any> 'agent_mission_collateral_paid',
        AgentMissionCollateralRefunded = <any> 'agent_mission_collateral_refunded',
        AgentMissionReward = <any> 'agent_mission_reward',
        AgentMissionRewardCorporationTax = <any> 'agent_mission_reward_corporation_tax',
        AgentMissionTimeBonusReward = <any> 'agent_mission_time_bonus_reward',
        AgentMissionTimeBonusRewardCorporationTax = <any> 'agent_mission_time_bonus_reward_corporation_tax',
        AgentSecurityServices = <any> 'agent_security_services',
        AgentServicesRendered = <any> 'agent_services_rendered',
        AgentsPreward = <any> 'agents_preward',
        AllianceMaintainanceFee = <any> 'alliance_maintainance_fee',
        AllianceRegistrationFee = <any> 'alliance_registration_fee',
        AssetSafetyRecoveryTax = <any> 'asset_safety_recovery_tax',
        Bounty = <any> 'bounty',
        BountyPrize = <any> 'bounty_prize',
        BountyPrizeCorporationTax = <any> 'bounty_prize_corporation_tax',
        BountyPrizes = <any> 'bounty_prizes',
        BountyReimbursement = <any> 'bounty_reimbursement',
        BountySurcharge = <any> 'bounty_surcharge',
        BrokersFee = <any> 'brokers_fee',
        CloneActivation = <any> 'clone_activation',
        CloneTransfer = <any> 'clone_transfer',
        ContrabandFine = <any> 'contraband_fine',
        ContractAuctionBid = <any> 'contract_auction_bid',
        ContractAuctionBidCorp = <any> 'contract_auction_bid_corp',
        ContractAuctionBidRefund = <any> 'contract_auction_bid_refund',
        ContractAuctionSold = <any> 'contract_auction_sold',
        ContractBrokersFee = <any> 'contract_brokers_fee',
        ContractBrokersFeeCorp = <any> 'contract_brokers_fee_corp',
        ContractCollateral = <any> 'contract_collateral',
        ContractCollateralDepositedCorp = <any> 'contract_collateral_deposited_corp',
        ContractCollateralPayout = <any> 'contract_collateral_payout',
        ContractCollateralRefund = <any> 'contract_collateral_refund',
        ContractDeposit = <any> 'contract_deposit',
        ContractDepositCorp = <any> 'contract_deposit_corp',
        ContractDepositRefund = <any> 'contract_deposit_refund',
        ContractDepositSalesTax = <any> 'contract_deposit_sales_tax',
        ContractPrice = <any> 'contract_price',
        ContractPricePaymentCorp = <any> 'contract_price_payment_corp',
        ContractReversal = <any> 'contract_reversal',
        ContractReward = <any> 'contract_reward',
        ContractRewardDeposited = <any> 'contract_reward_deposited',
        ContractRewardDepositedCorp = <any> 'contract_reward_deposited_corp',
        ContractRewardRefund = <any> 'contract_reward_refund',
        ContractSalesTax = <any> 'contract_sales_tax',
        Copying = <any> 'copying',
        CorporateRewardPayout = <any> 'corporate_reward_payout',
        CorporateRewardTax = <any> 'corporate_reward_tax',
        CorporationAccountWithdrawal = <any> 'corporation_account_withdrawal',
        CorporationBulkPayment = <any> 'corporation_bulk_payment',
        CorporationDividendPayment = <any> 'corporation_dividend_payment',
        CorporationLiquidation = <any> 'corporation_liquidation',
        CorporationLogoChangeCost = <any> 'corporation_logo_change_cost',
        CorporationPayment = <any> 'corporation_payment',
        CorporationRegistrationFee = <any> 'corporation_registration_fee',
        CourierMissionEscrow = <any> 'courier_mission_escrow',
        Cspa = <any> 'cspa',
        Cspaofflinerefund = <any> 'cspaofflinerefund',
        DatacoreFee = <any> 'datacore_fee',
        DnaModificationFee = <any> 'dna_modification_fee',
        DockingFee = <any> 'docking_fee',
        DuelWagerEscrow = <any> 'duel_wager_escrow',
        DuelWagerPayment = <any> 'duel_wager_payment',
        DuelWagerRefund = <any> 'duel_wager_refund',
        FactorySlotRentalFee = <any> 'factory_slot_rental_fee',
        GmCashTransfer = <any> 'gm_cash_transfer',
        IndustryJobTax = <any> 'industry_job_tax',
        InfrastructureHubMaintenance = <any> 'infrastructure_hub_maintenance',
        Inheritance = <any> 'inheritance',
        Insurance = <any> 'insurance',
        JumpCloneActivationFee = <any> 'jump_clone_activation_fee',
        JumpCloneInstallationFee = <any> 'jump_clone_installation_fee',
        KillRightFee = <any> 'kill_right_fee',
        LpStore = <any> 'lp_store',
        Manufacturing = <any> 'manufacturing',
        MarketEscrow = <any> 'market_escrow',
        MarketFinePaid = <any> 'market_fine_paid',
        MarketTransaction = <any> 'market_transaction',
        MedalCreation = <any> 'medal_creation',
        MedalIssued = <any> 'medal_issued',
        MissionCompletion = <any> 'mission_completion',
        MissionCost = <any> 'mission_cost',
        MissionExpiration = <any> 'mission_expiration',
        MissionReward = <any> 'mission_reward',
        OfficeRentalFee = <any> 'office_rental_fee',
        OperationBonus = <any> 'operation_bonus',
        OpportunityReward = <any> 'opportunity_reward',
        PlanetaryConstruction = <any> 'planetary_construction',
        PlanetaryExportTax = <any> 'planetary_export_tax',
        PlanetaryImportTax = <any> 'planetary_import_tax',
        PlayerDonation = <any> 'player_donation',
        PlayerTrading = <any> 'player_trading',
        ProjectDiscoveryReward = <any> 'project_discovery_reward',
        ProjectDiscoveryTax = <any> 'project_discovery_tax',
        Reaction = <any> 'reaction',
        ReleaseOfImpoundedProperty = <any> 'release_of_impounded_property',
        RepairBill = <any> 'repair_bill',
        ReprocessingTax = <any> 'reprocessing_tax',
        ResearchingMaterialProductivity = <any> 'researching_material_productivity',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeProductivity = <any> 'researching_time_productivity',
        ResourceWarsReward = <any> 'resource_wars_reward',
        ReverseEngineering = <any> 'reverse_engineering',
        SecurityProcessingFee = <any> 'security_processing_fee',
        Shares = <any> 'shares',
        SovereignityBill = <any> 'sovereignity_bill',
        StorePurchase = <any> 'store_purchase',
        StorePurchaseRefund = <any> 'store_purchase_refund',
        StructureGateJump = <any> 'structure_gate_jump',
        TransactionTax = <any> 'transaction_tax',
        UpkeepAdjustmentFee = <any> 'upkeep_adjustment_fee',
        WarAllyContract = <any> 'war_ally_contract',
        WarFee = <any> 'war_fee',
        WarFeeSurrender = <any> 'war_fee_surrender'
    }
}
/**
* wallet transaction
*/
export class GetCorporationsCorporationIdWalletsDivisionTransactions200Ok {
    /**
    * client_id integer
    */
    'clientId': number;
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * is_buy boolean
    */
    'isBuy': boolean;
    /**
    * -1 if there is no corresponding wallet journal entry
    */
    'journalRefId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * Unique transaction ID
    */
    'transactionId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * Amount paid per unit
    */
    'unitPrice': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "isBuy",
            "baseName": "is_buy",
            "type": "boolean"
        },
        {
            "name": "journalRefId",
            "baseName": "journal_ref_id",
            "type": "number"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unit_price",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCorporationsCorporationIdWalletsDivisionTransactions200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetDogmaAttributesAttributeIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaAttributesAttributeIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetDogmaAttributesAttributeIdOk {
    /**
    * attribute_id integer
    */
    'attributeId': number;
    /**
    * default_value number
    */
    'defaultValue'?: number;
    /**
    * description string
    */
    'description'?: string;
    /**
    * display_name string
    */
    'displayName'?: string;
    /**
    * high_is_good boolean
    */
    'highIsGood'?: boolean;
    /**
    * icon_id integer
    */
    'iconId'?: number;
    /**
    * name string
    */
    'name'?: string;
    /**
    * published boolean
    */
    'published'?: boolean;
    /**
    * stackable boolean
    */
    'stackable'?: boolean;
    /**
    * unit_id integer
    */
    'unitId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributeId",
            "baseName": "attribute_id",
            "type": "number"
        },
        {
            "name": "defaultValue",
            "baseName": "default_value",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "highIsGood",
            "baseName": "high_is_good",
            "type": "boolean"
        },
        {
            "name": "iconId",
            "baseName": "icon_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "stackable",
            "baseName": "stackable",
            "type": "boolean"
        },
        {
            "name": "unitId",
            "baseName": "unit_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaAttributesAttributeIdOk.attributeTypeMap;
    }
}

/**
* dogma_attribute object
*/
export class GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute {
    /**
    * attribute_id integer
    */
    'attributeId': number;
    /**
    * value number
    */
    'value': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributeId",
            "baseName": "attribute_id",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute.attributeTypeMap;
    }
}

/**
* dogma_effect object
*/
export class GetDogmaDynamicItemsTypeIdItemIdDogmaEffect {
    /**
    * effect_id integer
    */
    'effectId': number;
    /**
    * is_default boolean
    */
    'isDefault': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "effectId",
            "baseName": "effect_id",
            "type": "number"
        },
        {
            "name": "isDefault",
            "baseName": "is_default",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaDynamicItemsTypeIdItemIdDogmaEffect.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetDogmaDynamicItemsTypeIdItemIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaDynamicItemsTypeIdItemIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetDogmaDynamicItemsTypeIdItemIdOk {
    /**
    * The ID of the character who created the item
    */
    'createdBy': number;
    /**
    * dogma_attributes array
    */
    'dogmaAttributes': Array<GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute>;
    /**
    * dogma_effects array
    */
    'dogmaEffects': Array<GetDogmaDynamicItemsTypeIdItemIdDogmaEffect>;
    /**
    * The type ID of the mutator used to generate the dynamic item.
    */
    'mutatorTypeId': number;
    /**
    * The type ID of the source item the mutator was applied to create the dynamic item.
    */
    'sourceTypeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdBy",
            "baseName": "created_by",
            "type": "number"
        },
        {
            "name": "dogmaAttributes",
            "baseName": "dogma_attributes",
            "type": "Array<GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute>"
        },
        {
            "name": "dogmaEffects",
            "baseName": "dogma_effects",
            "type": "Array<GetDogmaDynamicItemsTypeIdItemIdDogmaEffect>"
        },
        {
            "name": "mutatorTypeId",
            "baseName": "mutator_type_id",
            "type": "number"
        },
        {
            "name": "sourceTypeId",
            "baseName": "source_type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaDynamicItemsTypeIdItemIdOk.attributeTypeMap;
    }
}

/**
* modifier object
*/
export class GetDogmaEffectsEffectIdModifier {
    /**
    * domain string
    */
    'domain'?: string;
    /**
    * effect_id integer
    */
    'effectId'?: number;
    /**
    * func string
    */
    'func': string;
    /**
    * modified_attribute_id integer
    */
    'modifiedAttributeId'?: number;
    /**
    * modifying_attribute_id integer
    */
    'modifyingAttributeId'?: number;
    /**
    * operator integer
    */
    'operator'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "effectId",
            "baseName": "effect_id",
            "type": "number"
        },
        {
            "name": "func",
            "baseName": "func",
            "type": "string"
        },
        {
            "name": "modifiedAttributeId",
            "baseName": "modified_attribute_id",
            "type": "number"
        },
        {
            "name": "modifyingAttributeId",
            "baseName": "modifying_attribute_id",
            "type": "number"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaEffectsEffectIdModifier.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetDogmaEffectsEffectIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaEffectsEffectIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetDogmaEffectsEffectIdOk {
    /**
    * description string
    */
    'description'?: string;
    /**
    * disallow_auto_repeat boolean
    */
    'disallowAutoRepeat'?: boolean;
    /**
    * discharge_attribute_id integer
    */
    'dischargeAttributeId'?: number;
    /**
    * display_name string
    */
    'displayName'?: string;
    /**
    * duration_attribute_id integer
    */
    'durationAttributeId'?: number;
    /**
    * effect_category integer
    */
    'effectCategory'?: number;
    /**
    * effect_id integer
    */
    'effectId': number;
    /**
    * electronic_chance boolean
    */
    'electronicChance'?: boolean;
    /**
    * falloff_attribute_id integer
    */
    'falloffAttributeId'?: number;
    /**
    * icon_id integer
    */
    'iconId'?: number;
    /**
    * is_assistance boolean
    */
    'isAssistance'?: boolean;
    /**
    * is_offensive boolean
    */
    'isOffensive'?: boolean;
    /**
    * is_warp_safe boolean
    */
    'isWarpSafe'?: boolean;
    /**
    * modifiers array
    */
    'modifiers'?: Array<GetDogmaEffectsEffectIdModifier>;
    /**
    * name string
    */
    'name'?: string;
    /**
    * post_expression integer
    */
    'postExpression'?: number;
    /**
    * pre_expression integer
    */
    'preExpression'?: number;
    /**
    * published boolean
    */
    'published'?: boolean;
    /**
    * range_attribute_id integer
    */
    'rangeAttributeId'?: number;
    /**
    * range_chance boolean
    */
    'rangeChance'?: boolean;
    /**
    * tracking_speed_attribute_id integer
    */
    'trackingSpeedAttributeId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "disallowAutoRepeat",
            "baseName": "disallow_auto_repeat",
            "type": "boolean"
        },
        {
            "name": "dischargeAttributeId",
            "baseName": "discharge_attribute_id",
            "type": "number"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "durationAttributeId",
            "baseName": "duration_attribute_id",
            "type": "number"
        },
        {
            "name": "effectCategory",
            "baseName": "effect_category",
            "type": "number"
        },
        {
            "name": "effectId",
            "baseName": "effect_id",
            "type": "number"
        },
        {
            "name": "electronicChance",
            "baseName": "electronic_chance",
            "type": "boolean"
        },
        {
            "name": "falloffAttributeId",
            "baseName": "falloff_attribute_id",
            "type": "number"
        },
        {
            "name": "iconId",
            "baseName": "icon_id",
            "type": "number"
        },
        {
            "name": "isAssistance",
            "baseName": "is_assistance",
            "type": "boolean"
        },
        {
            "name": "isOffensive",
            "baseName": "is_offensive",
            "type": "boolean"
        },
        {
            "name": "isWarpSafe",
            "baseName": "is_warp_safe",
            "type": "boolean"
        },
        {
            "name": "modifiers",
            "baseName": "modifiers",
            "type": "Array<GetDogmaEffectsEffectIdModifier>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "postExpression",
            "baseName": "post_expression",
            "type": "number"
        },
        {
            "name": "preExpression",
            "baseName": "pre_expression",
            "type": "number"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "rangeAttributeId",
            "baseName": "range_attribute_id",
            "type": "number"
        },
        {
            "name": "rangeChance",
            "baseName": "range_chance",
            "type": "boolean"
        },
        {
            "name": "trackingSpeedAttributeId",
            "baseName": "tracking_speed_attribute_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetDogmaEffectsEffectIdOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdMembers200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * join_time string
    */
    'joinTime': Date;
    /**
    * Member’s role in fleet
    */
    'role': GetFleetsFleetIdMembers200Ok.RoleEnum;
    /**
    * Localized role names
    */
    'roleName': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * Solar system the member is located in
    */
    'solarSystemId': number;
    /**
    * ID of the squad the member is in. If not applicable, will be set to -1
    */
    'squadId': number;
    /**
    * Station in which the member is docked in, if applicable
    */
    'stationId'?: number;
    /**
    * Whether the member take fleet warps
    */
    'takesFleetWarp': boolean;
    /**
    * ID of the wing the member is in. If not applicable, will be set to -1
    */
    'wingId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "joinTime",
            "baseName": "join_time",
            "type": "Date"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "GetFleetsFleetIdMembers200Ok.RoleEnum"
        },
        {
            "name": "roleName",
            "baseName": "role_name",
            "type": "string"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "squadId",
            "baseName": "squad_id",
            "type": "number"
        },
        {
            "name": "stationId",
            "baseName": "station_id",
            "type": "number"
        },
        {
            "name": "takesFleetWarp",
            "baseName": "takes_fleet_warp",
            "type": "boolean"
        },
        {
            "name": "wingId",
            "baseName": "wing_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFleetsFleetIdMembers200Ok.attributeTypeMap;
    }
}

export namespace GetFleetsFleetIdMembers200Ok {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* Not found
*/
export class GetFleetsFleetIdMembersNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetFleetsFleetIdMembersNotFound.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetFleetsFleetIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetFleetsFleetIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdOk {
    /**
    * Is free-move enabled
    */
    'isFreeMove': boolean;
    /**
    * Does the fleet have an active fleet advertisement
    */
    'isRegistered': boolean;
    /**
    * Is EVE Voice enabled
    */
    'isVoiceEnabled': boolean;
    /**
    * Fleet MOTD in CCP flavoured HTML
    */
    'motd': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isFreeMove",
            "baseName": "is_free_move",
            "type": "boolean"
        },
        {
            "name": "isRegistered",
            "baseName": "is_registered",
            "type": "boolean"
        },
        {
            "name": "isVoiceEnabled",
            "baseName": "is_voice_enabled",
            "type": "boolean"
        },
        {
            "name": "motd",
            "baseName": "motd",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetFleetsFleetIdOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdWings200Ok {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
    /**
    * squads array
    */
    'squads': Array<GetFleetsFleetIdWingsSquad>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "squads",
            "baseName": "squads",
            "type": "Array<GetFleetsFleetIdWingsSquad>"
        }    ];

    static getAttributeTypeMap() {
        return GetFleetsFleetIdWings200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetFleetsFleetIdWingsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetFleetsFleetIdWingsNotFound.attributeTypeMap;
    }
}

/**
* squad object
*/
export class GetFleetsFleetIdWingsSquad {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetFleetsFleetIdWingsSquad.attributeTypeMap;
    }
}

/**
* active_total object
*/
export class GetFwLeaderboardsActiveTotalActiveTotal {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * faction_id integer
    */
    'factionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsActiveTotalActiveTotal.attributeTypeMap;
    }
}

/**
* active_total object
*/
export class GetFwLeaderboardsActiveTotalActiveTotal1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * faction_id integer
    */
    'factionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsActiveTotalActiveTotal1.attributeTypeMap;
    }
}

/**
* active_total object
*/
export class GetFwLeaderboardsCharactersActiveTotalActiveTotal {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersActiveTotalActiveTotal.attributeTypeMap;
    }
}

/**
* active_total object
*/
export class GetFwLeaderboardsCharactersActiveTotalActiveTotal1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersActiveTotalActiveTotal1.attributeTypeMap;
    }
}

/**
* Top 100 rankings of pilots by number of kills from yesterday, last week and in total
*/
export class GetFwLeaderboardsCharactersKills {
    /**
    * Top 100 ranking of pilots active in faction warfare by total kills. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
    */
    'activeTotal': Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal>;
    /**
    * Top 100 ranking of pilots by kills in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCharactersLastWeekLastWeek>;
    /**
    * Top 100 ranking of pilots by kills in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCharactersYesterdayYesterday>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeTotal",
            "baseName": "active_total",
            "type": "Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal>"
        },
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "Array<GetFwLeaderboardsCharactersLastWeekLastWeek>"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "Array<GetFwLeaderboardsCharactersYesterdayYesterday>"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersKills.attributeTypeMap;
    }
}

/**
* last_week object
*/
export class GetFwLeaderboardsCharactersLastWeekLastWeek {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersLastWeekLastWeek.attributeTypeMap;
    }
}

/**
* last_week object
*/
export class GetFwLeaderboardsCharactersLastWeekLastWeek1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersLastWeekLastWeek1.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFwLeaderboardsCharactersOk {
    'kills': GetFwLeaderboardsCharactersKills;
    'victoryPoints': GetFwLeaderboardsCharactersVictoryPoints;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kills",
            "baseName": "kills",
            "type": "GetFwLeaderboardsCharactersKills"
        },
        {
            "name": "victoryPoints",
            "baseName": "victory_points",
            "type": "GetFwLeaderboardsCharactersVictoryPoints"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersOk.attributeTypeMap;
    }
}

/**
* Top 100 rankings of pilots by victory points from yesterday, last week and in total
*/
export class GetFwLeaderboardsCharactersVictoryPoints {
    /**
    * Top 100 ranking of pilots active in faction warfare by total victory points. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
    */
    'activeTotal': Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal1>;
    /**
    * Top 100 ranking of pilots by victory points in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCharactersLastWeekLastWeek1>;
    /**
    * Top 100 ranking of pilots by victory points in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCharactersYesterdayYesterday1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeTotal",
            "baseName": "active_total",
            "type": "Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal1>"
        },
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "Array<GetFwLeaderboardsCharactersLastWeekLastWeek1>"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "Array<GetFwLeaderboardsCharactersYesterdayYesterday1>"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersVictoryPoints.attributeTypeMap;
    }
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCharactersYesterdayYesterday {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersYesterdayYesterday.attributeTypeMap;
    }
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCharactersYesterdayYesterday1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCharactersYesterdayYesterday1.attributeTypeMap;
    }
}

/**
* active_total object
*/
export class GetFwLeaderboardsCorporationsActiveTotalActiveTotal {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsActiveTotalActiveTotal.attributeTypeMap;
    }
}

/**
* active_total object
*/
export class GetFwLeaderboardsCorporationsActiveTotalActiveTotal1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsActiveTotalActiveTotal1.attributeTypeMap;
    }
}

/**
* Top 10 rankings of corporations by number of kills from yesterday, last week and in total
*/
export class GetFwLeaderboardsCorporationsKills {
    /**
    * Top 10 ranking of corporations active in faction warfare by total kills. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
    */
    'activeTotal': Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal>;
    /**
    * Top 10 ranking of corporations by kills in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCorporationsLastWeekLastWeek>;
    /**
    * Top 10 ranking of corporations by kills in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCorporationsYesterdayYesterday>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeTotal",
            "baseName": "active_total",
            "type": "Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal>"
        },
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "Array<GetFwLeaderboardsCorporationsLastWeekLastWeek>"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "Array<GetFwLeaderboardsCorporationsYesterdayYesterday>"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsKills.attributeTypeMap;
    }
}

/**
* last_week object
*/
export class GetFwLeaderboardsCorporationsLastWeekLastWeek {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsLastWeekLastWeek.attributeTypeMap;
    }
}

/**
* last_week object
*/
export class GetFwLeaderboardsCorporationsLastWeekLastWeek1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsLastWeekLastWeek1.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFwLeaderboardsCorporationsOk {
    'kills': GetFwLeaderboardsCorporationsKills;
    'victoryPoints': GetFwLeaderboardsCorporationsVictoryPoints;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kills",
            "baseName": "kills",
            "type": "GetFwLeaderboardsCorporationsKills"
        },
        {
            "name": "victoryPoints",
            "baseName": "victory_points",
            "type": "GetFwLeaderboardsCorporationsVictoryPoints"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsOk.attributeTypeMap;
    }
}

/**
* Top 10 rankings of corporations by victory points from yesterday, last week and in total
*/
export class GetFwLeaderboardsCorporationsVictoryPoints {
    /**
    * Top 10 ranking of corporations active in faction warfare by total victory points. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
    */
    'activeTotal': Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal1>;
    /**
    * Top 10 ranking of corporations by victory points in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCorporationsLastWeekLastWeek1>;
    /**
    * Top 10 ranking of corporations by victory points in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCorporationsYesterdayYesterday1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeTotal",
            "baseName": "active_total",
            "type": "Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal1>"
        },
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "Array<GetFwLeaderboardsCorporationsLastWeekLastWeek1>"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "Array<GetFwLeaderboardsCorporationsYesterdayYesterday1>"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsVictoryPoints.attributeTypeMap;
    }
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCorporationsYesterdayYesterday {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsYesterdayYesterday.attributeTypeMap;
    }
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCorporationsYesterdayYesterday1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsCorporationsYesterdayYesterday1.attributeTypeMap;
    }
}

/**
* Top 4 rankings of factions by number of kills from yesterday, last week and in total
*/
export class GetFwLeaderboardsKills {
    /**
    * Top 4 ranking of factions active in faction warfare by total kills. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
    */
    'activeTotal': Array<GetFwLeaderboardsActiveTotalActiveTotal>;
    /**
    * Top 4 ranking of factions by kills in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsLastWeekLastWeek>;
    /**
    * Top 4 ranking of factions by kills in the past day
    */
    'yesterday': Array<GetFwLeaderboardsYesterdayYesterday>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeTotal",
            "baseName": "active_total",
            "type": "Array<GetFwLeaderboardsActiveTotalActiveTotal>"
        },
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "Array<GetFwLeaderboardsLastWeekLastWeek>"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "Array<GetFwLeaderboardsYesterdayYesterday>"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsKills.attributeTypeMap;
    }
}

/**
* last_week object
*/
export class GetFwLeaderboardsLastWeekLastWeek {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * faction_id integer
    */
    'factionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsLastWeekLastWeek.attributeTypeMap;
    }
}

/**
* last_week object
*/
export class GetFwLeaderboardsLastWeekLastWeek1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * faction_id integer
    */
    'factionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsLastWeekLastWeek1.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFwLeaderboardsOk {
    'kills': GetFwLeaderboardsKills;
    'victoryPoints': GetFwLeaderboardsVictoryPoints;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kills",
            "baseName": "kills",
            "type": "GetFwLeaderboardsKills"
        },
        {
            "name": "victoryPoints",
            "baseName": "victory_points",
            "type": "GetFwLeaderboardsVictoryPoints"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsOk.attributeTypeMap;
    }
}

/**
* Top 4 rankings of factions by victory points from yesterday, last week and in total
*/
export class GetFwLeaderboardsVictoryPoints {
    /**
    * Top 4 ranking of factions active in faction warfare by total victory points. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
    */
    'activeTotal': Array<GetFwLeaderboardsActiveTotalActiveTotal1>;
    /**
    * Top 4 ranking of factions by victory points in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsLastWeekLastWeek1>;
    /**
    * Top 4 ranking of factions by victory points in the past day
    */
    'yesterday': Array<GetFwLeaderboardsYesterdayYesterday1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeTotal",
            "baseName": "active_total",
            "type": "Array<GetFwLeaderboardsActiveTotalActiveTotal1>"
        },
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "Array<GetFwLeaderboardsLastWeekLastWeek1>"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "Array<GetFwLeaderboardsYesterdayYesterday1>"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsVictoryPoints.attributeTypeMap;
    }
}

/**
* yesterday object
*/
export class GetFwLeaderboardsYesterdayYesterday {
    /**
    * Amount of kills
    */
    'amount'?: number;
    /**
    * faction_id integer
    */
    'factionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsYesterdayYesterday.attributeTypeMap;
    }
}

/**
* yesterday object
*/
export class GetFwLeaderboardsYesterdayYesterday1 {
    /**
    * Amount of victory points
    */
    'amount'?: number;
    /**
    * faction_id integer
    */
    'factionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwLeaderboardsYesterdayYesterday1.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFwStats200Ok {
    /**
    * faction_id integer
    */
    'factionId': number;
    'kills': GetFwStatsKills;
    /**
    * How many pilots fight for the given faction
    */
    'pilots': number;
    /**
    * The number of solar systems controlled by the given faction
    */
    'systemsControlled': number;
    'victoryPoints': GetFwStatsVictoryPoints;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "kills",
            "baseName": "kills",
            "type": "GetFwStatsKills"
        },
        {
            "name": "pilots",
            "baseName": "pilots",
            "type": "number"
        },
        {
            "name": "systemsControlled",
            "baseName": "systems_controlled",
            "type": "number"
        },
        {
            "name": "victoryPoints",
            "baseName": "victory_points",
            "type": "GetFwStatsVictoryPoints"
        }    ];

    static getAttributeTypeMap() {
        return GetFwStats200Ok.attributeTypeMap;
    }
}

/**
* Summary of kills against an enemy faction for the given faction
*/
export class GetFwStatsKills {
    /**
    * Last week's total number of kills against enemy factions
    */
    'lastWeek': number;
    /**
    * Total number of kills against enemy factions since faction warfare began
    */
    'total': number;
    /**
    * Yesterday's total number of kills against enemy factions
    */
    'yesterday': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwStatsKills.attributeTypeMap;
    }
}

/**
* Summary of victory points gained for the given faction
*/
export class GetFwStatsVictoryPoints {
    /**
    * Last week's victory points gained
    */
    'lastWeek': number;
    /**
    * Total victory points gained since faction warfare began
    */
    'total': number;
    /**
    * Yesterday's victory points gained
    */
    'yesterday': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastWeek",
            "baseName": "last_week",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "yesterday",
            "baseName": "yesterday",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwStatsVictoryPoints.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetFwSystems200Ok {
    /**
    * contested string
    */
    'contested': GetFwSystems200Ok.ContestedEnum;
    /**
    * occupier_faction_id integer
    */
    'occupierFactionId': number;
    /**
    * owner_faction_id integer
    */
    'ownerFactionId': number;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * victory_points integer
    */
    'victoryPoints': number;
    /**
    * victory_points_threshold integer
    */
    'victoryPointsThreshold': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contested",
            "baseName": "contested",
            "type": "GetFwSystems200Ok.ContestedEnum"
        },
        {
            "name": "occupierFactionId",
            "baseName": "occupier_faction_id",
            "type": "number"
        },
        {
            "name": "ownerFactionId",
            "baseName": "owner_faction_id",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "victoryPoints",
            "baseName": "victory_points",
            "type": "number"
        },
        {
            "name": "victoryPointsThreshold",
            "baseName": "victory_points_threshold",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwSystems200Ok.attributeTypeMap;
    }
}

export namespace GetFwSystems200Ok {
    export enum ContestedEnum {
        Captured = <any> 'captured',
        Contested = <any> 'contested',
        Uncontested = <any> 'uncontested',
        Vulnerable = <any> 'vulnerable'
    }
}
/**
* 200 ok object
*/
export class GetFwWars200Ok {
    /**
    * The faction ID of the enemy faction.
    */
    'againstId': number;
    /**
    * faction_id integer
    */
    'factionId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "againstId",
            "baseName": "against_id",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFwWars200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetIncursions200Ok {
    /**
    * The constellation id in which this incursion takes place
    */
    'constellationId': number;
    /**
    * The attacking faction's id
    */
    'factionId': number;
    /**
    * Whether the final encounter has boss or not
    */
    'hasBoss': boolean;
    /**
    * A list of infested solar system ids that are a part of this incursion
    */
    'infestedSolarSystems': Array<number>;
    /**
    * Influence of this incursion as a float from 0 to 1
    */
    'influence': number;
    /**
    * Staging solar system for this incursion
    */
    'stagingSolarSystemId': number;
    /**
    * The state of this incursion
    */
    'state': GetIncursions200Ok.StateEnum;
    /**
    * The type of this incursion
    */
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "constellationId",
            "baseName": "constellation_id",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "hasBoss",
            "baseName": "has_boss",
            "type": "boolean"
        },
        {
            "name": "infestedSolarSystems",
            "baseName": "infested_solar_systems",
            "type": "Array<number>"
        },
        {
            "name": "influence",
            "baseName": "influence",
            "type": "number"
        },
        {
            "name": "stagingSolarSystemId",
            "baseName": "staging_solar_system_id",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "GetIncursions200Ok.StateEnum"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetIncursions200Ok.attributeTypeMap;
    }
}

export namespace GetIncursions200Ok {
    export enum StateEnum {
        Withdrawing = <any> 'withdrawing',
        Mobilizing = <any> 'mobilizing',
        Established = <any> 'established'
    }
}
/**
* 200 ok object
*/
export class GetIndustryFacilities200Ok {
    /**
    * ID of the facility
    */
    'facilityId': number;
    /**
    * Owner of the facility
    */
    'ownerId': number;
    /**
    * Region ID where the facility is
    */
    'regionId': number;
    /**
    * Solar system ID where the facility is
    */
    'solarSystemId': number;
    /**
    * Tax imposed by the facility
    */
    'tax'?: number;
    /**
    * Type ID of the facility
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "facilityId",
            "baseName": "facility_id",
            "type": "number"
        },
        {
            "name": "ownerId",
            "baseName": "owner_id",
            "type": "number"
        },
        {
            "name": "regionId",
            "baseName": "region_id",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetIndustryFacilities200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetIndustrySystems200Ok {
    /**
    * cost_indices array
    */
    'costIndices': Array<GetIndustrySystemsCostIndice>;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "costIndices",
            "baseName": "cost_indices",
            "type": "Array<GetIndustrySystemsCostIndice>"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetIndustrySystems200Ok.attributeTypeMap;
    }
}

/**
* cost_indice object
*/
export class GetIndustrySystemsCostIndice {
    /**
    * activity string
    */
    'activity': GetIndustrySystemsCostIndice.ActivityEnum;
    /**
    * cost_index number
    */
    'costIndex': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activity",
            "baseName": "activity",
            "type": "GetIndustrySystemsCostIndice.ActivityEnum"
        },
        {
            "name": "costIndex",
            "baseName": "cost_index",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetIndustrySystemsCostIndice.attributeTypeMap;
    }
}

export namespace GetIndustrySystemsCostIndice {
    export enum ActivityEnum {
        Copying = <any> 'copying',
        Duplicating = <any> 'duplicating',
        Invention = <any> 'invention',
        Manufacturing = <any> 'manufacturing',
        None = <any> 'none',
        Reaction = <any> 'reaction',
        ResearchingMaterialEfficiency = <any> 'researching_material_efficiency',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeEfficiency = <any> 'researching_time_efficiency',
        ReverseEngineering = <any> 'reverse_engineering'
    }
}
/**
* 200 ok object
*/
export class GetInsurancePrices200Ok {
    /**
    * A list of a available insurance levels for this ship type
    */
    'levels': Array<GetInsurancePricesLevel>;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "levels",
            "baseName": "levels",
            "type": "Array<GetInsurancePricesLevel>"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetInsurancePrices200Ok.attributeTypeMap;
    }
}

/**
* level object
*/
export class GetInsurancePricesLevel {
    /**
    * cost number
    */
    'cost': number;
    /**
    * Localized insurance level
    */
    'name': string;
    /**
    * payout number
    */
    'payout': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "payout",
            "baseName": "payout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetInsurancePricesLevel.attributeTypeMap;
    }
}

/**
* attacker object
*/
export class GetKillmailsKillmailIdKillmailHashAttacker {
    /**
    * alliance_id integer
    */
    'allianceId'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;
    /**
    * damage_done integer
    */
    'damageDone': number;
    /**
    * faction_id integer
    */
    'factionId'?: number;
    /**
    * Was the attacker the one to achieve the final blow 
    */
    'finalBlow': boolean;
    /**
    * Security status for the attacker 
    */
    'securityStatus': number;
    /**
    * What ship was the attacker flying 
    */
    'shipTypeId'?: number;
    /**
    * What weapon was used by the attacker for the kill 
    */
    'weaponTypeId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "damageDone",
            "baseName": "damage_done",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "finalBlow",
            "baseName": "final_blow",
            "type": "boolean"
        },
        {
            "name": "securityStatus",
            "baseName": "security_status",
            "type": "number"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        },
        {
            "name": "weaponTypeId",
            "baseName": "weapon_type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetKillmailsKillmailIdKillmailHashAttacker.attributeTypeMap;
    }
}

/**
* item object
*/
export class GetKillmailsKillmailIdKillmailHashItem {
    /**
    * Flag for the location of the item 
    */
    'flag': number;
    /**
    * item_type_id integer
    */
    'itemTypeId': number;
    /**
    * items array
    */
    'items'?: Array<GetKillmailsKillmailIdKillmailHashItemsItem>;
    /**
    * How many of the item were destroyed if any 
    */
    'quantityDestroyed'?: number;
    /**
    * How many of the item were dropped if any 
    */
    'quantityDropped'?: number;
    /**
    * singleton integer
    */
    'singleton': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "flag",
            "baseName": "flag",
            "type": "number"
        },
        {
            "name": "itemTypeId",
            "baseName": "item_type_id",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<GetKillmailsKillmailIdKillmailHashItemsItem>"
        },
        {
            "name": "quantityDestroyed",
            "baseName": "quantity_destroyed",
            "type": "number"
        },
        {
            "name": "quantityDropped",
            "baseName": "quantity_dropped",
            "type": "number"
        },
        {
            "name": "singleton",
            "baseName": "singleton",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetKillmailsKillmailIdKillmailHashItem.attributeTypeMap;
    }
}

/**
* item object
*/
export class GetKillmailsKillmailIdKillmailHashItemsItem {
    /**
    * flag integer
    */
    'flag': number;
    /**
    * item_type_id integer
    */
    'itemTypeId': number;
    /**
    * quantity_destroyed integer
    */
    'quantityDestroyed'?: number;
    /**
    * quantity_dropped integer
    */
    'quantityDropped'?: number;
    /**
    * singleton integer
    */
    'singleton': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "flag",
            "baseName": "flag",
            "type": "number"
        },
        {
            "name": "itemTypeId",
            "baseName": "item_type_id",
            "type": "number"
        },
        {
            "name": "quantityDestroyed",
            "baseName": "quantity_destroyed",
            "type": "number"
        },
        {
            "name": "quantityDropped",
            "baseName": "quantity_dropped",
            "type": "number"
        },
        {
            "name": "singleton",
            "baseName": "singleton",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetKillmailsKillmailIdKillmailHashItemsItem.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetKillmailsKillmailIdKillmailHashOk {
    /**
    * attackers array
    */
    'attackers': Array<GetKillmailsKillmailIdKillmailHashAttacker>;
    /**
    * ID of the killmail
    */
    'killmailId': number;
    /**
    * Time that the victim was killed and the killmail generated 
    */
    'killmailTime': Date;
    /**
    * Moon if the kill took place at one
    */
    'moonId'?: number;
    /**
    * Solar system that the kill took place in 
    */
    'solarSystemId': number;
    'victim': GetKillmailsKillmailIdKillmailHashVictim;
    /**
    * War if the killmail is generated in relation to an official war 
    */
    'warId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attackers",
            "baseName": "attackers",
            "type": "Array<GetKillmailsKillmailIdKillmailHashAttacker>"
        },
        {
            "name": "killmailId",
            "baseName": "killmail_id",
            "type": "number"
        },
        {
            "name": "killmailTime",
            "baseName": "killmail_time",
            "type": "Date"
        },
        {
            "name": "moonId",
            "baseName": "moon_id",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "victim",
            "baseName": "victim",
            "type": "GetKillmailsKillmailIdKillmailHashVictim"
        },
        {
            "name": "warId",
            "baseName": "war_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetKillmailsKillmailIdKillmailHashOk.attributeTypeMap;
    }
}

/**
* Coordinates of the victim in Cartesian space relative to the Sun 
*/
export class GetKillmailsKillmailIdKillmailHashPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetKillmailsKillmailIdKillmailHashPosition.attributeTypeMap;
    }
}

/**
* Unprocessable entity
*/
export class GetKillmailsKillmailIdKillmailHashUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetKillmailsKillmailIdKillmailHashUnprocessableEntity.attributeTypeMap;
    }
}

/**
* victim object
*/
export class GetKillmailsKillmailIdKillmailHashVictim {
    /**
    * alliance_id integer
    */
    'allianceId'?: number;
    /**
    * character_id integer
    */
    'characterId'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;
    /**
    * How much total damage was taken by the victim 
    */
    'damageTaken': number;
    /**
    * faction_id integer
    */
    'factionId'?: number;
    /**
    * items array
    */
    'items'?: Array<GetKillmailsKillmailIdKillmailHashItem>;
    'position'?: GetKillmailsKillmailIdKillmailHashPosition;
    /**
    * The ship that the victim was piloting and was destroyed 
    */
    'shipTypeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "damageTaken",
            "baseName": "damage_taken",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<GetKillmailsKillmailIdKillmailHashItem>"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetKillmailsKillmailIdKillmailHashPosition"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetKillmailsKillmailIdKillmailHashVictim.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetLoyaltyStoresCorporationIdOffers200Ok {
    /**
    * Analysis kredit cost
    */
    'akCost'?: number;
    /**
    * isk_cost integer
    */
    'iskCost': number;
    /**
    * lp_cost integer
    */
    'lpCost': number;
    /**
    * offer_id integer
    */
    'offerId': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * required_items array
    */
    'requiredItems': Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "akCost",
            "baseName": "ak_cost",
            "type": "number"
        },
        {
            "name": "iskCost",
            "baseName": "isk_cost",
            "type": "number"
        },
        {
            "name": "lpCost",
            "baseName": "lp_cost",
            "type": "number"
        },
        {
            "name": "offerId",
            "baseName": "offer_id",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "requiredItems",
            "baseName": "required_items",
            "type": "Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetLoyaltyStoresCorporationIdOffers200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetLoyaltyStoresCorporationIdOffersNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetLoyaltyStoresCorporationIdOffersNotFound.attributeTypeMap;
    }
}

/**
* required_item object
*/
export class GetLoyaltyStoresCorporationIdOffersRequiredItem {
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetLoyaltyStoresCorporationIdOffersRequiredItem.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetMarketsGroupsMarketGroupIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsGroupsMarketGroupIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetMarketsGroupsMarketGroupIdOk {
    /**
    * description string
    */
    'description': string;
    /**
    * market_group_id integer
    */
    'marketGroupId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * parent_group_id integer
    */
    'parentGroupId'?: number;
    /**
    * types array
    */
    'types': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "marketGroupId",
            "baseName": "market_group_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parentGroupId",
            "baseName": "parent_group_id",
            "type": "number"
        },
        {
            "name": "types",
            "baseName": "types",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsGroupsMarketGroupIdOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetMarketsPrices200Ok {
    /**
    * adjusted_price number
    */
    'adjustedPrice'?: number;
    /**
    * average_price number
    */
    'averagePrice'?: number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "adjustedPrice",
            "baseName": "adjusted_price",
            "type": "number"
        },
        {
            "name": "averagePrice",
            "baseName": "average_price",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsPrices200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetMarketsRegionIdHistory200Ok {
    /**
    * average number
    */
    'average': number;
    /**
    * The date of this historical statistic entry
    */
    'date': string;
    /**
    * highest number
    */
    'highest': number;
    /**
    * lowest number
    */
    'lowest': number;
    /**
    * Total number of orders happened that day
    */
    'orderCount': number;
    /**
    * Total
    */
    'volume': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "average",
            "baseName": "average",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "highest",
            "baseName": "highest",
            "type": "number"
        },
        {
            "name": "lowest",
            "baseName": "lowest",
            "type": "number"
        },
        {
            "name": "orderCount",
            "baseName": "order_count",
            "type": "number"
        },
        {
            "name": "volume",
            "baseName": "volume",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsRegionIdHistory200Ok.attributeTypeMap;
    }
}

/**
* Error 520
*/
export class GetMarketsRegionIdHistoryError520 {
    /**
    * Error 520 message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsRegionIdHistoryError520.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetMarketsRegionIdHistoryNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsRegionIdHistoryNotFound.attributeTypeMap;
    }
}

/**
* Unprocessable entity
*/
export class GetMarketsRegionIdHistoryUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsRegionIdHistoryUnprocessableEntity.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetMarketsRegionIdOrders200Ok {
    /**
    * duration integer
    */
    'duration': number;
    /**
    * is_buy_order boolean
    */
    'isBuyOrder': boolean;
    /**
    * issued string
    */
    'issued': Date;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * min_volume integer
    */
    'minVolume': number;
    /**
    * order_id integer
    */
    'orderId': number;
    /**
    * price number
    */
    'price': number;
    /**
    * range string
    */
    'range': GetMarketsRegionIdOrders200Ok.RangeEnum;
    /**
    * The solar system this order was placed
    */
    'systemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * volume_remain integer
    */
    'volumeRemain': number;
    /**
    * volume_total integer
    */
    'volumeTotal': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "isBuyOrder",
            "baseName": "is_buy_order",
            "type": "boolean"
        },
        {
            "name": "issued",
            "baseName": "issued",
            "type": "Date"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "minVolume",
            "baseName": "min_volume",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "range",
            "baseName": "range",
            "type": "GetMarketsRegionIdOrders200Ok.RangeEnum"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "volumeRemain",
            "baseName": "volume_remain",
            "type": "number"
        },
        {
            "name": "volumeTotal",
            "baseName": "volume_total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsRegionIdOrders200Ok.attributeTypeMap;
    }
}

export namespace GetMarketsRegionIdOrders200Ok {
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}
/**
* Not found
*/
export class GetMarketsRegionIdOrdersNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsRegionIdOrdersNotFound.attributeTypeMap;
    }
}

/**
* Unprocessable entity
*/
export class GetMarketsRegionIdOrdersUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsRegionIdOrdersUnprocessableEntity.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetMarketsStructuresStructureId200Ok {
    /**
    * duration integer
    */
    'duration': number;
    /**
    * is_buy_order boolean
    */
    'isBuyOrder': boolean;
    /**
    * issued string
    */
    'issued': Date;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * min_volume integer
    */
    'minVolume': number;
    /**
    * order_id integer
    */
    'orderId': number;
    /**
    * price number
    */
    'price': number;
    /**
    * range string
    */
    'range': GetMarketsStructuresStructureId200Ok.RangeEnum;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * volume_remain integer
    */
    'volumeRemain': number;
    /**
    * volume_total integer
    */
    'volumeTotal': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "isBuyOrder",
            "baseName": "is_buy_order",
            "type": "boolean"
        },
        {
            "name": "issued",
            "baseName": "issued",
            "type": "Date"
        },
        {
            "name": "locationId",
            "baseName": "location_id",
            "type": "number"
        },
        {
            "name": "minVolume",
            "baseName": "min_volume",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "range",
            "baseName": "range",
            "type": "GetMarketsStructuresStructureId200Ok.RangeEnum"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "volumeRemain",
            "baseName": "volume_remain",
            "type": "number"
        },
        {
            "name": "volumeTotal",
            "baseName": "volume_total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetMarketsStructuresStructureId200Ok.attributeTypeMap;
    }
}

export namespace GetMarketsStructuresStructureId200Ok {
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}
/**
* 200 ok object
*/
export class GetOpportunitiesGroupsGroupIdOk {
    /**
    * The groups that are connected to this group on the opportunities map
    */
    'connectedGroups': Array<number>;
    /**
    * description string
    */
    'description': string;
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * notification string
    */
    'notification': string;
    /**
    * Tasks need to complete for this group
    */
    'requiredTasks': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectedGroups",
            "baseName": "connected_groups",
            "type": "Array<number>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "notification",
            "baseName": "notification",
            "type": "string"
        },
        {
            "name": "requiredTasks",
            "baseName": "required_tasks",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetOpportunitiesGroupsGroupIdOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetOpportunitiesTasksTaskIdOk {
    /**
    * description string
    */
    'description': string;
    /**
    * name string
    */
    'name': string;
    /**
    * notification string
    */
    'notification': string;
    /**
    * task_id integer
    */
    'taskId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "notification",
            "baseName": "notification",
            "type": "string"
        },
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetOpportunitiesTasksTaskIdOk.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetRouteOriginDestinationNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetRouteOriginDestinationNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetSearchOk {
    /**
    * agent array
    */
    'agent'?: Array<number>;
    /**
    * alliance array
    */
    'alliance'?: Array<number>;
    /**
    * character array
    */
    'character'?: Array<number>;
    /**
    * constellation array
    */
    'constellation'?: Array<number>;
    /**
    * corporation array
    */
    'corporation'?: Array<number>;
    /**
    * faction array
    */
    'faction'?: Array<number>;
    /**
    * inventory_type array
    */
    'inventoryType'?: Array<number>;
    /**
    * region array
    */
    'region'?: Array<number>;
    /**
    * solar_system array
    */
    'solarSystem'?: Array<number>;
    /**
    * station array
    */
    'station'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agent",
            "baseName": "agent",
            "type": "Array<number>"
        },
        {
            "name": "alliance",
            "baseName": "alliance",
            "type": "Array<number>"
        },
        {
            "name": "character",
            "baseName": "character",
            "type": "Array<number>"
        },
        {
            "name": "constellation",
            "baseName": "constellation",
            "type": "Array<number>"
        },
        {
            "name": "corporation",
            "baseName": "corporation",
            "type": "Array<number>"
        },
        {
            "name": "faction",
            "baseName": "faction",
            "type": "Array<number>"
        },
        {
            "name": "inventoryType",
            "baseName": "inventory_type",
            "type": "Array<number>"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "Array<number>"
        },
        {
            "name": "solarSystem",
            "baseName": "solar_system",
            "type": "Array<number>"
        },
        {
            "name": "station",
            "baseName": "station",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetSearchOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetSovereigntyCampaigns200Ok {
    /**
    * Score for all attacking parties, only present in Defense Events. 
    */
    'attackersScore'?: number;
    /**
    * Unique ID for this campaign.
    */
    'campaignId': number;
    /**
    * The constellation in which the campaign will take place. 
    */
    'constellationId': number;
    /**
    * Defending alliance, only present in Defense Events 
    */
    'defenderId'?: number;
    /**
    * Score for the defending alliance, only present in Defense Events. 
    */
    'defenderScore'?: number;
    /**
    * Type of event this campaign is for. tcu_defense, ihub_defense and station_defense are referred to as \"Defense Events\", station_freeport as \"Freeport Events\". 
    */
    'eventType': GetSovereigntyCampaigns200Ok.EventTypeEnum;
    /**
    * Alliance participating and their respective scores, only present in Freeport Events. 
    */
    'participants'?: Array<GetSovereigntyCampaignsParticipant>;
    /**
    * The solar system the structure is located in. 
    */
    'solarSystemId': number;
    /**
    * Time the event is scheduled to start. 
    */
    'startTime': Date;
    /**
    * The structure item ID that is related to this campaign. 
    */
    'structureId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attackersScore",
            "baseName": "attackers_score",
            "type": "number"
        },
        {
            "name": "campaignId",
            "baseName": "campaign_id",
            "type": "number"
        },
        {
            "name": "constellationId",
            "baseName": "constellation_id",
            "type": "number"
        },
        {
            "name": "defenderId",
            "baseName": "defender_id",
            "type": "number"
        },
        {
            "name": "defenderScore",
            "baseName": "defender_score",
            "type": "number"
        },
        {
            "name": "eventType",
            "baseName": "event_type",
            "type": "GetSovereigntyCampaigns200Ok.EventTypeEnum"
        },
        {
            "name": "participants",
            "baseName": "participants",
            "type": "Array<GetSovereigntyCampaignsParticipant>"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "Date"
        },
        {
            "name": "structureId",
            "baseName": "structure_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSovereigntyCampaigns200Ok.attributeTypeMap;
    }
}

export namespace GetSovereigntyCampaigns200Ok {
    export enum EventTypeEnum {
        TcuDefense = <any> 'tcu_defense',
        IhubDefense = <any> 'ihub_defense',
        StationDefense = <any> 'station_defense',
        StationFreeport = <any> 'station_freeport'
    }
}
/**
* participant object
*/
export class GetSovereigntyCampaignsParticipant {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * score number
    */
    'score': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSovereigntyCampaignsParticipant.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetSovereigntyMap200Ok {
    /**
    * alliance_id integer
    */
    'allianceId'?: number;
    /**
    * corporation_id integer
    */
    'corporationId'?: number;
    /**
    * faction_id integer
    */
    'factionId'?: number;
    /**
    * system_id integer
    */
    'systemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSovereigntyMap200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetSovereigntyStructures200Ok {
    /**
    * The alliance that owns the structure. 
    */
    'allianceId': number;
    /**
    * Solar system in which the structure is located. 
    */
    'solarSystemId': number;
    /**
    * Unique item ID for this structure.
    */
    'structureId': number;
    /**
    * A reference to the type of structure this is. 
    */
    'structureTypeId': number;
    /**
    * The occupancy level for the next or current vulnerability window. This takes into account all development indexes and capital system bonuses. Also known as Activity Defense Multiplier from in the client. It increases the time that attackers must spend using their entosis links on the structure. 
    */
    'vulnerabilityOccupancyLevel'?: number;
    /**
    * The time at which the next or current vulnerability window ends. At the end of a vulnerability window the next window is recalculated and locked in along with the vulnerabilityOccupancyLevel. If the structure is not in 100% entosis control of the defender, it will go in to 'overtime' and stay vulnerable for as long as that situation persists. Only once the defenders have 100% entosis control and has the vulnerableEndTime passed does the vulnerability interval expire and a new one is calculated. 
    */
    'vulnerableEndTime'?: Date;
    /**
    * The next time at which the structure will become vulnerable. Or the start time of the current window if current time is between this and vulnerableEndTime. 
    */
    'vulnerableStartTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "structureId",
            "baseName": "structure_id",
            "type": "number"
        },
        {
            "name": "structureTypeId",
            "baseName": "structure_type_id",
            "type": "number"
        },
        {
            "name": "vulnerabilityOccupancyLevel",
            "baseName": "vulnerability_occupancy_level",
            "type": "number"
        },
        {
            "name": "vulnerableEndTime",
            "baseName": "vulnerable_end_time",
            "type": "Date"
        },
        {
            "name": "vulnerableStartTime",
            "baseName": "vulnerable_start_time",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetSovereigntyStructures200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetStatusOk {
    /**
    * Current online player count
    */
    'players': number;
    /**
    * Running version as string
    */
    'serverVersion': string;
    /**
    * Server start timestamp
    */
    'startTime': Date;
    /**
    * If the server is in VIP mode
    */
    'vip'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "players",
            "baseName": "players",
            "type": "number"
        },
        {
            "name": "serverVersion",
            "baseName": "server_version",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "Date"
        },
        {
            "name": "vip",
            "baseName": "vip",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetStatusOk.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseAncestries200Ok {
    /**
    * The bloodline associated with this ancestry
    */
    'bloodlineId': number;
    /**
    * description string
    */
    'description': string;
    /**
    * icon_id integer
    */
    'iconId'?: number;
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
    /**
    * short_description string
    */
    'shortDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bloodlineId",
            "baseName": "bloodline_id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "iconId",
            "baseName": "icon_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseAncestries200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseAsteroidBeltsAsteroidBeltIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseAsteroidBeltsAsteroidBeltIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseAsteroidBeltsAsteroidBeltIdOk {
    /**
    * name string
    */
    'name': string;
    'position': GetUniverseAsteroidBeltsAsteroidBeltIdPosition;
    /**
    * The solar system this asteroid belt is in
    */
    'systemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniverseAsteroidBeltsAsteroidBeltIdPosition"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseAsteroidBeltsAsteroidBeltIdOk.attributeTypeMap;
    }
}

/**
* position object
*/
export class GetUniverseAsteroidBeltsAsteroidBeltIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseAsteroidBeltsAsteroidBeltIdPosition.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseBloodlines200Ok {
    /**
    * bloodline_id integer
    */
    'bloodlineId': number;
    /**
    * charisma integer
    */
    'charisma': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * description string
    */
    'description': string;
    /**
    * intelligence integer
    */
    'intelligence': number;
    /**
    * memory integer
    */
    'memory': number;
    /**
    * name string
    */
    'name': string;
    /**
    * perception integer
    */
    'perception': number;
    /**
    * race_id integer
    */
    'raceId': number;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * willpower integer
    */
    'willpower': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bloodlineId",
            "baseName": "bloodline_id",
            "type": "number"
        },
        {
            "name": "charisma",
            "baseName": "charisma",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "intelligence",
            "baseName": "intelligence",
            "type": "number"
        },
        {
            "name": "memory",
            "baseName": "memory",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "perception",
            "baseName": "perception",
            "type": "number"
        },
        {
            "name": "raceId",
            "baseName": "race_id",
            "type": "number"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        },
        {
            "name": "willpower",
            "baseName": "willpower",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseBloodlines200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseCategoriesCategoryIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseCategoriesCategoryIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseCategoriesCategoryIdOk {
    /**
    * category_id integer
    */
    'categoryId': number;
    /**
    * groups array
    */
    'groups': Array<number>;
    /**
    * name string
    */
    'name': string;
    /**
    * published boolean
    */
    'published': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryId",
            "baseName": "category_id",
            "type": "number"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<number>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseCategoriesCategoryIdOk.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseConstellationsConstellationIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseConstellationsConstellationIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseConstellationsConstellationIdOk {
    /**
    * constellation_id integer
    */
    'constellationId': number;
    /**
    * name string
    */
    'name': string;
    'position': GetUniverseConstellationsConstellationIdPosition;
    /**
    * The region this constellation is in
    */
    'regionId': number;
    /**
    * systems array
    */
    'systems': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "constellationId",
            "baseName": "constellation_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniverseConstellationsConstellationIdPosition"
        },
        {
            "name": "regionId",
            "baseName": "region_id",
            "type": "number"
        },
        {
            "name": "systems",
            "baseName": "systems",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseConstellationsConstellationIdOk.attributeTypeMap;
    }
}

/**
* position object
*/
export class GetUniverseConstellationsConstellationIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseConstellationsConstellationIdPosition.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseFactions200Ok {
    /**
    * corporation_id integer
    */
    'corporationId'?: number;
    /**
    * description string
    */
    'description': string;
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * is_unique boolean
    */
    'isUnique': boolean;
    /**
    * militia_corporation_id integer
    */
    'militiaCorporationId'?: number;
    /**
    * name string
    */
    'name': string;
    /**
    * size_factor number
    */
    'sizeFactor': number;
    /**
    * solar_system_id integer
    */
    'solarSystemId'?: number;
    /**
    * station_count integer
    */
    'stationCount': number;
    /**
    * station_system_count integer
    */
    'stationSystemCount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        },
        {
            "name": "isUnique",
            "baseName": "is_unique",
            "type": "boolean"
        },
        {
            "name": "militiaCorporationId",
            "baseName": "militia_corporation_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sizeFactor",
            "baseName": "size_factor",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "stationCount",
            "baseName": "station_count",
            "type": "number"
        },
        {
            "name": "stationSystemCount",
            "baseName": "station_system_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseFactions200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseGraphicsGraphicIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseGraphicsGraphicIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseGraphicsGraphicIdOk {
    /**
    * collision_file string
    */
    'collisionFile'?: string;
    /**
    * graphic_file string
    */
    'graphicFile'?: string;
    /**
    * graphic_id integer
    */
    'graphicId': number;
    /**
    * icon_folder string
    */
    'iconFolder'?: string;
    /**
    * sof_dna string
    */
    'sofDna'?: string;
    /**
    * sof_fation_name string
    */
    'sofFationName'?: string;
    /**
    * sof_hull_name string
    */
    'sofHullName'?: string;
    /**
    * sof_race_name string
    */
    'sofRaceName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "collisionFile",
            "baseName": "collision_file",
            "type": "string"
        },
        {
            "name": "graphicFile",
            "baseName": "graphic_file",
            "type": "string"
        },
        {
            "name": "graphicId",
            "baseName": "graphic_id",
            "type": "number"
        },
        {
            "name": "iconFolder",
            "baseName": "icon_folder",
            "type": "string"
        },
        {
            "name": "sofDna",
            "baseName": "sof_dna",
            "type": "string"
        },
        {
            "name": "sofFationName",
            "baseName": "sof_fation_name",
            "type": "string"
        },
        {
            "name": "sofHullName",
            "baseName": "sof_hull_name",
            "type": "string"
        },
        {
            "name": "sofRaceName",
            "baseName": "sof_race_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseGraphicsGraphicIdOk.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseGroupsGroupIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseGroupsGroupIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseGroupsGroupIdOk {
    /**
    * category_id integer
    */
    'categoryId': number;
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * types array
    */
    'types': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryId",
            "baseName": "category_id",
            "type": "number"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "types",
            "baseName": "types",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseGroupsGroupIdOk.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseMoonsMoonIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseMoonsMoonIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseMoonsMoonIdOk {
    /**
    * moon_id integer
    */
    'moonId': number;
    /**
    * name string
    */
    'name': string;
    'position': GetUniverseMoonsMoonIdPosition;
    /**
    * The solar system this moon is in
    */
    'systemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "moonId",
            "baseName": "moon_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniverseMoonsMoonIdPosition"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseMoonsMoonIdOk.attributeTypeMap;
    }
}

/**
* position object
*/
export class GetUniverseMoonsMoonIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseMoonsMoonIdPosition.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniversePlanetsPlanetIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniversePlanetsPlanetIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniversePlanetsPlanetIdOk {
    /**
    * name string
    */
    'name': string;
    /**
    * planet_id integer
    */
    'planetId': number;
    'position': GetUniversePlanetsPlanetIdPosition;
    /**
    * The solar system this planet is in
    */
    'systemId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "planetId",
            "baseName": "planet_id",
            "type": "number"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniversePlanetsPlanetIdPosition"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniversePlanetsPlanetIdOk.attributeTypeMap;
    }
}

/**
* position object
*/
export class GetUniversePlanetsPlanetIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniversePlanetsPlanetIdPosition.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseRaces200Ok {
    /**
    * The alliance generally associated with this race
    */
    'allianceId': number;
    /**
    * description string
    */
    'description': string;
    /**
    * name string
    */
    'name': string;
    /**
    * race_id integer
    */
    'raceId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "raceId",
            "baseName": "race_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseRaces200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseRegionsRegionIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseRegionsRegionIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseRegionsRegionIdOk {
    /**
    * constellations array
    */
    'constellations': Array<number>;
    /**
    * description string
    */
    'description'?: string;
    /**
    * name string
    */
    'name': string;
    /**
    * region_id integer
    */
    'regionId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "constellations",
            "baseName": "constellations",
            "type": "Array<number>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "regionId",
            "baseName": "region_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseRegionsRegionIdOk.attributeTypeMap;
    }
}

/**
* Schematic not found
*/
export class GetUniverseSchematicsSchematicIdNotFound {
    /**
    * error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSchematicsSchematicIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseSchematicsSchematicIdOk {
    /**
    * Time in seconds to process a run
    */
    'cycleTime': number;
    /**
    * schematic_name string
    */
    'schematicName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cycleTime",
            "baseName": "cycle_time",
            "type": "number"
        },
        {
            "name": "schematicName",
            "baseName": "schematic_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSchematicsSchematicIdOk.attributeTypeMap;
    }
}

/**
* destination object
*/
export class GetUniverseStargatesStargateIdDestination {
    /**
    * The stargate this stargate connects to
    */
    'stargateId': number;
    /**
    * The solar system this stargate connects to
    */
    'systemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stargateId",
            "baseName": "stargate_id",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStargatesStargateIdDestination.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseStargatesStargateIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStargatesStargateIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseStargatesStargateIdOk {
    'destination': GetUniverseStargatesStargateIdDestination;
    /**
    * name string
    */
    'name': string;
    'position': GetUniverseStargatesStargateIdPosition;
    /**
    * stargate_id integer
    */
    'stargateId': number;
    /**
    * The solar system this stargate is in
    */
    'systemId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "destination",
            "baseName": "destination",
            "type": "GetUniverseStargatesStargateIdDestination"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniverseStargatesStargateIdPosition"
        },
        {
            "name": "stargateId",
            "baseName": "stargate_id",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStargatesStargateIdOk.attributeTypeMap;
    }
}

/**
* position object
*/
export class GetUniverseStargatesStargateIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStargatesStargateIdPosition.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseStarsStarIdOk {
    /**
    * Age of star in years
    */
    'age': number;
    /**
    * luminosity number
    */
    'luminosity': number;
    /**
    * name string
    */
    'name': string;
    /**
    * radius integer
    */
    'radius': number;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * spectral_class string
    */
    'spectralClass': GetUniverseStarsStarIdOk.SpectralClassEnum;
    /**
    * temperature integer
    */
    'temperature': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "age",
            "baseName": "age",
            "type": "number"
        },
        {
            "name": "luminosity",
            "baseName": "luminosity",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "radius",
            "baseName": "radius",
            "type": "number"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "spectralClass",
            "baseName": "spectral_class",
            "type": "GetUniverseStarsStarIdOk.SpectralClassEnum"
        },
        {
            "name": "temperature",
            "baseName": "temperature",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStarsStarIdOk.attributeTypeMap;
    }
}

export namespace GetUniverseStarsStarIdOk {
    export enum SpectralClassEnum {
        K2V = <any> 'K2 V',
        K4V = <any> 'K4 V',
        G2V = <any> 'G2 V',
        G8V = <any> 'G8 V',
        M7V = <any> 'M7 V',
        K7V = <any> 'K7 V',
        M2V = <any> 'M2 V',
        K5V = <any> 'K5 V',
        M3V = <any> 'M3 V',
        G0V = <any> 'G0 V',
        G7V = <any> 'G7 V',
        G3V = <any> 'G3 V',
        F9V = <any> 'F9 V',
        G5V = <any> 'G5 V',
        F6V = <any> 'F6 V',
        K8V = <any> 'K8 V',
        K9V = <any> 'K9 V',
        K6V = <any> 'K6 V',
        G9V = <any> 'G9 V',
        G6V = <any> 'G6 V',
        G4VI = <any> 'G4 VI',
        G4V = <any> 'G4 V',
        F8V = <any> 'F8 V',
        F2V = <any> 'F2 V',
        F1V = <any> 'F1 V',
        K3V = <any> 'K3 V',
        F0VI = <any> 'F0 VI',
        G1VI = <any> 'G1 VI',
        G0VI = <any> 'G0 VI',
        K1V = <any> 'K1 V',
        M4V = <any> 'M4 V',
        M1V = <any> 'M1 V',
        M6V = <any> 'M6 V',
        M0V = <any> 'M0 V',
        K2IV = <any> 'K2 IV',
        G2VI = <any> 'G2 VI',
        K0V = <any> 'K0 V',
        K5IV = <any> 'K5 IV',
        F5VI = <any> 'F5 VI',
        G6VI = <any> 'G6 VI',
        F6VI = <any> 'F6 VI',
        F2IV = <any> 'F2 IV',
        G3VI = <any> 'G3 VI',
        M8V = <any> 'M8 V',
        F1VI = <any> 'F1 VI',
        K1IV = <any> 'K1 IV',
        F7V = <any> 'F7 V',
        G5VI = <any> 'G5 VI',
        M5V = <any> 'M5 V',
        G7VI = <any> 'G7 VI',
        F5V = <any> 'F5 V',
        F4VI = <any> 'F4 VI',
        F8VI = <any> 'F8 VI',
        K3IV = <any> 'K3 IV',
        F4IV = <any> 'F4 IV',
        F0V = <any> 'F0 V',
        G7IV = <any> 'G7 IV',
        G8VI = <any> 'G8 VI',
        F2VI = <any> 'F2 VI',
        F4V = <any> 'F4 V',
        F7VI = <any> 'F7 VI',
        F3V = <any> 'F3 V',
        G1V = <any> 'G1 V',
        G9VI = <any> 'G9 VI',
        F3IV = <any> 'F3 IV',
        F9VI = <any> 'F9 VI',
        M9V = <any> 'M9 V',
        K0IV = <any> 'K0 IV',
        F1IV = <any> 'F1 IV',
        G4IV = <any> 'G4 IV',
        F3VI = <any> 'F3 VI',
        K4IV = <any> 'K4 IV',
        G5IV = <any> 'G5 IV',
        G3IV = <any> 'G3 IV',
        G1IV = <any> 'G1 IV',
        K7IV = <any> 'K7 IV',
        G0IV = <any> 'G0 IV',
        K6IV = <any> 'K6 IV',
        K9IV = <any> 'K9 IV',
        G2IV = <any> 'G2 IV',
        F9IV = <any> 'F9 IV',
        F0IV = <any> 'F0 IV',
        K8IV = <any> 'K8 IV',
        G8IV = <any> 'G8 IV',
        F6IV = <any> 'F6 IV',
        F5IV = <any> 'F5 IV',
        A0 = <any> 'A0',
        A0IV = <any> 'A0IV',
        A0IV2 = <any> 'A0IV2'
    }
}
/**
* Not found
*/
export class GetUniverseStationsStationIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStationsStationIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseStationsStationIdOk {
    /**
    * max_dockable_ship_volume number
    */
    'maxDockableShipVolume': number;
    /**
    * name string
    */
    'name': string;
    /**
    * office_rental_cost number
    */
    'officeRentalCost': number;
    /**
    * ID of the corporation that controls this station
    */
    'owner'?: number;
    'position': GetUniverseStationsStationIdPosition;
    /**
    * race_id integer
    */
    'raceId'?: number;
    /**
    * reprocessing_efficiency number
    */
    'reprocessingEfficiency': number;
    /**
    * reprocessing_stations_take number
    */
    'reprocessingStationsTake': number;
    /**
    * services array
    */
    'services': Array<GetUniverseStationsStationIdOk.ServicesEnum>;
    /**
    * station_id integer
    */
    'stationId': number;
    /**
    * The solar system this station is in
    */
    'systemId': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxDockableShipVolume",
            "baseName": "max_dockable_ship_volume",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "officeRentalCost",
            "baseName": "office_rental_cost",
            "type": "number"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "number"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniverseStationsStationIdPosition"
        },
        {
            "name": "raceId",
            "baseName": "race_id",
            "type": "number"
        },
        {
            "name": "reprocessingEfficiency",
            "baseName": "reprocessing_efficiency",
            "type": "number"
        },
        {
            "name": "reprocessingStationsTake",
            "baseName": "reprocessing_stations_take",
            "type": "number"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<GetUniverseStationsStationIdOk.ServicesEnum>"
        },
        {
            "name": "stationId",
            "baseName": "station_id",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStationsStationIdOk.attributeTypeMap;
    }
}

export namespace GetUniverseStationsStationIdOk {
    export enum ServicesEnum {
        BountyMissions = <any> 'bounty-missions',
        AssasinationMissions = <any> 'assasination-missions',
        CourierMissions = <any> 'courier-missions',
        Interbus = <any> 'interbus',
        ReprocessingPlant = <any> 'reprocessing-plant',
        Refinery = <any> 'refinery',
        Market = <any> 'market',
        BlackMarket = <any> 'black-market',
        StockExchange = <any> 'stock-exchange',
        Cloning = <any> 'cloning',
        Surgery = <any> 'surgery',
        DnaTherapy = <any> 'dna-therapy',
        RepairFacilities = <any> 'repair-facilities',
        Factory = <any> 'factory',
        Labratory = <any> 'labratory',
        Gambling = <any> 'gambling',
        Fitting = <any> 'fitting',
        Paintshop = <any> 'paintshop',
        News = <any> 'news',
        Storage = <any> 'storage',
        Insurance = <any> 'insurance',
        Docking = <any> 'docking',
        OfficeRental = <any> 'office-rental',
        JumpCloneFacility = <any> 'jump-clone-facility',
        LoyaltyPointStore = <any> 'loyalty-point-store',
        NavyOffices = <any> 'navy-offices',
        SecurityOffices = <any> 'security-offices'
    }
}
/**
* position object
*/
export class GetUniverseStationsStationIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStationsStationIdPosition.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseStructuresStructureIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStructuresStructureIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseStructuresStructureIdOk {
    /**
    * The full name of the structure
    */
    'name': string;
    /**
    * The ID of the corporation who owns this particular structure
    */
    'ownerId': number;
    'position'?: GetUniverseStructuresStructureIdPosition;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * type_id integer
    */
    'typeId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "ownerId",
            "baseName": "owner_id",
            "type": "number"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniverseStructuresStructureIdPosition"
        },
        {
            "name": "solarSystemId",
            "baseName": "solar_system_id",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStructuresStructureIdOk.attributeTypeMap;
    }
}

/**
* Coordinates of the structure in Cartesian space relative to the Sun, in metres. 
*/
export class GetUniverseStructuresStructureIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseStructuresStructureIdPosition.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseSystemJumps200Ok {
    /**
    * ship_jumps integer
    */
    'shipJumps': number;
    /**
    * system_id integer
    */
    'systemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shipJumps",
            "baseName": "ship_jumps",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSystemJumps200Ok.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseSystemKills200Ok {
    /**
    * Number of NPC ships killed in this system
    */
    'npcKills': number;
    /**
    * Number of pods killed in this system
    */
    'podKills': number;
    /**
    * Number of player ships killed in this system
    */
    'shipKills': number;
    /**
    * system_id integer
    */
    'systemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "npcKills",
            "baseName": "npc_kills",
            "type": "number"
        },
        {
            "name": "podKills",
            "baseName": "pod_kills",
            "type": "number"
        },
        {
            "name": "shipKills",
            "baseName": "ship_kills",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSystemKills200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseSystemsSystemIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSystemsSystemIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseSystemsSystemIdOk {
    /**
    * The constellation this solar system is in
    */
    'constellationId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * planets array
    */
    'planets'?: Array<GetUniverseSystemsSystemIdPlanet>;
    'position': GetUniverseSystemsSystemIdPosition;
    /**
    * security_class string
    */
    'securityClass'?: string;
    /**
    * security_status number
    */
    'securityStatus': number;
    /**
    * star_id integer
    */
    'starId'?: number;
    /**
    * stargates array
    */
    'stargates'?: Array<number>;
    /**
    * stations array
    */
    'stations'?: Array<number>;
    /**
    * system_id integer
    */
    'systemId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "constellationId",
            "baseName": "constellation_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "planets",
            "baseName": "planets",
            "type": "Array<GetUniverseSystemsSystemIdPlanet>"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "GetUniverseSystemsSystemIdPosition"
        },
        {
            "name": "securityClass",
            "baseName": "security_class",
            "type": "string"
        },
        {
            "name": "securityStatus",
            "baseName": "security_status",
            "type": "number"
        },
        {
            "name": "starId",
            "baseName": "star_id",
            "type": "number"
        },
        {
            "name": "stargates",
            "baseName": "stargates",
            "type": "Array<number>"
        },
        {
            "name": "stations",
            "baseName": "stations",
            "type": "Array<number>"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSystemsSystemIdOk.attributeTypeMap;
    }
}

/**
* planet object
*/
export class GetUniverseSystemsSystemIdPlanet {
    /**
    * asteroid_belts array
    */
    'asteroidBelts'?: Array<number>;
    /**
    * moons array
    */
    'moons'?: Array<number>;
    /**
    * planet_id integer
    */
    'planetId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "asteroidBelts",
            "baseName": "asteroid_belts",
            "type": "Array<number>"
        },
        {
            "name": "moons",
            "baseName": "moons",
            "type": "Array<number>"
        },
        {
            "name": "planetId",
            "baseName": "planet_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSystemsSystemIdPlanet.attributeTypeMap;
    }
}

/**
* position object
*/
export class GetUniverseSystemsSystemIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseSystemsSystemIdPosition.attributeTypeMap;
    }
}

/**
* dogma_attribute object
*/
export class GetUniverseTypesTypeIdDogmaAttribute {
    /**
    * attribute_id integer
    */
    'attributeId': number;
    /**
    * value number
    */
    'value': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributeId",
            "baseName": "attribute_id",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseTypesTypeIdDogmaAttribute.attributeTypeMap;
    }
}

/**
* dogma_effect object
*/
export class GetUniverseTypesTypeIdDogmaEffect {
    /**
    * effect_id integer
    */
    'effectId': number;
    /**
    * is_default boolean
    */
    'isDefault': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "effectId",
            "baseName": "effect_id",
            "type": "number"
        },
        {
            "name": "isDefault",
            "baseName": "is_default",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseTypesTypeIdDogmaEffect.attributeTypeMap;
    }
}

/**
* Not found
*/
export class GetUniverseTypesTypeIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseTypesTypeIdNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetUniverseTypesTypeIdOk {
    /**
    * capacity number
    */
    'capacity'?: number;
    /**
    * description string
    */
    'description': string;
    /**
    * dogma_attributes array
    */
    'dogmaAttributes'?: Array<GetUniverseTypesTypeIdDogmaAttribute>;
    /**
    * dogma_effects array
    */
    'dogmaEffects'?: Array<GetUniverseTypesTypeIdDogmaEffect>;
    /**
    * graphic_id integer
    */
    'graphicId'?: number;
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * icon_id integer
    */
    'iconId'?: number;
    /**
    * This only exists for types that can be put on the market
    */
    'marketGroupId'?: number;
    /**
    * mass number
    */
    'mass'?: number;
    /**
    * name string
    */
    'name': string;
    /**
    * packaged_volume number
    */
    'packagedVolume'?: number;
    /**
    * portion_size integer
    */
    'portionSize'?: number;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * radius number
    */
    'radius'?: number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * volume number
    */
    'volume'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "capacity",
            "baseName": "capacity",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dogmaAttributes",
            "baseName": "dogma_attributes",
            "type": "Array<GetUniverseTypesTypeIdDogmaAttribute>"
        },
        {
            "name": "dogmaEffects",
            "baseName": "dogma_effects",
            "type": "Array<GetUniverseTypesTypeIdDogmaEffect>"
        },
        {
            "name": "graphicId",
            "baseName": "graphic_id",
            "type": "number"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "number"
        },
        {
            "name": "iconId",
            "baseName": "icon_id",
            "type": "number"
        },
        {
            "name": "marketGroupId",
            "baseName": "market_group_id",
            "type": "number"
        },
        {
            "name": "mass",
            "baseName": "mass",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "packagedVolume",
            "baseName": "packaged_volume",
            "type": "number"
        },
        {
            "name": "portionSize",
            "baseName": "portion_size",
            "type": "number"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "radius",
            "baseName": "radius",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        },
        {
            "name": "volume",
            "baseName": "volume",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetUniverseTypesTypeIdOk.attributeTypeMap;
    }
}

/**
* The aggressor corporation or alliance that declared this war, only contains either corporation_id or alliance_id
*/
export class GetWarsWarIdAggressor {
    /**
    * Alliance ID if and only if the aggressor is an alliance
    */
    'allianceId'?: number;
    /**
    * Corporation ID if and only if the aggressor is a corporation
    */
    'corporationId'?: number;
    /**
    * ISK value of ships the aggressor has destroyed
    */
    'iskDestroyed': number;
    /**
    * The number of ships the aggressor has killed
    */
    'shipsKilled': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "iskDestroyed",
            "baseName": "isk_destroyed",
            "type": "number"
        },
        {
            "name": "shipsKilled",
            "baseName": "ships_killed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetWarsWarIdAggressor.attributeTypeMap;
    }
}

/**
* ally object
*/
export class GetWarsWarIdAlly {
    /**
    * Alliance ID if and only if this ally is an alliance
    */
    'allianceId'?: number;
    /**
    * Corporation ID if and only if this ally is a corporation
    */
    'corporationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetWarsWarIdAlly.attributeTypeMap;
    }
}

/**
* The defending corporation or alliance that declared this war, only contains either corporation_id or alliance_id
*/
export class GetWarsWarIdDefender {
    /**
    * Alliance ID if and only if the defender is an alliance
    */
    'allianceId'?: number;
    /**
    * Corporation ID if and only if the defender is a corporation
    */
    'corporationId'?: number;
    /**
    * ISK value of ships the defender has killed
    */
    'iskDestroyed': number;
    /**
    * The number of ships the defender has killed
    */
    'shipsKilled': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "iskDestroyed",
            "baseName": "isk_destroyed",
            "type": "number"
        },
        {
            "name": "shipsKilled",
            "baseName": "ships_killed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetWarsWarIdDefender.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetWarsWarIdKillmails200Ok {
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
    /**
    * ID of this killmail
    */
    'killmailId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "killmailHash",
            "baseName": "killmail_hash",
            "type": "string"
        },
        {
            "name": "killmailId",
            "baseName": "killmail_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetWarsWarIdKillmails200Ok.attributeTypeMap;
    }
}

/**
* Unprocessable entity
*/
export class GetWarsWarIdKillmailsUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetWarsWarIdKillmailsUnprocessableEntity.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class GetWarsWarIdOk {
    'aggressor': GetWarsWarIdAggressor;
    /**
    * allied corporations or alliances, each object contains either corporation_id or alliance_id
    */
    'allies'?: Array<GetWarsWarIdAlly>;
    /**
    * Time that the war was declared
    */
    'declared': Date;
    'defender': GetWarsWarIdDefender;
    /**
    * Time the war ended and shooting was no longer allowed
    */
    'finished'?: Date;
    /**
    * ID of the specified war
    */
    'id': number;
    /**
    * Was the war declared mutual by both parties
    */
    'mutual': boolean;
    /**
    * Is the war currently open for allies or not
    */
    'openForAllies': boolean;
    /**
    * Time the war was retracted but both sides could still shoot each other
    */
    'retracted'?: Date;
    /**
    * Time when the war started and both sides could shoot each other
    */
    'started'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggressor",
            "baseName": "aggressor",
            "type": "GetWarsWarIdAggressor"
        },
        {
            "name": "allies",
            "baseName": "allies",
            "type": "Array<GetWarsWarIdAlly>"
        },
        {
            "name": "declared",
            "baseName": "declared",
            "type": "Date"
        },
        {
            "name": "defender",
            "baseName": "defender",
            "type": "GetWarsWarIdDefender"
        },
        {
            "name": "finished",
            "baseName": "finished",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "mutual",
            "baseName": "mutual",
            "type": "boolean"
        },
        {
            "name": "openForAllies",
            "baseName": "open_for_allies",
            "type": "boolean"
        },
        {
            "name": "retracted",
            "baseName": "retracted",
            "type": "Date"
        },
        {
            "name": "started",
            "baseName": "started",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GetWarsWarIdOk.attributeTypeMap;
    }
}

/**
* Unprocessable entity
*/
export class GetWarsWarIdUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetWarsWarIdUnprocessableEntity.attributeTypeMap;
    }
}

/**
* Internal server error model
*/
export class InternalServerError {
    /**
    * Internal server error message
    */
    'error': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InternalServerError.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class PostCharactersAffiliation200Ok {
    /**
    * The character's alliance ID, if their corporation is in an alliance
    */
    'allianceId'?: number;
    /**
    * The character's ID
    */
    'characterId': number;
    /**
    * The character's corporation ID
    */
    'corporationId': number;
    /**
    * The character's faction ID, if their corporation is in a faction
    */
    'factionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allianceId",
            "baseName": "alliance_id",
            "type": "number"
        },
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "corporationId",
            "baseName": "corporation_id",
            "type": "number"
        },
        {
            "name": "factionId",
            "baseName": "faction_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersAffiliation200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PostCharactersAffiliationNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersAffiliationNotFound.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class PostCharactersCharacterIdAssetsLocations200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    'position': PostCharactersCharacterIdAssetsLocationsPosition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "PostCharactersCharacterIdAssetsLocationsPosition"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdAssetsLocations200Ok.attributeTypeMap;
    }
}

/**
* position object
*/
export class PostCharactersCharacterIdAssetsLocationsPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdAssetsLocationsPosition.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class PostCharactersCharacterIdAssetsNames200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdAssetsNames200Ok.attributeTypeMap;
    }
}

/**
* Error 520
*/
export class PostCharactersCharacterIdContactsError520 {
    /**
    * Error 520 message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdContactsError520.attributeTypeMap;
    }
}

/**
* 201 created object
*/
export class PostCharactersCharacterIdFittingsCreated {
    /**
    * fitting_id integer
    */
    'fittingId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fittingId",
            "baseName": "fitting_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdFittingsCreated.attributeTypeMap;
    }
}

/**
* fitting object
*/
export class PostCharactersCharacterIdFittingsFitting {
    /**
    * description string
    */
    'description': string;
    /**
    * items array
    */
    'items': Array<PostCharactersCharacterIdFittingsItem>;
    /**
    * name string
    */
    'name': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<PostCharactersCharacterIdFittingsItem>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shipTypeId",
            "baseName": "ship_type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdFittingsFitting.attributeTypeMap;
    }
}

/**
* item object
*/
export class PostCharactersCharacterIdFittingsItem {
    /**
    * Fitting location for the item. Entries placed in 'Invalid' will be discarded. If this leaves the fitting with nothing, it will cause an error.
    */
    'flag': PostCharactersCharacterIdFittingsItem.FlagEnum;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "flag",
            "baseName": "flag",
            "type": "PostCharactersCharacterIdFittingsItem.FlagEnum"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdFittingsItem.attributeTypeMap;
    }
}

export namespace PostCharactersCharacterIdFittingsItem {
    export enum FlagEnum {
        Cargo = <any> 'Cargo',
        DroneBay = <any> 'DroneBay',
        FighterBay = <any> 'FighterBay',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        Invalid = <any> 'Invalid',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3'
    }
}
/**
* Error 520
*/
export class PostCharactersCharacterIdMailError520 {
    /**
    * Error 520 message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdMailError520.attributeTypeMap;
    }
}

/**
* label object
*/
export class PostCharactersCharacterIdMailLabelsLabel {
    /**
    * Hexadecimal string representing label color, in RGB format
    */
    'color'?: PostCharactersCharacterIdMailLabelsLabel.ColorEnum;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "PostCharactersCharacterIdMailLabelsLabel.ColorEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdMailLabelsLabel.attributeTypeMap;
    }
}

export namespace PostCharactersCharacterIdMailLabelsLabel {
    export enum ColorEnum {
        _0000fe = <any> '#0000fe',
        _006634 = <any> '#006634',
        _0099ff = <any> '#0099ff',
        _00ff33 = <any> '#00ff33',
        _01ffff = <any> '#01ffff',
        _349800 = <any> '#349800',
        _660066 = <any> '#660066',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        _99ffff = <any> '#99ffff',
        _9a0000 = <any> '#9a0000',
        Ccff9a = <any> '#ccff9a',
        E6e6e6 = <any> '#e6e6e6',
        Fe0000 = <any> '#fe0000',
        Ff6600 = <any> '#ff6600',
        Ffff01 = <any> '#ffff01',
        Ffffcd = <any> '#ffffcd',
        Ffffff = <any> '#ffffff'
    }
}
/**
* mail object
*/
export class PostCharactersCharacterIdMailMail {
    /**
    * approved_cost integer
    */
    'approvedCost'?: number;
    /**
    * body string
    */
    'body': string;
    /**
    * recipients array
    */
    'recipients': Array<PostCharactersCharacterIdMailRecipient>;
    /**
    * subject string
    */
    'subject': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvedCost",
            "baseName": "approved_cost",
            "type": "number"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<PostCharactersCharacterIdMailRecipient>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdMailMail.attributeTypeMap;
    }
}

/**
* recipient object
*/
export class PostCharactersCharacterIdMailRecipient {
    /**
    * recipient_id integer
    */
    'recipientId': number;
    /**
    * recipient_type string
    */
    'recipientType': PostCharactersCharacterIdMailRecipient.RecipientTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipientId",
            "baseName": "recipient_id",
            "type": "number"
        },
        {
            "name": "recipientType",
            "baseName": "recipient_type",
            "type": "PostCharactersCharacterIdMailRecipient.RecipientTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return PostCharactersCharacterIdMailRecipient.attributeTypeMap;
    }
}

export namespace PostCharactersCharacterIdMailRecipient {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* 200 ok object
*/
export class PostCorporationsCorporationIdAssetsLocations200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    'position': PostCorporationsCorporationIdAssetsLocationsPosition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "PostCorporationsCorporationIdAssetsLocationsPosition"
        }    ];

    static getAttributeTypeMap() {
        return PostCorporationsCorporationIdAssetsLocations200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PostCorporationsCorporationIdAssetsLocationsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCorporationsCorporationIdAssetsLocationsNotFound.attributeTypeMap;
    }
}

/**
* position object
*/
export class PostCorporationsCorporationIdAssetsLocationsPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "number"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostCorporationsCorporationIdAssetsLocationsPosition.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class PostCorporationsCorporationIdAssetsNames200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCorporationsCorporationIdAssetsNames200Ok.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PostCorporationsCorporationIdAssetsNamesNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostCorporationsCorporationIdAssetsNamesNotFound.attributeTypeMap;
    }
}

/**
* invitation object
*/
export class PostFleetsFleetIdMembersInvitation {
    /**
    * The character you want to invite
    */
    'characterId': number;
    /**
    * If a character is invited with the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is invited with the `wing_commander` role, only `wing_id` should be specified. If a character is invited with the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is invited with the `squad_member` role, `wing_id` and `squad_id` should either both be specified or not specified at all. If they aren’t specified, the invited character will join any squad with available positions.
    */
    'role': PostFleetsFleetIdMembersInvitation.RoleEnum;
    /**
    * squad_id integer
    */
    'squadId'?: number;
    /**
    * wing_id integer
    */
    'wingId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "characterId",
            "baseName": "character_id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "PostFleetsFleetIdMembersInvitation.RoleEnum"
        },
        {
            "name": "squadId",
            "baseName": "squad_id",
            "type": "number"
        },
        {
            "name": "wingId",
            "baseName": "wing_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostFleetsFleetIdMembersInvitation.attributeTypeMap;
    }
}

export namespace PostFleetsFleetIdMembersInvitation {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* Not found
*/
export class PostFleetsFleetIdMembersNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostFleetsFleetIdMembersNotFound.attributeTypeMap;
    }
}

/**
* 422 unprocessable entity object
*/
export class PostFleetsFleetIdMembersUnprocessableEntity {
    /**
    * error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostFleetsFleetIdMembersUnprocessableEntity.attributeTypeMap;
    }
}

/**
* 201 created object
*/
export class PostFleetsFleetIdWingsCreated {
    /**
    * The wing_id of the newly created wing
    */
    'wingId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "wingId",
            "baseName": "wing_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostFleetsFleetIdWingsCreated.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PostFleetsFleetIdWingsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostFleetsFleetIdWingsNotFound.attributeTypeMap;
    }
}

/**
* 201 created object
*/
export class PostFleetsFleetIdWingsWingIdSquadsCreated {
    /**
    * The squad_id of the newly created squad
    */
    'squadId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "squadId",
            "baseName": "squad_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostFleetsFleetIdWingsWingIdSquadsCreated.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PostFleetsFleetIdWingsWingIdSquadsNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostFleetsFleetIdWingsWingIdSquadsNotFound.attributeTypeMap;
    }
}

/**
* new_mail object
*/
export class PostUiOpenwindowNewmailNewMail {
    /**
    * body string
    */
    'body': string;
    /**
    * recipients array
    */
    'recipients': Array<number>;
    /**
    * subject string
    */
    'subject': string;
    /**
    * to_corp_or_alliance_id integer
    */
    'toCorpOrAllianceId'?: number;
    /**
    * Corporations, alliances and mailing lists are all types of mailing groups. You may only send to one mailing group, at a time, so you may fill out either this field or the to_corp_or_alliance_ids field
    */
    'toMailingListId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<number>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "toCorpOrAllianceId",
            "baseName": "to_corp_or_alliance_id",
            "type": "number"
        },
        {
            "name": "toMailingListId",
            "baseName": "to_mailing_list_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostUiOpenwindowNewmailNewMail.attributeTypeMap;
    }
}

/**
* Unprocessable entity
*/
export class PostUiOpenwindowNewmailUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUiOpenwindowNewmailUnprocessableEntity.attributeTypeMap;
    }
}

/**
* agent object
*/
export class PostUniverseIdsAgent {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsAgent.attributeTypeMap;
    }
}

/**
* alliance object
*/
export class PostUniverseIdsAlliance {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsAlliance.attributeTypeMap;
    }
}

/**
* character object
*/
export class PostUniverseIdsCharacter {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsCharacter.attributeTypeMap;
    }
}

/**
* constellation object
*/
export class PostUniverseIdsConstellation {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsConstellation.attributeTypeMap;
    }
}

/**
* corporation object
*/
export class PostUniverseIdsCorporation {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsCorporation.attributeTypeMap;
    }
}

/**
* faction object
*/
export class PostUniverseIdsFaction {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsFaction.attributeTypeMap;
    }
}

/**
* inventory_type object
*/
export class PostUniverseIdsInventoryType {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsInventoryType.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class PostUniverseIdsOk {
    /**
    * agents array
    */
    'agents'?: Array<PostUniverseIdsAgent>;
    /**
    * alliances array
    */
    'alliances'?: Array<PostUniverseIdsAlliance>;
    /**
    * characters array
    */
    'characters'?: Array<PostUniverseIdsCharacter>;
    /**
    * constellations array
    */
    'constellations'?: Array<PostUniverseIdsConstellation>;
    /**
    * corporations array
    */
    'corporations'?: Array<PostUniverseIdsCorporation>;
    /**
    * factions array
    */
    'factions'?: Array<PostUniverseIdsFaction>;
    /**
    * inventory_types array
    */
    'inventoryTypes'?: Array<PostUniverseIdsInventoryType>;
    /**
    * regions array
    */
    'regions'?: Array<PostUniverseIdsRegion>;
    /**
    * stations array
    */
    'stations'?: Array<PostUniverseIdsStation>;
    /**
    * systems array
    */
    'systems'?: Array<PostUniverseIdsSystem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agents",
            "baseName": "agents",
            "type": "Array<PostUniverseIdsAgent>"
        },
        {
            "name": "alliances",
            "baseName": "alliances",
            "type": "Array<PostUniverseIdsAlliance>"
        },
        {
            "name": "characters",
            "baseName": "characters",
            "type": "Array<PostUniverseIdsCharacter>"
        },
        {
            "name": "constellations",
            "baseName": "constellations",
            "type": "Array<PostUniverseIdsConstellation>"
        },
        {
            "name": "corporations",
            "baseName": "corporations",
            "type": "Array<PostUniverseIdsCorporation>"
        },
        {
            "name": "factions",
            "baseName": "factions",
            "type": "Array<PostUniverseIdsFaction>"
        },
        {
            "name": "inventoryTypes",
            "baseName": "inventory_types",
            "type": "Array<PostUniverseIdsInventoryType>"
        },
        {
            "name": "regions",
            "baseName": "regions",
            "type": "Array<PostUniverseIdsRegion>"
        },
        {
            "name": "stations",
            "baseName": "stations",
            "type": "Array<PostUniverseIdsStation>"
        },
        {
            "name": "systems",
            "baseName": "systems",
            "type": "Array<PostUniverseIdsSystem>"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsOk.attributeTypeMap;
    }
}

/**
* region object
*/
export class PostUniverseIdsRegion {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsRegion.attributeTypeMap;
    }
}

/**
* station object
*/
export class PostUniverseIdsStation {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsStation.attributeTypeMap;
    }
}

/**
* system object
*/
export class PostUniverseIdsSystem {
    /**
    * id integer
    */
    'id'?: number;
    /**
    * name string
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseIdsSystem.attributeTypeMap;
    }
}

/**
* 200 ok object
*/
export class PostUniverseNames200Ok {
    /**
    * category string
    */
    'category': PostUniverseNames200Ok.CategoryEnum;
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "PostUniverseNames200Ok.CategoryEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseNames200Ok.attributeTypeMap;
    }
}

export namespace PostUniverseNames200Ok {
    export enum CategoryEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Constellation = <any> 'constellation',
        Corporation = <any> 'corporation',
        InventoryType = <any> 'inventory_type',
        Region = <any> 'region',
        SolarSystem = <any> 'solar_system',
        Station = <any> 'station',
        Faction = <any> 'faction'
    }
}
/**
* Not found
*/
export class PostUniverseNamesNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostUniverseNamesNotFound.attributeTypeMap;
    }
}

/**
* response object
*/
export class PutCharactersCharacterIdCalendarEventIdResponse {
    /**
    * response string
    */
    'response': PutCharactersCharacterIdCalendarEventIdResponse.ResponseEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "PutCharactersCharacterIdCalendarEventIdResponse.ResponseEnum"
        }    ];

    static getAttributeTypeMap() {
        return PutCharactersCharacterIdCalendarEventIdResponse.attributeTypeMap;
    }
}

export namespace PutCharactersCharacterIdCalendarEventIdResponse {
    export enum ResponseEnum {
        Accepted = <any> 'accepted',
        Declined = <any> 'declined',
        Tentative = <any> 'tentative'
    }
}
/**
* contents object
*/
export class PutCharactersCharacterIdMailMailIdContents {
    /**
    * Labels to assign to the mail. Pre-existing labels are unassigned.
    */
    'labels'?: Array<number>;
    /**
    * Whether the mail is flagged as read
    */
    'read'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<number>"
        },
        {
            "name": "read",
            "baseName": "read",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PutCharactersCharacterIdMailMailIdContents.attributeTypeMap;
    }
}

/**
* movement object
*/
export class PutFleetsFleetIdMembersMemberIdMovement {
    /**
    * If a character is moved to the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is moved to the `wing_commander` role, only `wing_id` should be specified. If a character is moved to the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is moved to the `squad_member` role, both `wing_id` and `squad_id` should be specified.
    */
    'role': PutFleetsFleetIdMembersMemberIdMovement.RoleEnum;
    /**
    * squad_id integer
    */
    'squadId'?: number;
    /**
    * wing_id integer
    */
    'wingId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "role",
            "baseName": "role",
            "type": "PutFleetsFleetIdMembersMemberIdMovement.RoleEnum"
        },
        {
            "name": "squadId",
            "baseName": "squad_id",
            "type": "number"
        },
        {
            "name": "wingId",
            "baseName": "wing_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdMembersMemberIdMovement.attributeTypeMap;
    }
}

export namespace PutFleetsFleetIdMembersMemberIdMovement {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* Not found
*/
export class PutFleetsFleetIdMembersMemberIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdMembersMemberIdNotFound.attributeTypeMap;
    }
}

/**
* 422 unprocessable entity object
*/
export class PutFleetsFleetIdMembersMemberIdUnprocessableEntity {
    /**
    * error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdMembersMemberIdUnprocessableEntity.attributeTypeMap;
    }
}

/**
* new_settings object
*/
export class PutFleetsFleetIdNewSettings {
    /**
    * Should free-move be enabled in the fleet
    */
    'isFreeMove'?: boolean;
    /**
    * New fleet MOTD in CCP flavoured HTML
    */
    'motd'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isFreeMove",
            "baseName": "is_free_move",
            "type": "boolean"
        },
        {
            "name": "motd",
            "baseName": "motd",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdNewSettings.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PutFleetsFleetIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdNotFound.attributeTypeMap;
    }
}

/**
* naming object
*/
export class PutFleetsFleetIdSquadsSquadIdNaming {
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdSquadsSquadIdNaming.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PutFleetsFleetIdSquadsSquadIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdSquadsSquadIdNotFound.attributeTypeMap;
    }
}

/**
* naming object
*/
export class PutFleetsFleetIdWingsWingIdNaming {
    /**
    * name string
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdWingsWingIdNaming.attributeTypeMap;
    }
}

/**
* Not found
*/
export class PutFleetsFleetIdWingsWingIdNotFound {
    /**
    * Not found message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutFleetsFleetIdWingsWingIdNotFound.attributeTypeMap;
    }
}

/**
* Service unavailable model
*/
export class ServiceUnavailable {
    /**
    * Service unavailable message
    */
    'error': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ServiceUnavailable.attributeTypeMap;
    }
}

/**
* Unauthorized model
*/
export class Unauthorized {
    /**
    * Unauthorized message
    */
    'error': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Unauthorized.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "GetAlliancesAllianceIdContacts200Ok.ContactTypeEnum": GetAlliancesAllianceIdContacts200Ok.ContactTypeEnum,
        "GetCharactersCharacterIdAssets200Ok.LocationFlagEnum": GetCharactersCharacterIdAssets200Ok.LocationFlagEnum,
        "GetCharactersCharacterIdAssets200Ok.LocationTypeEnum": GetCharactersCharacterIdAssets200Ok.LocationTypeEnum,
        "GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum": GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum,
        "GetCharactersCharacterIdCalendar200Ok.EventResponseEnum": GetCharactersCharacterIdCalendar200Ok.EventResponseEnum,
        "GetCharactersCharacterIdCalendarEventIdAttendees200Ok.EventResponseEnum": GetCharactersCharacterIdCalendarEventIdAttendees200Ok.EventResponseEnum,
        "GetCharactersCharacterIdCalendarEventIdOk.OwnerTypeEnum": GetCharactersCharacterIdCalendarEventIdOk.OwnerTypeEnum,
        "GetCharactersCharacterIdClonesHomeLocation.LocationTypeEnum": GetCharactersCharacterIdClonesHomeLocation.LocationTypeEnum,
        "GetCharactersCharacterIdClonesJumpClone.LocationTypeEnum": GetCharactersCharacterIdClonesJumpClone.LocationTypeEnum,
        "GetCharactersCharacterIdContacts200Ok.ContactTypeEnum": GetCharactersCharacterIdContacts200Ok.ContactTypeEnum,
        "GetCharactersCharacterIdContracts200Ok.AvailabilityEnum": GetCharactersCharacterIdContracts200Ok.AvailabilityEnum,
        "GetCharactersCharacterIdContracts200Ok.StatusEnum": GetCharactersCharacterIdContracts200Ok.StatusEnum,
        "GetCharactersCharacterIdContracts200Ok.TypeEnum": GetCharactersCharacterIdContracts200Ok.TypeEnum,
        "GetCharactersCharacterIdFittingsItem.FlagEnum": GetCharactersCharacterIdFittingsItem.FlagEnum,
        "GetCharactersCharacterIdFleetOk.RoleEnum": GetCharactersCharacterIdFleetOk.RoleEnum,
        "GetCharactersCharacterIdIndustryJobs200Ok.StatusEnum": GetCharactersCharacterIdIndustryJobs200Ok.StatusEnum,
        "GetCharactersCharacterIdMailLabelsLabel.ColorEnum": GetCharactersCharacterIdMailLabelsLabel.ColorEnum,
        "GetCharactersCharacterIdMailMailIdRecipient.RecipientTypeEnum": GetCharactersCharacterIdMailMailIdRecipient.RecipientTypeEnum,
        "GetCharactersCharacterIdMailRecipient.RecipientTypeEnum": GetCharactersCharacterIdMailRecipient.RecipientTypeEnum,
        "GetCharactersCharacterIdMedals200Ok.StatusEnum": GetCharactersCharacterIdMedals200Ok.StatusEnum,
        "GetCharactersCharacterIdNotifications200Ok.SenderTypeEnum": GetCharactersCharacterIdNotifications200Ok.SenderTypeEnum,
        "GetCharactersCharacterIdNotifications200Ok.TypeEnum": GetCharactersCharacterIdNotifications200Ok.TypeEnum,
        "GetCharactersCharacterIdOk.GenderEnum": GetCharactersCharacterIdOk.GenderEnum,
        "GetCharactersCharacterIdOrders200Ok.RangeEnum": GetCharactersCharacterIdOrders200Ok.RangeEnum,
        "GetCharactersCharacterIdOrdersHistory200Ok.RangeEnum": GetCharactersCharacterIdOrdersHistory200Ok.RangeEnum,
        "GetCharactersCharacterIdOrdersHistory200Ok.StateEnum": GetCharactersCharacterIdOrdersHistory200Ok.StateEnum,
        "GetCharactersCharacterIdPlanets200Ok.PlanetTypeEnum": GetCharactersCharacterIdPlanets200Ok.PlanetTypeEnum,
        "GetCharactersCharacterIdRolesOk.RolesEnum": GetCharactersCharacterIdRolesOk.RolesEnum,
        "GetCharactersCharacterIdRolesOk.RolesAtBaseEnum": GetCharactersCharacterIdRolesOk.RolesAtBaseEnum,
        "GetCharactersCharacterIdRolesOk.RolesAtHqEnum": GetCharactersCharacterIdRolesOk.RolesAtHqEnum,
        "GetCharactersCharacterIdRolesOk.RolesAtOtherEnum": GetCharactersCharacterIdRolesOk.RolesAtOtherEnum,
        "GetCharactersCharacterIdStandings200Ok.FromTypeEnum": GetCharactersCharacterIdStandings200Ok.FromTypeEnum,
        "GetCharactersCharacterIdWalletJournal200Ok.ContextIdTypeEnum": GetCharactersCharacterIdWalletJournal200Ok.ContextIdTypeEnum,
        "GetCharactersCharacterIdWalletJournal200Ok.RefTypeEnum": GetCharactersCharacterIdWalletJournal200Ok.RefTypeEnum,
        "GetContractsPublicRegionId200Ok.TypeEnum": GetContractsPublicRegionId200Ok.TypeEnum,
        "GetCorporationCorporationIdMiningObservers200Ok.ObserverTypeEnum": GetCorporationCorporationIdMiningObservers200Ok.ObserverTypeEnum,
        "GetCorporationsCorporationIdAssets200Ok.LocationFlagEnum": GetCorporationsCorporationIdAssets200Ok.LocationFlagEnum,
        "GetCorporationsCorporationIdAssets200Ok.LocationTypeEnum": GetCorporationsCorporationIdAssets200Ok.LocationTypeEnum,
        "GetCorporationsCorporationIdBlueprints200Ok.LocationFlagEnum": GetCorporationsCorporationIdBlueprints200Ok.LocationFlagEnum,
        "GetCorporationsCorporationIdContacts200Ok.ContactTypeEnum": GetCorporationsCorporationIdContacts200Ok.ContactTypeEnum,
        "GetCorporationsCorporationIdContainersLogs200Ok.ActionEnum": GetCorporationsCorporationIdContainersLogs200Ok.ActionEnum,
        "GetCorporationsCorporationIdContainersLogs200Ok.LocationFlagEnum": GetCorporationsCorporationIdContainersLogs200Ok.LocationFlagEnum,
        "GetCorporationsCorporationIdContainersLogs200Ok.PasswordTypeEnum": GetCorporationsCorporationIdContainersLogs200Ok.PasswordTypeEnum,
        "GetCorporationsCorporationIdContracts200Ok.AvailabilityEnum": GetCorporationsCorporationIdContracts200Ok.AvailabilityEnum,
        "GetCorporationsCorporationIdContracts200Ok.StatusEnum": GetCorporationsCorporationIdContracts200Ok.StatusEnum,
        "GetCorporationsCorporationIdContracts200Ok.TypeEnum": GetCorporationsCorporationIdContracts200Ok.TypeEnum,
        "GetCorporationsCorporationIdCustomsOffices200Ok.StandingLevelEnum": GetCorporationsCorporationIdCustomsOffices200Ok.StandingLevelEnum,
        "GetCorporationsCorporationIdIndustryJobs200Ok.StatusEnum": GetCorporationsCorporationIdIndustryJobs200Ok.StatusEnum,
        "GetCorporationsCorporationIdMedalsIssued200Ok.StatusEnum": GetCorporationsCorporationIdMedalsIssued200Ok.StatusEnum,
        "GetCorporationsCorporationIdOrders200Ok.RangeEnum": GetCorporationsCorporationIdOrders200Ok.RangeEnum,
        "GetCorporationsCorporationIdOrdersHistory200Ok.RangeEnum": GetCorporationsCorporationIdOrdersHistory200Ok.RangeEnum,
        "GetCorporationsCorporationIdOrdersHistory200Ok.StateEnum": GetCorporationsCorporationIdOrdersHistory200Ok.StateEnum,
        "GetCorporationsCorporationIdRoles200Ok.GrantableRolesEnum": GetCorporationsCorporationIdRoles200Ok.GrantableRolesEnum,
        "GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtBaseEnum": GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtBaseEnum,
        "GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtHqEnum": GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtHqEnum,
        "GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtOtherEnum": GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtOtherEnum,
        "GetCorporationsCorporationIdRoles200Ok.RolesEnum": GetCorporationsCorporationIdRoles200Ok.RolesEnum,
        "GetCorporationsCorporationIdRoles200Ok.RolesAtBaseEnum": GetCorporationsCorporationIdRoles200Ok.RolesAtBaseEnum,
        "GetCorporationsCorporationIdRoles200Ok.RolesAtHqEnum": GetCorporationsCorporationIdRoles200Ok.RolesAtHqEnum,
        "GetCorporationsCorporationIdRoles200Ok.RolesAtOtherEnum": GetCorporationsCorporationIdRoles200Ok.RolesAtOtherEnum,
        "GetCorporationsCorporationIdRolesHistory200Ok.NewRolesEnum": GetCorporationsCorporationIdRolesHistory200Ok.NewRolesEnum,
        "GetCorporationsCorporationIdRolesHistory200Ok.OldRolesEnum": GetCorporationsCorporationIdRolesHistory200Ok.OldRolesEnum,
        "GetCorporationsCorporationIdRolesHistory200Ok.RoleTypeEnum": GetCorporationsCorporationIdRolesHistory200Ok.RoleTypeEnum,
        "GetCorporationsCorporationIdShareholders200Ok.ShareholderTypeEnum": GetCorporationsCorporationIdShareholders200Ok.ShareholderTypeEnum,
        "GetCorporationsCorporationIdStandings200Ok.FromTypeEnum": GetCorporationsCorporationIdStandings200Ok.FromTypeEnum,
        "GetCorporationsCorporationIdStarbases200Ok.StateEnum": GetCorporationsCorporationIdStarbases200Ok.StateEnum,
        "GetCorporationsCorporationIdStarbasesStarbaseIdOk.AnchorEnum": GetCorporationsCorporationIdStarbasesStarbaseIdOk.AnchorEnum,
        "GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayTakeEnum": GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayTakeEnum,
        "GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayViewEnum": GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayViewEnum,
        "GetCorporationsCorporationIdStarbasesStarbaseIdOk.OfflineEnum": GetCorporationsCorporationIdStarbasesStarbaseIdOk.OfflineEnum,
        "GetCorporationsCorporationIdStarbasesStarbaseIdOk.OnlineEnum": GetCorporationsCorporationIdStarbasesStarbaseIdOk.OnlineEnum,
        "GetCorporationsCorporationIdStarbasesStarbaseIdOk.UnanchorEnum": GetCorporationsCorporationIdStarbasesStarbaseIdOk.UnanchorEnum,
        "GetCorporationsCorporationIdStructures200Ok.StateEnum": GetCorporationsCorporationIdStructures200Ok.StateEnum,
        "GetCorporationsCorporationIdStructuresService.StateEnum": GetCorporationsCorporationIdStructuresService.StateEnum,
        "GetCorporationsCorporationIdTitles200Ok.GrantableRolesEnum": GetCorporationsCorporationIdTitles200Ok.GrantableRolesEnum,
        "GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtBaseEnum": GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtBaseEnum,
        "GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtHqEnum": GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtHqEnum,
        "GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtOtherEnum": GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtOtherEnum,
        "GetCorporationsCorporationIdTitles200Ok.RolesEnum": GetCorporationsCorporationIdTitles200Ok.RolesEnum,
        "GetCorporationsCorporationIdTitles200Ok.RolesAtBaseEnum": GetCorporationsCorporationIdTitles200Ok.RolesAtBaseEnum,
        "GetCorporationsCorporationIdTitles200Ok.RolesAtHqEnum": GetCorporationsCorporationIdTitles200Ok.RolesAtHqEnum,
        "GetCorporationsCorporationIdTitles200Ok.RolesAtOtherEnum": GetCorporationsCorporationIdTitles200Ok.RolesAtOtherEnum,
        "GetCorporationsCorporationIdWalletsDivisionJournal200Ok.ContextIdTypeEnum": GetCorporationsCorporationIdWalletsDivisionJournal200Ok.ContextIdTypeEnum,
        "GetCorporationsCorporationIdWalletsDivisionJournal200Ok.RefTypeEnum": GetCorporationsCorporationIdWalletsDivisionJournal200Ok.RefTypeEnum,
        "GetFleetsFleetIdMembers200Ok.RoleEnum": GetFleetsFleetIdMembers200Ok.RoleEnum,
        "GetFwSystems200Ok.ContestedEnum": GetFwSystems200Ok.ContestedEnum,
        "GetIncursions200Ok.StateEnum": GetIncursions200Ok.StateEnum,
        "GetIndustrySystemsCostIndice.ActivityEnum": GetIndustrySystemsCostIndice.ActivityEnum,
        "GetMarketsRegionIdOrders200Ok.RangeEnum": GetMarketsRegionIdOrders200Ok.RangeEnum,
        "GetMarketsStructuresStructureId200Ok.RangeEnum": GetMarketsStructuresStructureId200Ok.RangeEnum,
        "GetSovereigntyCampaigns200Ok.EventTypeEnum": GetSovereigntyCampaigns200Ok.EventTypeEnum,
        "GetUniverseStarsStarIdOk.SpectralClassEnum": GetUniverseStarsStarIdOk.SpectralClassEnum,
        "GetUniverseStationsStationIdOk.ServicesEnum": GetUniverseStationsStationIdOk.ServicesEnum,
        "PostCharactersCharacterIdFittingsItem.FlagEnum": PostCharactersCharacterIdFittingsItem.FlagEnum,
        "PostCharactersCharacterIdMailLabelsLabel.ColorEnum": PostCharactersCharacterIdMailLabelsLabel.ColorEnum,
        "PostCharactersCharacterIdMailRecipient.RecipientTypeEnum": PostCharactersCharacterIdMailRecipient.RecipientTypeEnum,
        "PostFleetsFleetIdMembersInvitation.RoleEnum": PostFleetsFleetIdMembersInvitation.RoleEnum,
        "PostUniverseNames200Ok.CategoryEnum": PostUniverseNames200Ok.CategoryEnum,
        "PutCharactersCharacterIdCalendarEventIdResponse.ResponseEnum": PutCharactersCharacterIdCalendarEventIdResponse.ResponseEnum,
        "PutFleetsFleetIdMembersMemberIdMovement.RoleEnum": PutFleetsFleetIdMembersMemberIdMovement.RoleEnum,
}

let typeMap: {[index: string]: any} = {
    "BadRequest": BadRequest,
    "DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity": DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity,
    "DeleteFleetsFleetIdMembersMemberIdNotFound": DeleteFleetsFleetIdMembersMemberIdNotFound,
    "DeleteFleetsFleetIdSquadsSquadIdNotFound": DeleteFleetsFleetIdSquadsSquadIdNotFound,
    "DeleteFleetsFleetIdWingsWingIdNotFound": DeleteFleetsFleetIdWingsWingIdNotFound,
    "ErrorLimited": ErrorLimited,
    "Forbidden": Forbidden,
    "GatewayTimeout": GatewayTimeout,
    "GetAlliancesAllianceIdContacts200Ok": GetAlliancesAllianceIdContacts200Ok,
    "GetAlliancesAllianceIdContactsLabels200Ok": GetAlliancesAllianceIdContactsLabels200Ok,
    "GetAlliancesAllianceIdIconsNotFound": GetAlliancesAllianceIdIconsNotFound,
    "GetAlliancesAllianceIdIconsOk": GetAlliancesAllianceIdIconsOk,
    "GetAlliancesAllianceIdNotFound": GetAlliancesAllianceIdNotFound,
    "GetAlliancesAllianceIdOk": GetAlliancesAllianceIdOk,
    "GetCharactersCharacterIdAgentsResearch200Ok": GetCharactersCharacterIdAgentsResearch200Ok,
    "GetCharactersCharacterIdAssets200Ok": GetCharactersCharacterIdAssets200Ok,
    "GetCharactersCharacterIdAttributesOk": GetCharactersCharacterIdAttributesOk,
    "GetCharactersCharacterIdBlueprints200Ok": GetCharactersCharacterIdBlueprints200Ok,
    "GetCharactersCharacterIdBookmarks200Ok": GetCharactersCharacterIdBookmarks200Ok,
    "GetCharactersCharacterIdBookmarksCoordinates": GetCharactersCharacterIdBookmarksCoordinates,
    "GetCharactersCharacterIdBookmarksFolders200Ok": GetCharactersCharacterIdBookmarksFolders200Ok,
    "GetCharactersCharacterIdBookmarksItem": GetCharactersCharacterIdBookmarksItem,
    "GetCharactersCharacterIdCalendar200Ok": GetCharactersCharacterIdCalendar200Ok,
    "GetCharactersCharacterIdCalendarEventIdAttendees200Ok": GetCharactersCharacterIdCalendarEventIdAttendees200Ok,
    "GetCharactersCharacterIdCalendarEventIdAttendeesNotFound": GetCharactersCharacterIdCalendarEventIdAttendeesNotFound,
    "GetCharactersCharacterIdCalendarEventIdNotFound": GetCharactersCharacterIdCalendarEventIdNotFound,
    "GetCharactersCharacterIdCalendarEventIdOk": GetCharactersCharacterIdCalendarEventIdOk,
    "GetCharactersCharacterIdClonesHomeLocation": GetCharactersCharacterIdClonesHomeLocation,
    "GetCharactersCharacterIdClonesJumpClone": GetCharactersCharacterIdClonesJumpClone,
    "GetCharactersCharacterIdClonesOk": GetCharactersCharacterIdClonesOk,
    "GetCharactersCharacterIdContacts200Ok": GetCharactersCharacterIdContacts200Ok,
    "GetCharactersCharacterIdContactsLabels200Ok": GetCharactersCharacterIdContactsLabels200Ok,
    "GetCharactersCharacterIdContracts200Ok": GetCharactersCharacterIdContracts200Ok,
    "GetCharactersCharacterIdContractsContractIdBids200Ok": GetCharactersCharacterIdContractsContractIdBids200Ok,
    "GetCharactersCharacterIdContractsContractIdBidsNotFound": GetCharactersCharacterIdContractsContractIdBidsNotFound,
    "GetCharactersCharacterIdContractsContractIdItems200Ok": GetCharactersCharacterIdContractsContractIdItems200Ok,
    "GetCharactersCharacterIdContractsContractIdItemsNotFound": GetCharactersCharacterIdContractsContractIdItemsNotFound,
    "GetCharactersCharacterIdCorporationhistory200Ok": GetCharactersCharacterIdCorporationhistory200Ok,
    "GetCharactersCharacterIdFatigueOk": GetCharactersCharacterIdFatigueOk,
    "GetCharactersCharacterIdFittings200Ok": GetCharactersCharacterIdFittings200Ok,
    "GetCharactersCharacterIdFittingsItem": GetCharactersCharacterIdFittingsItem,
    "GetCharactersCharacterIdFleetNotFound": GetCharactersCharacterIdFleetNotFound,
    "GetCharactersCharacterIdFleetOk": GetCharactersCharacterIdFleetOk,
    "GetCharactersCharacterIdFwStatsKills": GetCharactersCharacterIdFwStatsKills,
    "GetCharactersCharacterIdFwStatsOk": GetCharactersCharacterIdFwStatsOk,
    "GetCharactersCharacterIdFwStatsVictoryPoints": GetCharactersCharacterIdFwStatsVictoryPoints,
    "GetCharactersCharacterIdIndustryJobs200Ok": GetCharactersCharacterIdIndustryJobs200Ok,
    "GetCharactersCharacterIdKillmailsRecent200Ok": GetCharactersCharacterIdKillmailsRecent200Ok,
    "GetCharactersCharacterIdLocationOk": GetCharactersCharacterIdLocationOk,
    "GetCharactersCharacterIdLoyaltyPoints200Ok": GetCharactersCharacterIdLoyaltyPoints200Ok,
    "GetCharactersCharacterIdMail200Ok": GetCharactersCharacterIdMail200Ok,
    "GetCharactersCharacterIdMailLabelsLabel": GetCharactersCharacterIdMailLabelsLabel,
    "GetCharactersCharacterIdMailLabelsOk": GetCharactersCharacterIdMailLabelsOk,
    "GetCharactersCharacterIdMailLists200Ok": GetCharactersCharacterIdMailLists200Ok,
    "GetCharactersCharacterIdMailMailIdNotFound": GetCharactersCharacterIdMailMailIdNotFound,
    "GetCharactersCharacterIdMailMailIdOk": GetCharactersCharacterIdMailMailIdOk,
    "GetCharactersCharacterIdMailMailIdRecipient": GetCharactersCharacterIdMailMailIdRecipient,
    "GetCharactersCharacterIdMailRecipient": GetCharactersCharacterIdMailRecipient,
    "GetCharactersCharacterIdMedals200Ok": GetCharactersCharacterIdMedals200Ok,
    "GetCharactersCharacterIdMedalsGraphic": GetCharactersCharacterIdMedalsGraphic,
    "GetCharactersCharacterIdMining200Ok": GetCharactersCharacterIdMining200Ok,
    "GetCharactersCharacterIdNotFound": GetCharactersCharacterIdNotFound,
    "GetCharactersCharacterIdNotifications200Ok": GetCharactersCharacterIdNotifications200Ok,
    "GetCharactersCharacterIdNotificationsContacts200Ok": GetCharactersCharacterIdNotificationsContacts200Ok,
    "GetCharactersCharacterIdOk": GetCharactersCharacterIdOk,
    "GetCharactersCharacterIdOnlineOk": GetCharactersCharacterIdOnlineOk,
    "GetCharactersCharacterIdOpportunities200Ok": GetCharactersCharacterIdOpportunities200Ok,
    "GetCharactersCharacterIdOrders200Ok": GetCharactersCharacterIdOrders200Ok,
    "GetCharactersCharacterIdOrdersHistory200Ok": GetCharactersCharacterIdOrdersHistory200Ok,
    "GetCharactersCharacterIdPlanets200Ok": GetCharactersCharacterIdPlanets200Ok,
    "GetCharactersCharacterIdPlanetsPlanetIdContent": GetCharactersCharacterIdPlanetsPlanetIdContent,
    "GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails": GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails,
    "GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails": GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails,
    "GetCharactersCharacterIdPlanetsPlanetIdHead": GetCharactersCharacterIdPlanetsPlanetIdHead,
    "GetCharactersCharacterIdPlanetsPlanetIdLink": GetCharactersCharacterIdPlanetsPlanetIdLink,
    "GetCharactersCharacterIdPlanetsPlanetIdNotFound": GetCharactersCharacterIdPlanetsPlanetIdNotFound,
    "GetCharactersCharacterIdPlanetsPlanetIdOk": GetCharactersCharacterIdPlanetsPlanetIdOk,
    "GetCharactersCharacterIdPlanetsPlanetIdPin": GetCharactersCharacterIdPlanetsPlanetIdPin,
    "GetCharactersCharacterIdPlanetsPlanetIdRoute": GetCharactersCharacterIdPlanetsPlanetIdRoute,
    "GetCharactersCharacterIdPortraitNotFound": GetCharactersCharacterIdPortraitNotFound,
    "GetCharactersCharacterIdPortraitOk": GetCharactersCharacterIdPortraitOk,
    "GetCharactersCharacterIdRolesOk": GetCharactersCharacterIdRolesOk,
    "GetCharactersCharacterIdSearchOk": GetCharactersCharacterIdSearchOk,
    "GetCharactersCharacterIdShipOk": GetCharactersCharacterIdShipOk,
    "GetCharactersCharacterIdSkillqueue200Ok": GetCharactersCharacterIdSkillqueue200Ok,
    "GetCharactersCharacterIdSkillsOk": GetCharactersCharacterIdSkillsOk,
    "GetCharactersCharacterIdSkillsSkill": GetCharactersCharacterIdSkillsSkill,
    "GetCharactersCharacterIdStandings200Ok": GetCharactersCharacterIdStandings200Ok,
    "GetCharactersCharacterIdStats200Ok": GetCharactersCharacterIdStats200Ok,
    "GetCharactersCharacterIdStatsCharacter": GetCharactersCharacterIdStatsCharacter,
    "GetCharactersCharacterIdStatsCombat": GetCharactersCharacterIdStatsCombat,
    "GetCharactersCharacterIdStatsIndustry": GetCharactersCharacterIdStatsIndustry,
    "GetCharactersCharacterIdStatsInventory": GetCharactersCharacterIdStatsInventory,
    "GetCharactersCharacterIdStatsIsk": GetCharactersCharacterIdStatsIsk,
    "GetCharactersCharacterIdStatsMarket": GetCharactersCharacterIdStatsMarket,
    "GetCharactersCharacterIdStatsMining": GetCharactersCharacterIdStatsMining,
    "GetCharactersCharacterIdStatsModule": GetCharactersCharacterIdStatsModule,
    "GetCharactersCharacterIdStatsOrbital": GetCharactersCharacterIdStatsOrbital,
    "GetCharactersCharacterIdStatsPve": GetCharactersCharacterIdStatsPve,
    "GetCharactersCharacterIdStatsSocial": GetCharactersCharacterIdStatsSocial,
    "GetCharactersCharacterIdStatsTravel": GetCharactersCharacterIdStatsTravel,
    "GetCharactersCharacterIdTitles200Ok": GetCharactersCharacterIdTitles200Ok,
    "GetCharactersCharacterIdWalletJournal200Ok": GetCharactersCharacterIdWalletJournal200Ok,
    "GetCharactersCharacterIdWalletTransactions200Ok": GetCharactersCharacterIdWalletTransactions200Ok,
    "GetContractsPublicBidsContractId200Ok": GetContractsPublicBidsContractId200Ok,
    "GetContractsPublicBidsContractIdForbidden": GetContractsPublicBidsContractIdForbidden,
    "GetContractsPublicBidsContractIdNotFound": GetContractsPublicBidsContractIdNotFound,
    "GetContractsPublicItemsContractId200Ok": GetContractsPublicItemsContractId200Ok,
    "GetContractsPublicItemsContractIdForbidden": GetContractsPublicItemsContractIdForbidden,
    "GetContractsPublicItemsContractIdNotFound": GetContractsPublicItemsContractIdNotFound,
    "GetContractsPublicRegionId200Ok": GetContractsPublicRegionId200Ok,
    "GetContractsPublicRegionIdNotFound": GetContractsPublicRegionIdNotFound,
    "GetCorporationCorporationIdMiningExtractions200Ok": GetCorporationCorporationIdMiningExtractions200Ok,
    "GetCorporationCorporationIdMiningObservers200Ok": GetCorporationCorporationIdMiningObservers200Ok,
    "GetCorporationCorporationIdMiningObserversObserverId200Ok": GetCorporationCorporationIdMiningObserversObserverId200Ok,
    "GetCorporationsCorporationIdAlliancehistory200Ok": GetCorporationsCorporationIdAlliancehistory200Ok,
    "GetCorporationsCorporationIdAssets200Ok": GetCorporationsCorporationIdAssets200Ok,
    "GetCorporationsCorporationIdBlueprints200Ok": GetCorporationsCorporationIdBlueprints200Ok,
    "GetCorporationsCorporationIdBookmarks200Ok": GetCorporationsCorporationIdBookmarks200Ok,
    "GetCorporationsCorporationIdBookmarksCoordinates": GetCorporationsCorporationIdBookmarksCoordinates,
    "GetCorporationsCorporationIdBookmarksFolders200Ok": GetCorporationsCorporationIdBookmarksFolders200Ok,
    "GetCorporationsCorporationIdBookmarksItem": GetCorporationsCorporationIdBookmarksItem,
    "GetCorporationsCorporationIdContacts200Ok": GetCorporationsCorporationIdContacts200Ok,
    "GetCorporationsCorporationIdContactsLabels200Ok": GetCorporationsCorporationIdContactsLabels200Ok,
    "GetCorporationsCorporationIdContainersLogs200Ok": GetCorporationsCorporationIdContainersLogs200Ok,
    "GetCorporationsCorporationIdContracts200Ok": GetCorporationsCorporationIdContracts200Ok,
    "GetCorporationsCorporationIdContractsContractIdBids200Ok": GetCorporationsCorporationIdContractsContractIdBids200Ok,
    "GetCorporationsCorporationIdContractsContractIdBidsNotFound": GetCorporationsCorporationIdContractsContractIdBidsNotFound,
    "GetCorporationsCorporationIdContractsContractIdItems200Ok": GetCorporationsCorporationIdContractsContractIdItems200Ok,
    "GetCorporationsCorporationIdContractsContractIdItemsError520": GetCorporationsCorporationIdContractsContractIdItemsError520,
    "GetCorporationsCorporationIdContractsContractIdItemsNotFound": GetCorporationsCorporationIdContractsContractIdItemsNotFound,
    "GetCorporationsCorporationIdCustomsOffices200Ok": GetCorporationsCorporationIdCustomsOffices200Ok,
    "GetCorporationsCorporationIdDivisionsHangarHangar": GetCorporationsCorporationIdDivisionsHangarHangar,
    "GetCorporationsCorporationIdDivisionsOk": GetCorporationsCorporationIdDivisionsOk,
    "GetCorporationsCorporationIdDivisionsWalletWallet": GetCorporationsCorporationIdDivisionsWalletWallet,
    "GetCorporationsCorporationIdFacilities200Ok": GetCorporationsCorporationIdFacilities200Ok,
    "GetCorporationsCorporationIdFwStatsKills": GetCorporationsCorporationIdFwStatsKills,
    "GetCorporationsCorporationIdFwStatsOk": GetCorporationsCorporationIdFwStatsOk,
    "GetCorporationsCorporationIdFwStatsVictoryPoints": GetCorporationsCorporationIdFwStatsVictoryPoints,
    "GetCorporationsCorporationIdIconsNotFound": GetCorporationsCorporationIdIconsNotFound,
    "GetCorporationsCorporationIdIconsOk": GetCorporationsCorporationIdIconsOk,
    "GetCorporationsCorporationIdIndustryJobs200Ok": GetCorporationsCorporationIdIndustryJobs200Ok,
    "GetCorporationsCorporationIdKillmailsRecent200Ok": GetCorporationsCorporationIdKillmailsRecent200Ok,
    "GetCorporationsCorporationIdMedals200Ok": GetCorporationsCorporationIdMedals200Ok,
    "GetCorporationsCorporationIdMedalsIssued200Ok": GetCorporationsCorporationIdMedalsIssued200Ok,
    "GetCorporationsCorporationIdMembersTitles200Ok": GetCorporationsCorporationIdMembersTitles200Ok,
    "GetCorporationsCorporationIdMembertracking200Ok": GetCorporationsCorporationIdMembertracking200Ok,
    "GetCorporationsCorporationIdNotFound": GetCorporationsCorporationIdNotFound,
    "GetCorporationsCorporationIdOk": GetCorporationsCorporationIdOk,
    "GetCorporationsCorporationIdOrders200Ok": GetCorporationsCorporationIdOrders200Ok,
    "GetCorporationsCorporationIdOrdersHistory200Ok": GetCorporationsCorporationIdOrdersHistory200Ok,
    "GetCorporationsCorporationIdRoles200Ok": GetCorporationsCorporationIdRoles200Ok,
    "GetCorporationsCorporationIdRolesHistory200Ok": GetCorporationsCorporationIdRolesHistory200Ok,
    "GetCorporationsCorporationIdShareholders200Ok": GetCorporationsCorporationIdShareholders200Ok,
    "GetCorporationsCorporationIdStandings200Ok": GetCorporationsCorporationIdStandings200Ok,
    "GetCorporationsCorporationIdStarbases200Ok": GetCorporationsCorporationIdStarbases200Ok,
    "GetCorporationsCorporationIdStarbasesStarbaseIdFuel": GetCorporationsCorporationIdStarbasesStarbaseIdFuel,
    "GetCorporationsCorporationIdStarbasesStarbaseIdOk": GetCorporationsCorporationIdStarbasesStarbaseIdOk,
    "GetCorporationsCorporationIdStructures200Ok": GetCorporationsCorporationIdStructures200Ok,
    "GetCorporationsCorporationIdStructuresService": GetCorporationsCorporationIdStructuresService,
    "GetCorporationsCorporationIdTitles200Ok": GetCorporationsCorporationIdTitles200Ok,
    "GetCorporationsCorporationIdWallets200Ok": GetCorporationsCorporationIdWallets200Ok,
    "GetCorporationsCorporationIdWalletsDivisionJournal200Ok": GetCorporationsCorporationIdWalletsDivisionJournal200Ok,
    "GetCorporationsCorporationIdWalletsDivisionTransactions200Ok": GetCorporationsCorporationIdWalletsDivisionTransactions200Ok,
    "GetDogmaAttributesAttributeIdNotFound": GetDogmaAttributesAttributeIdNotFound,
    "GetDogmaAttributesAttributeIdOk": GetDogmaAttributesAttributeIdOk,
    "GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute": GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute,
    "GetDogmaDynamicItemsTypeIdItemIdDogmaEffect": GetDogmaDynamicItemsTypeIdItemIdDogmaEffect,
    "GetDogmaDynamicItemsTypeIdItemIdNotFound": GetDogmaDynamicItemsTypeIdItemIdNotFound,
    "GetDogmaDynamicItemsTypeIdItemIdOk": GetDogmaDynamicItemsTypeIdItemIdOk,
    "GetDogmaEffectsEffectIdModifier": GetDogmaEffectsEffectIdModifier,
    "GetDogmaEffectsEffectIdNotFound": GetDogmaEffectsEffectIdNotFound,
    "GetDogmaEffectsEffectIdOk": GetDogmaEffectsEffectIdOk,
    "GetFleetsFleetIdMembers200Ok": GetFleetsFleetIdMembers200Ok,
    "GetFleetsFleetIdMembersNotFound": GetFleetsFleetIdMembersNotFound,
    "GetFleetsFleetIdNotFound": GetFleetsFleetIdNotFound,
    "GetFleetsFleetIdOk": GetFleetsFleetIdOk,
    "GetFleetsFleetIdWings200Ok": GetFleetsFleetIdWings200Ok,
    "GetFleetsFleetIdWingsNotFound": GetFleetsFleetIdWingsNotFound,
    "GetFleetsFleetIdWingsSquad": GetFleetsFleetIdWingsSquad,
    "GetFwLeaderboardsActiveTotalActiveTotal": GetFwLeaderboardsActiveTotalActiveTotal,
    "GetFwLeaderboardsActiveTotalActiveTotal1": GetFwLeaderboardsActiveTotalActiveTotal1,
    "GetFwLeaderboardsCharactersActiveTotalActiveTotal": GetFwLeaderboardsCharactersActiveTotalActiveTotal,
    "GetFwLeaderboardsCharactersActiveTotalActiveTotal1": GetFwLeaderboardsCharactersActiveTotalActiveTotal1,
    "GetFwLeaderboardsCharactersKills": GetFwLeaderboardsCharactersKills,
    "GetFwLeaderboardsCharactersLastWeekLastWeek": GetFwLeaderboardsCharactersLastWeekLastWeek,
    "GetFwLeaderboardsCharactersLastWeekLastWeek1": GetFwLeaderboardsCharactersLastWeekLastWeek1,
    "GetFwLeaderboardsCharactersOk": GetFwLeaderboardsCharactersOk,
    "GetFwLeaderboardsCharactersVictoryPoints": GetFwLeaderboardsCharactersVictoryPoints,
    "GetFwLeaderboardsCharactersYesterdayYesterday": GetFwLeaderboardsCharactersYesterdayYesterday,
    "GetFwLeaderboardsCharactersYesterdayYesterday1": GetFwLeaderboardsCharactersYesterdayYesterday1,
    "GetFwLeaderboardsCorporationsActiveTotalActiveTotal": GetFwLeaderboardsCorporationsActiveTotalActiveTotal,
    "GetFwLeaderboardsCorporationsActiveTotalActiveTotal1": GetFwLeaderboardsCorporationsActiveTotalActiveTotal1,
    "GetFwLeaderboardsCorporationsKills": GetFwLeaderboardsCorporationsKills,
    "GetFwLeaderboardsCorporationsLastWeekLastWeek": GetFwLeaderboardsCorporationsLastWeekLastWeek,
    "GetFwLeaderboardsCorporationsLastWeekLastWeek1": GetFwLeaderboardsCorporationsLastWeekLastWeek1,
    "GetFwLeaderboardsCorporationsOk": GetFwLeaderboardsCorporationsOk,
    "GetFwLeaderboardsCorporationsVictoryPoints": GetFwLeaderboardsCorporationsVictoryPoints,
    "GetFwLeaderboardsCorporationsYesterdayYesterday": GetFwLeaderboardsCorporationsYesterdayYesterday,
    "GetFwLeaderboardsCorporationsYesterdayYesterday1": GetFwLeaderboardsCorporationsYesterdayYesterday1,
    "GetFwLeaderboardsKills": GetFwLeaderboardsKills,
    "GetFwLeaderboardsLastWeekLastWeek": GetFwLeaderboardsLastWeekLastWeek,
    "GetFwLeaderboardsLastWeekLastWeek1": GetFwLeaderboardsLastWeekLastWeek1,
    "GetFwLeaderboardsOk": GetFwLeaderboardsOk,
    "GetFwLeaderboardsVictoryPoints": GetFwLeaderboardsVictoryPoints,
    "GetFwLeaderboardsYesterdayYesterday": GetFwLeaderboardsYesterdayYesterday,
    "GetFwLeaderboardsYesterdayYesterday1": GetFwLeaderboardsYesterdayYesterday1,
    "GetFwStats200Ok": GetFwStats200Ok,
    "GetFwStatsKills": GetFwStatsKills,
    "GetFwStatsVictoryPoints": GetFwStatsVictoryPoints,
    "GetFwSystems200Ok": GetFwSystems200Ok,
    "GetFwWars200Ok": GetFwWars200Ok,
    "GetIncursions200Ok": GetIncursions200Ok,
    "GetIndustryFacilities200Ok": GetIndustryFacilities200Ok,
    "GetIndustrySystems200Ok": GetIndustrySystems200Ok,
    "GetIndustrySystemsCostIndice": GetIndustrySystemsCostIndice,
    "GetInsurancePrices200Ok": GetInsurancePrices200Ok,
    "GetInsurancePricesLevel": GetInsurancePricesLevel,
    "GetKillmailsKillmailIdKillmailHashAttacker": GetKillmailsKillmailIdKillmailHashAttacker,
    "GetKillmailsKillmailIdKillmailHashItem": GetKillmailsKillmailIdKillmailHashItem,
    "GetKillmailsKillmailIdKillmailHashItemsItem": GetKillmailsKillmailIdKillmailHashItemsItem,
    "GetKillmailsKillmailIdKillmailHashOk": GetKillmailsKillmailIdKillmailHashOk,
    "GetKillmailsKillmailIdKillmailHashPosition": GetKillmailsKillmailIdKillmailHashPosition,
    "GetKillmailsKillmailIdKillmailHashUnprocessableEntity": GetKillmailsKillmailIdKillmailHashUnprocessableEntity,
    "GetKillmailsKillmailIdKillmailHashVictim": GetKillmailsKillmailIdKillmailHashVictim,
    "GetLoyaltyStoresCorporationIdOffers200Ok": GetLoyaltyStoresCorporationIdOffers200Ok,
    "GetLoyaltyStoresCorporationIdOffersNotFound": GetLoyaltyStoresCorporationIdOffersNotFound,
    "GetLoyaltyStoresCorporationIdOffersRequiredItem": GetLoyaltyStoresCorporationIdOffersRequiredItem,
    "GetMarketsGroupsMarketGroupIdNotFound": GetMarketsGroupsMarketGroupIdNotFound,
    "GetMarketsGroupsMarketGroupIdOk": GetMarketsGroupsMarketGroupIdOk,
    "GetMarketsPrices200Ok": GetMarketsPrices200Ok,
    "GetMarketsRegionIdHistory200Ok": GetMarketsRegionIdHistory200Ok,
    "GetMarketsRegionIdHistoryError520": GetMarketsRegionIdHistoryError520,
    "GetMarketsRegionIdHistoryNotFound": GetMarketsRegionIdHistoryNotFound,
    "GetMarketsRegionIdHistoryUnprocessableEntity": GetMarketsRegionIdHistoryUnprocessableEntity,
    "GetMarketsRegionIdOrders200Ok": GetMarketsRegionIdOrders200Ok,
    "GetMarketsRegionIdOrdersNotFound": GetMarketsRegionIdOrdersNotFound,
    "GetMarketsRegionIdOrdersUnprocessableEntity": GetMarketsRegionIdOrdersUnprocessableEntity,
    "GetMarketsStructuresStructureId200Ok": GetMarketsStructuresStructureId200Ok,
    "GetOpportunitiesGroupsGroupIdOk": GetOpportunitiesGroupsGroupIdOk,
    "GetOpportunitiesTasksTaskIdOk": GetOpportunitiesTasksTaskIdOk,
    "GetRouteOriginDestinationNotFound": GetRouteOriginDestinationNotFound,
    "GetSearchOk": GetSearchOk,
    "GetSovereigntyCampaigns200Ok": GetSovereigntyCampaigns200Ok,
    "GetSovereigntyCampaignsParticipant": GetSovereigntyCampaignsParticipant,
    "GetSovereigntyMap200Ok": GetSovereigntyMap200Ok,
    "GetSovereigntyStructures200Ok": GetSovereigntyStructures200Ok,
    "GetStatusOk": GetStatusOk,
    "GetUniverseAncestries200Ok": GetUniverseAncestries200Ok,
    "GetUniverseAsteroidBeltsAsteroidBeltIdNotFound": GetUniverseAsteroidBeltsAsteroidBeltIdNotFound,
    "GetUniverseAsteroidBeltsAsteroidBeltIdOk": GetUniverseAsteroidBeltsAsteroidBeltIdOk,
    "GetUniverseAsteroidBeltsAsteroidBeltIdPosition": GetUniverseAsteroidBeltsAsteroidBeltIdPosition,
    "GetUniverseBloodlines200Ok": GetUniverseBloodlines200Ok,
    "GetUniverseCategoriesCategoryIdNotFound": GetUniverseCategoriesCategoryIdNotFound,
    "GetUniverseCategoriesCategoryIdOk": GetUniverseCategoriesCategoryIdOk,
    "GetUniverseConstellationsConstellationIdNotFound": GetUniverseConstellationsConstellationIdNotFound,
    "GetUniverseConstellationsConstellationIdOk": GetUniverseConstellationsConstellationIdOk,
    "GetUniverseConstellationsConstellationIdPosition": GetUniverseConstellationsConstellationIdPosition,
    "GetUniverseFactions200Ok": GetUniverseFactions200Ok,
    "GetUniverseGraphicsGraphicIdNotFound": GetUniverseGraphicsGraphicIdNotFound,
    "GetUniverseGraphicsGraphicIdOk": GetUniverseGraphicsGraphicIdOk,
    "GetUniverseGroupsGroupIdNotFound": GetUniverseGroupsGroupIdNotFound,
    "GetUniverseGroupsGroupIdOk": GetUniverseGroupsGroupIdOk,
    "GetUniverseMoonsMoonIdNotFound": GetUniverseMoonsMoonIdNotFound,
    "GetUniverseMoonsMoonIdOk": GetUniverseMoonsMoonIdOk,
    "GetUniverseMoonsMoonIdPosition": GetUniverseMoonsMoonIdPosition,
    "GetUniversePlanetsPlanetIdNotFound": GetUniversePlanetsPlanetIdNotFound,
    "GetUniversePlanetsPlanetIdOk": GetUniversePlanetsPlanetIdOk,
    "GetUniversePlanetsPlanetIdPosition": GetUniversePlanetsPlanetIdPosition,
    "GetUniverseRaces200Ok": GetUniverseRaces200Ok,
    "GetUniverseRegionsRegionIdNotFound": GetUniverseRegionsRegionIdNotFound,
    "GetUniverseRegionsRegionIdOk": GetUniverseRegionsRegionIdOk,
    "GetUniverseSchematicsSchematicIdNotFound": GetUniverseSchematicsSchematicIdNotFound,
    "GetUniverseSchematicsSchematicIdOk": GetUniverseSchematicsSchematicIdOk,
    "GetUniverseStargatesStargateIdDestination": GetUniverseStargatesStargateIdDestination,
    "GetUniverseStargatesStargateIdNotFound": GetUniverseStargatesStargateIdNotFound,
    "GetUniverseStargatesStargateIdOk": GetUniverseStargatesStargateIdOk,
    "GetUniverseStargatesStargateIdPosition": GetUniverseStargatesStargateIdPosition,
    "GetUniverseStarsStarIdOk": GetUniverseStarsStarIdOk,
    "GetUniverseStationsStationIdNotFound": GetUniverseStationsStationIdNotFound,
    "GetUniverseStationsStationIdOk": GetUniverseStationsStationIdOk,
    "GetUniverseStationsStationIdPosition": GetUniverseStationsStationIdPosition,
    "GetUniverseStructuresStructureIdNotFound": GetUniverseStructuresStructureIdNotFound,
    "GetUniverseStructuresStructureIdOk": GetUniverseStructuresStructureIdOk,
    "GetUniverseStructuresStructureIdPosition": GetUniverseStructuresStructureIdPosition,
    "GetUniverseSystemJumps200Ok": GetUniverseSystemJumps200Ok,
    "GetUniverseSystemKills200Ok": GetUniverseSystemKills200Ok,
    "GetUniverseSystemsSystemIdNotFound": GetUniverseSystemsSystemIdNotFound,
    "GetUniverseSystemsSystemIdOk": GetUniverseSystemsSystemIdOk,
    "GetUniverseSystemsSystemIdPlanet": GetUniverseSystemsSystemIdPlanet,
    "GetUniverseSystemsSystemIdPosition": GetUniverseSystemsSystemIdPosition,
    "GetUniverseTypesTypeIdDogmaAttribute": GetUniverseTypesTypeIdDogmaAttribute,
    "GetUniverseTypesTypeIdDogmaEffect": GetUniverseTypesTypeIdDogmaEffect,
    "GetUniverseTypesTypeIdNotFound": GetUniverseTypesTypeIdNotFound,
    "GetUniverseTypesTypeIdOk": GetUniverseTypesTypeIdOk,
    "GetWarsWarIdAggressor": GetWarsWarIdAggressor,
    "GetWarsWarIdAlly": GetWarsWarIdAlly,
    "GetWarsWarIdDefender": GetWarsWarIdDefender,
    "GetWarsWarIdKillmails200Ok": GetWarsWarIdKillmails200Ok,
    "GetWarsWarIdKillmailsUnprocessableEntity": GetWarsWarIdKillmailsUnprocessableEntity,
    "GetWarsWarIdOk": GetWarsWarIdOk,
    "GetWarsWarIdUnprocessableEntity": GetWarsWarIdUnprocessableEntity,
    "InternalServerError": InternalServerError,
    "PostCharactersAffiliation200Ok": PostCharactersAffiliation200Ok,
    "PostCharactersAffiliationNotFound": PostCharactersAffiliationNotFound,
    "PostCharactersCharacterIdAssetsLocations200Ok": PostCharactersCharacterIdAssetsLocations200Ok,
    "PostCharactersCharacterIdAssetsLocationsPosition": PostCharactersCharacterIdAssetsLocationsPosition,
    "PostCharactersCharacterIdAssetsNames200Ok": PostCharactersCharacterIdAssetsNames200Ok,
    "PostCharactersCharacterIdContactsError520": PostCharactersCharacterIdContactsError520,
    "PostCharactersCharacterIdFittingsCreated": PostCharactersCharacterIdFittingsCreated,
    "PostCharactersCharacterIdFittingsFitting": PostCharactersCharacterIdFittingsFitting,
    "PostCharactersCharacterIdFittingsItem": PostCharactersCharacterIdFittingsItem,
    "PostCharactersCharacterIdMailError520": PostCharactersCharacterIdMailError520,
    "PostCharactersCharacterIdMailLabelsLabel": PostCharactersCharacterIdMailLabelsLabel,
    "PostCharactersCharacterIdMailMail": PostCharactersCharacterIdMailMail,
    "PostCharactersCharacterIdMailRecipient": PostCharactersCharacterIdMailRecipient,
    "PostCorporationsCorporationIdAssetsLocations200Ok": PostCorporationsCorporationIdAssetsLocations200Ok,
    "PostCorporationsCorporationIdAssetsLocationsNotFound": PostCorporationsCorporationIdAssetsLocationsNotFound,
    "PostCorporationsCorporationIdAssetsLocationsPosition": PostCorporationsCorporationIdAssetsLocationsPosition,
    "PostCorporationsCorporationIdAssetsNames200Ok": PostCorporationsCorporationIdAssetsNames200Ok,
    "PostCorporationsCorporationIdAssetsNamesNotFound": PostCorporationsCorporationIdAssetsNamesNotFound,
    "PostFleetsFleetIdMembersInvitation": PostFleetsFleetIdMembersInvitation,
    "PostFleetsFleetIdMembersNotFound": PostFleetsFleetIdMembersNotFound,
    "PostFleetsFleetIdMembersUnprocessableEntity": PostFleetsFleetIdMembersUnprocessableEntity,
    "PostFleetsFleetIdWingsCreated": PostFleetsFleetIdWingsCreated,
    "PostFleetsFleetIdWingsNotFound": PostFleetsFleetIdWingsNotFound,
    "PostFleetsFleetIdWingsWingIdSquadsCreated": PostFleetsFleetIdWingsWingIdSquadsCreated,
    "PostFleetsFleetIdWingsWingIdSquadsNotFound": PostFleetsFleetIdWingsWingIdSquadsNotFound,
    "PostUiOpenwindowNewmailNewMail": PostUiOpenwindowNewmailNewMail,
    "PostUiOpenwindowNewmailUnprocessableEntity": PostUiOpenwindowNewmailUnprocessableEntity,
    "PostUniverseIdsAgent": PostUniverseIdsAgent,
    "PostUniverseIdsAlliance": PostUniverseIdsAlliance,
    "PostUniverseIdsCharacter": PostUniverseIdsCharacter,
    "PostUniverseIdsConstellation": PostUniverseIdsConstellation,
    "PostUniverseIdsCorporation": PostUniverseIdsCorporation,
    "PostUniverseIdsFaction": PostUniverseIdsFaction,
    "PostUniverseIdsInventoryType": PostUniverseIdsInventoryType,
    "PostUniverseIdsOk": PostUniverseIdsOk,
    "PostUniverseIdsRegion": PostUniverseIdsRegion,
    "PostUniverseIdsStation": PostUniverseIdsStation,
    "PostUniverseIdsSystem": PostUniverseIdsSystem,
    "PostUniverseNames200Ok": PostUniverseNames200Ok,
    "PostUniverseNamesNotFound": PostUniverseNamesNotFound,
    "PutCharactersCharacterIdCalendarEventIdResponse": PutCharactersCharacterIdCalendarEventIdResponse,
    "PutCharactersCharacterIdMailMailIdContents": PutCharactersCharacterIdMailMailIdContents,
    "PutFleetsFleetIdMembersMemberIdMovement": PutFleetsFleetIdMembersMemberIdMovement,
    "PutFleetsFleetIdMembersMemberIdNotFound": PutFleetsFleetIdMembersMemberIdNotFound,
    "PutFleetsFleetIdMembersMemberIdUnprocessableEntity": PutFleetsFleetIdMembersMemberIdUnprocessableEntity,
    "PutFleetsFleetIdNewSettings": PutFleetsFleetIdNewSettings,
    "PutFleetsFleetIdNotFound": PutFleetsFleetIdNotFound,
    "PutFleetsFleetIdSquadsSquadIdNaming": PutFleetsFleetIdSquadsSquadIdNaming,
    "PutFleetsFleetIdSquadsSquadIdNotFound": PutFleetsFleetIdSquadsSquadIdNotFound,
    "PutFleetsFleetIdWingsWingIdNaming": PutFleetsFleetIdWingsWingIdNaming,
    "PutFleetsFleetIdWingsWingIdNotFound": PutFleetsFleetIdWingsWingIdNotFound,
    "ServiceUnavailable": ServiceUnavailable,
    "Unauthorized": Unauthorized,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AllianceApiApiKeys {
}

export class AllianceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AllianceApiApiKeys, value: string) {
        (this.authentications as any)[AllianceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
     * @summary List all alliances
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getAlliances (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/alliances/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance information
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getAlliancesAllianceId (allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdOk;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/'
            .replace('{' + 'alliance_id' + '}', encodeURIComponent(String(allianceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAlliancesAllianceIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
     * @summary List alliance's corporations
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getAlliancesAllianceIdCorporations (allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/corporations/'
            .replace('{' + 'alliance_id' + '}', encodeURIComponent(String(allianceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdCorporations.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
     * @summary Get alliance icon
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getAlliancesAllianceIdIcons (allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdIconsOk;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/icons/'
            .replace('{' + 'alliance_id' + '}', encodeURIComponent(String(allianceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdIcons.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdIconsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAlliancesAllianceIdIconsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AssetsApiApiKeys {
}

export class AssetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AssetsApiApiKeys, value: string) {
        (this.authentications as any)[AssetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
     * @summary Get character assets
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdAssets (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAssets200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/assets/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdAssets.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAssets200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdAssets200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation assets
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdAssets (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAssets200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/assets/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdAssets.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAssets200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdAssets200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
     * @summary Get character asset locations
     * @param characterId An EVE character ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCharactersCharacterIdAssetsLocations (characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsLocations200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/assets/locations/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdAssetsLocations.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCharactersCharacterIdAssetsLocations.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemIds, "Array<number>")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsLocations200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PostCharactersCharacterIdAssetsLocations200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
     * @summary Get character asset names
     * @param characterId An EVE character ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCharactersCharacterIdAssetsNames (characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsNames200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/assets/names/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdAssetsNames.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCharactersCharacterIdAssetsNames.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemIds, "Array<number>")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsNames200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PostCharactersCharacterIdAssetsNames200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation asset locations
     * @param corporationId An EVE corporation ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCorporationsCorporationIdAssetsLocations (corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsLocations200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/assets/locations/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling postCorporationsCorporationIdAssetsLocations.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCorporationsCorporationIdAssetsLocations.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemIds, "Array<number>")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsLocations200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PostCorporationsCorporationIdAssetsLocations200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation asset names
     * @param corporationId An EVE corporation ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCorporationsCorporationIdAssetsNames (corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsNames200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/assets/names/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling postCorporationsCorporationIdAssetsNames.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCorporationsCorporationIdAssetsNames.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemIds, "Array<number>")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsNames200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PostCorporationsCorporationIdAssetsNames200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BookmarksApiApiKeys {
}

export class BookmarksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BookmarksApiApiKeys, value: string) {
        (this.authentications as any)[BookmarksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * A list of your character's personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmarks
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdBookmarks (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarks200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/bookmarks/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarks.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarks200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdBookmarks200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A list of your character's personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmark folders
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdBookmarksFolders (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarksFolders200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/bookmarks/folders/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarksFolders.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarksFolders200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdBookmarksFolders200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A list of your corporation's bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmarks
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdBookmarks (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarks200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/bookmarks/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBookmarks.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarks200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdBookmarks200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A list of your corporation's bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmark folders
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdBookmarksFolders (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarksFolders200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/bookmarks/folders/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBookmarksFolders.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarksFolders200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdBookmarksFolders200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CalendarApiApiKeys {
}

export class CalendarApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CalendarApiApiKeys, value: string) {
        (this.authentications as any)[CalendarApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
     * @summary List calendar event summaries
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param fromEvent The event ID to retrieve events from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdCalendar (characterId: number, datasource?: 'tranquility', fromEvent?: number, ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendar200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendar.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (fromEvent !== undefined) {
            localVarQueryParameters['from_event'] = ObjectSerializer.serialize(fromEvent, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendar200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdCalendar200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get an event
     * @param characterId An EVE character ID
     * @param eventId The id of the event requested
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdCalendarEventId (characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdCalendarEventIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'event_id' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdCalendarEventIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdCalendarEventIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
     * @summary Get attendees
     * @param characterId An EVE character ID
     * @param eventId The id of the event requested
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdCalendarEventIdAttendees (characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/attendees/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'event_id' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendarEventIdAttendees.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getCharactersCharacterIdCalendarEventIdAttendees.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Respond to an event
     * @param characterId An EVE character ID
     * @param eventId The ID of the event requested
     * @param response The response value to set, overriding current value
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public putCharactersCharacterIdCalendarEventId (characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'event_id' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'response' is not null or undefined
        if (response === null || response === undefined) {
            throw new Error('Required parameter response was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(response, "PutCharactersCharacterIdCalendarEventIdResponse")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CharacterApiApiKeys {
}

export class CharacterApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CharacterApiApiKeys, value: string) {
        (this.authentications as any)[CharacterApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/v4/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
     * @summary Get character's public information
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterId (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/legacy/characters/{character_id}/agents_research/`  Alternate route: `/v1/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
     * @summary Get agents research
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdAgentsResearch (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAgentsResearch200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/agents_research/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdAgentsResearch.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAgentsResearch200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdAgentsResearch200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v2/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
     * @summary Get blueprints
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdBlueprints (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBlueprints200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/blueprints/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBlueprints.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBlueprints200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdBlueprints200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/legacy/characters/{character_id}/corporationhistory/`  Alternate route: `/v1/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
     * @summary Get corporation history
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdCorporationhistory (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCorporationhistory200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/corporationhistory/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCorporationhistory.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCorporationhistory200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdCorporationhistory200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a character's jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/legacy/characters/{character_id}/fatigue/`  Alternate route: `/v1/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
     * @summary Get jump fatigue
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdFatigue (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFatigueOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fatigue/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFatigue.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFatigueOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdFatigueOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/legacy/characters/{character_id}/medals/`  Alternate route: `/v1/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get medals
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdMedals (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMedals200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/medals/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMedals.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMedals200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdMedals200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
     * @summary Get character notifications
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdNotifications (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotifications200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/notifications/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdNotifications.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotifications200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdNotifications200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return notifications about having been added to someone's contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/legacy/characters/{character_id}/notifications/contacts/`  Alternate route: `/v1/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
     * @summary Get new contact notifications
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdNotificationsContacts (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotificationsContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/notifications/contacts/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdNotificationsContacts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotificationsContacts200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdNotificationsContacts200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get portrait urls for a character  --- Alternate route: `/v2/characters/{character_id}/portrait/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/portrait/)
     * @summary Get character portraits
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdPortrait (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPortraitOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/portrait/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPortrait.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPortraitOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdPortraitOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a character's corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v2/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation roles
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdRoles (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdRolesOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/roles/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdRoles.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdRolesOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdRolesOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/legacy/characters/{character_id}/standings/`  Alternate route: `/v1/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get standings
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdStandings (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStandings200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/standings/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdStandings.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStandings200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdStandings200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns aggregate yearly stats for a character  --- Alternate route: `/dev/characters/{character_id}/stats/`  Alternate route: `/v2/characters/{character_id}/stats/`  --- This route is cached for up to 86400 seconds
     * @summary Yearly aggregate stats
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdStats (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStats200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/stats/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdStats.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStats200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdStats200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a character's titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/legacy/characters/{character_id}/titles/`  Alternate route: `/v1/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation titles
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdTitles (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdTitles200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/titles/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdTitles.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdTitles200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdTitles200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/legacy/characters/affiliation/`  Alternate route: `/v1/characters/affiliation/`  --- This route is cached for up to 3600 seconds
     * @summary Character affiliation
     * @param characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
     * @param datasource The server name you would like data from
     * @param {*} [options] Override http request options.
     */
    public postCharactersAffiliation (characters: Array<number>, datasource?: 'tranquility', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PostCharactersAffiliation200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/affiliation/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characters' is not null or undefined
        if (characters === null || characters === undefined) {
            throw new Error('Required parameter characters was null or undefined when calling postCharactersAffiliation.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(characters, "Array<number>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCharactersAffiliation200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PostCharactersAffiliation200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v4/characters/{character_id}/cspa/` 
     * @summary Calculate a CSPA charge cost
     * @param characterId An EVE character ID
     * @param characters The target characters to calculate the charge for
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCharactersCharacterIdCspa (characterId: number, characters: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/cspa/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdCspa.');
        }

        // verify required parameter 'characters' is not null or undefined
        if (characters === null || characters === undefined) {
            throw new Error('Required parameter characters was null or undefined when calling postCharactersCharacterIdCspa.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(characters, "Array<number>")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClonesApiApiKeys {
}

export class ClonesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ClonesApiApiKeys, value: string) {
        (this.authentications as any)[ClonesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * A list of the character's clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
     * @summary Get clones
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdClones (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdClonesOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/clones/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdClones.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdClonesOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdClonesOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
     * @summary Get active implants
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdImplants (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/implants/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdImplants.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContactsApiApiKeys {
}

export class ContactsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContactsApiApiKeys, value: string) {
        (this.authentications as any)[ContactsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Delete contacts
     * @param characterId An EVE character ID
     * @param contactIds A list of contacts to delete
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public deleteCharactersCharacterIdContacts (characterId: number, contactIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling deleteCharactersCharacterIdContacts.');
        }

        if (contactIds !== undefined) {
            localVarQueryParameters['contact_ids'] = ObjectSerializer.serialize(contactIds, "Array<number>");
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contacts
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getAlliancesAllianceIdContacts (allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetAlliancesAllianceIdContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/contacts/'
            .replace('{' + 'alliance_id' + '}', encodeURIComponent(String(allianceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdContacts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetAlliancesAllianceIdContacts200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetAlliancesAllianceIdContacts200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return custom labels for an alliance's contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contact labels
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getAlliancesAllianceIdContactsLabels (allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetAlliancesAllianceIdContactsLabels200Ok>;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/contacts/labels/'
            .replace('{' + 'alliance_id' + '}', encodeURIComponent(String(allianceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdContactsLabels.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetAlliancesAllianceIdContactsLabels200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetAlliancesAllianceIdContactsLabels200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get contacts
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdContacts (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContacts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContacts200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdContacts200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return custom labels for a character's contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get contact labels
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdContactsLabels (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContactsLabels200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/labels/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContactsLabels.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContactsLabels200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdContactsLabels200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contacts
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdContacts (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contacts/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContacts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContacts200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdContacts200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return custom labels for a corporation's contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contact labels
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdContactsLabels (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContactsLabels200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contacts/labels/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContactsLabels.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContactsLabels200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdContactsLabels200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Add contacts
     * @param characterId An EVE character ID
     * @param contactIds A list of contacts
     * @param standing Standing for the contact
     * @param datasource The server name you would like data from
     * @param labelIds Add custom labels to the new contact
     * @param token Access token to use if unable to set a header
     * @param watched Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request options.
     */
    public postCharactersCharacterIdContacts (characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        // verify required parameter 'standing' is not null or undefined
        if (standing === null || standing === undefined) {
            throw new Error('Required parameter standing was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (labelIds !== undefined) {
            localVarQueryParameters['label_ids'] = ObjectSerializer.serialize(labelIds, "Array<number>");
        }

        if (standing !== undefined) {
            localVarQueryParameters['standing'] = ObjectSerializer.serialize(standing, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (watched !== undefined) {
            localVarQueryParameters['watched'] = ObjectSerializer.serialize(watched, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactIds, "Array<number>")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Edit contacts
     * @param characterId An EVE character ID
     * @param contactIds A list of contacts
     * @param standing Standing for the contact
     * @param datasource The server name you would like data from
     * @param labelIds Add custom labels to the contact
     * @param token Access token to use if unable to set a header
     * @param watched Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request options.
     */
    public putCharactersCharacterIdContacts (characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        // verify required parameter 'standing' is not null or undefined
        if (standing === null || standing === undefined) {
            throw new Error('Required parameter standing was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (labelIds !== undefined) {
            localVarQueryParameters['label_ids'] = ObjectSerializer.serialize(labelIds, "Array<number>");
        }

        if (standing !== undefined) {
            localVarQueryParameters['standing'] = ObjectSerializer.serialize(standing, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (watched !== undefined) {
            localVarQueryParameters['watched'] = ObjectSerializer.serialize(watched, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactIds, "Array<number>")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContractsApiApiKeys {
}

export class ContractsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContractsApiApiKeys, value: string) {
        (this.authentications as any)[ContractsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get contracts
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdContracts (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContracts200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contracts/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContracts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContracts200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdContracts200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
     * @summary Get contract bids
     * @param characterId An EVE character ID
     * @param contractId ID of a contract
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdContractsContractIdBids (characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdBids200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contracts/{contract_id}/bids/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'contract_id' + '}', encodeURIComponent(String(contractId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContractsContractIdBids.');
        }

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCharactersCharacterIdContractsContractIdBids.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdBids200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdContractsContractIdBids200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get contract items
     * @param characterId An EVE character ID
     * @param contractId ID of a contract
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdContractsContractIdItems (characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdItems200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contracts/{contract_id}/items/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'contract_id' + '}', encodeURIComponent(String(contractId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContractsContractIdItems.');
        }

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCharactersCharacterIdContractsContractIdItems.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdItems200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdContractsContractIdItems200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
     * @summary Get public contract bids
     * @param contractId ID of a contract
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param {*} [options] Override http request options.
     */
    public getContractsPublicBidsContractId (contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetContractsPublicBidsContractId200Ok>;  }> {
        const localVarPath = this.basePath + '/contracts/public/bids/{contract_id}/'
            .replace('{' + 'contract_id' + '}', encodeURIComponent(String(contractId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getContractsPublicBidsContractId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetContractsPublicBidsContractId200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetContractsPublicBidsContractId200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get public contract items
     * @param contractId ID of a contract
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param {*} [options] Override http request options.
     */
    public getContractsPublicItemsContractId (contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetContractsPublicItemsContractId200Ok>;  }> {
        const localVarPath = this.basePath + '/contracts/public/items/{contract_id}/'
            .replace('{' + 'contract_id' + '}', encodeURIComponent(String(contractId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getContractsPublicItemsContractId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetContractsPublicItemsContractId200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetContractsPublicItemsContractId200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
     * @summary Get public contracts
     * @param regionId An EVE region id
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param {*} [options] Override http request options.
     */
    public getContractsPublicRegionId (regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetContractsPublicRegionId200Ok>;  }> {
        const localVarPath = this.basePath + '/contracts/public/{region_id}/'
            .replace('{' + 'region_id' + '}', encodeURIComponent(String(regionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getContractsPublicRegionId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetContractsPublicRegionId200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetContractsPublicRegionId200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contracts
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdContracts (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContracts200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contracts/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContracts.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContracts200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdContracts200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract bids
     * @param contractId ID of a contract
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdContractsContractIdBids (contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contracts/{contract_id}/bids/'
            .replace('{' + 'contract_id' + '}', encodeURIComponent(String(contractId)))
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCorporationsCorporationIdContractsContractIdBids.');
        }

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContractsContractIdBids.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract items
     * @param contractId ID of a contract
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdContractsContractIdItems (contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contracts/{contract_id}/items/'
            .replace('{' + 'contract_id' + '}', encodeURIComponent(String(contractId)))
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCorporationsCorporationIdContractsContractIdItems.');
        }

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContractsContractIdItems.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CorporationApiApiKeys {
}

export class CorporationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CorporationApiApiKeys, value: string) {
        (this.authentications as any)[CorporationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v4/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation information
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationId (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCorporationsCorporationIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v2/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance history
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdAlliancehistory (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAlliancehistory200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/alliancehistory/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdAlliancehistory.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAlliancehistory200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdAlliancehistory200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v2/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation blueprints
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdBlueprints (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBlueprints200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/blueprints/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBlueprints.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBlueprints200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdBlueprints200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v2/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get all corporation ALSC logs
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdContainersLogs (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContainersLogs200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/containers/logs/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContainersLogs.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContainersLogs200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdContainersLogs200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/legacy/corporations/{corporation_id}/divisions/`  Alternate route: `/v1/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation divisions
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdDivisions (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdDivisionsOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/divisions/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdDivisions.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdDivisionsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCorporationsCorporationIdDivisionsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a corporation's facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/legacy/corporations/{corporation_id}/facilities/`  Alternate route: `/v1/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
     * @summary Get corporation facilities
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdFacilities (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdFacilities200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/facilities/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdFacilities.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdFacilities200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdFacilities200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the icon urls for a corporation  --- Alternate route: `/legacy/corporations/{corporation_id}/icons/`  Alternate route: `/v1/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/corporations/{corporation_id}/icons/)
     * @summary Get corporation icon
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdIcons (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdIconsOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/icons/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdIcons.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdIconsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCorporationsCorporationIdIconsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a corporation's medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/`  Alternate route: `/v1/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation medals
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdMedals (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedals200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/medals/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMedals.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedals200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdMedals200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v1/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation issued medals
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdMedalsIssued (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedalsIssued200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/medals/issued/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMedalsIssued.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedalsIssued200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdMedalsIssued200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return the current member list of a corporation, the token's character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v3/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation members
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdMembers (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/members/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembers.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a corporation's member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/legacy/corporations/{corporation_id}/members/limit/`  Alternate route: `/v1/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation member limit
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdMembersLimit (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/members/limit/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembersLimit.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a corporation's members' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/members/titles/`  Alternate route: `/v1/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation's members' titles
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdMembersTitles (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembersTitles200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/members/titles/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembersTitles.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembersTitles200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdMembersTitles200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns additional information about a corporation's members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/legacy/corporations/{corporation_id}/membertracking/`  Alternate route: `/v1/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Track corporation members
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdMembertracking (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembertracking200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/membertracking/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembertracking.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembertracking200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdMembertracking200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/`  Alternate route: `/v1/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation member roles
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdRoles (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRoles200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/roles/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdRoles.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRoles200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdRoles200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return how roles have changed for a coporation's members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/history/`  Alternate route: `/v1/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation member roles history
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdRolesHistory (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRolesHistory200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/roles/history/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdRolesHistory.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRolesHistory200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdRolesHistory200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation shareholders
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdShareholders (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdShareholders200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/shareholders/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdShareholders.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdShareholders200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdShareholders200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/legacy/corporations/{corporation_id}/standings/`  Alternate route: `/v1/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation standings
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdStandings (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStandings200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/standings/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStandings.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStandings200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdStandings200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation starbases (POSes)
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdStarbases (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStarbases200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/starbases/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStarbases.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStarbases200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdStarbases200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get starbase (POS) detail
     * @param corporationId An EVE corporation ID
     * @param starbaseId An EVE starbase (POS) ID
     * @param systemId The solar system this starbase (POS) is located in,
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdStarbasesStarbaseId (corporationId: number, starbaseId: number, systemId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdStarbasesStarbaseIdOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/starbases/{starbase_id}/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)))
            .replace('{' + 'starbase_id' + '}', encodeURIComponent(String(starbaseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
        }

        // verify required parameter 'starbaseId' is not null or undefined
        if (starbaseId === null || starbaseId === undefined) {
            throw new Error('Required parameter starbaseId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
        }

        // verify required parameter 'systemId' is not null or undefined
        if (systemId === null || systemId === undefined) {
            throw new Error('Required parameter systemId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (systemId !== undefined) {
            localVarQueryParameters['system_id'] = ObjectSerializer.serialize(systemId, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdStarbasesStarbaseIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCorporationsCorporationIdStarbasesStarbaseIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v3/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
     * @summary Get corporation structures
     * @param corporationId An EVE corporation ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdStructures (corporationId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStructures200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/structures/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStructures.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStructures200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdStructures200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a corporation's titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/titles/`  Alternate route: `/v1/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation titles
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdTitles (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdTitles200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/titles/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdTitles.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdTitles200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdTitles200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/legacy/corporations/npccorps/`  Alternate route: `/v1/corporations/npccorps/`  --- This route expires daily at 11:05
     * @summary Get npc corporations
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getCorporationsNpccorps (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/corporations/npccorps/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DogmaApiApiKeys {
}

export class DogmaApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DogmaApiApiKeys, value: string) {
        (this.authentications as any)[DogmaApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
     * @summary Get attributes
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getDogmaAttributes (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/dogma/attributes/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
     * @summary Get attribute information
     * @param attributeId A dogma attribute ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getDogmaAttributesAttributeId (attributeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetDogmaAttributesAttributeIdOk;  }> {
        const localVarPath = this.basePath + '/dogma/attributes/{attribute_id}/'
            .replace('{' + 'attribute_id' + '}', encodeURIComponent(String(attributeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributeId' is not null or undefined
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getDogmaAttributesAttributeId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetDogmaAttributesAttributeIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetDogmaAttributesAttributeIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
     * @summary Get dynamic item information
     * @param itemId item_id integer
     * @param typeId type_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getDogmaDynamicItemsTypeIdItemId (itemId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetDogmaDynamicItemsTypeIdItemIdOk;  }> {
        const localVarPath = this.basePath + '/dogma/dynamic/items/{type_id}/{item_id}/'
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)))
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling getDogmaDynamicItemsTypeIdItemId.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getDogmaDynamicItemsTypeIdItemId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetDogmaDynamicItemsTypeIdItemIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetDogmaDynamicItemsTypeIdItemIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
     * @summary Get effects
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getDogmaEffects (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/dogma/effects/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
     * @summary Get effect information
     * @param effectId A dogma effect ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getDogmaEffectsEffectId (effectId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetDogmaEffectsEffectIdOk;  }> {
        const localVarPath = this.basePath + '/dogma/effects/{effect_id}/'
            .replace('{' + 'effect_id' + '}', encodeURIComponent(String(effectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'effectId' is not null or undefined
        if (effectId === null || effectId === undefined) {
            throw new Error('Required parameter effectId was null or undefined when calling getDogmaEffectsEffectId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetDogmaEffectsEffectIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetDogmaEffectsEffectIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FactionWarfareApiApiKeys {
}

export class FactionWarfareApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FactionWarfareApiApiKeys, value: string) {
        (this.authentications as any)[FactionWarfareApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a character involved in faction warfare
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdFwStats (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFwStatsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fw/stats/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFwStats.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFwStatsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdFwStatsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a corporation involved in faction warfare
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdFwStats (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdFwStatsOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/fw/stats/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdFwStats.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdFwStatsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCorporationsCorporationIdFwStatsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
     * @summary List of the top factions in faction warfare
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getFwLeaderboards (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsOk;  }> {
        const localVarPath = this.basePath + '/fw/leaderboards/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFwLeaderboardsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
     * @summary List of the top pilots in faction warfare
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getFwLeaderboardsCharacters (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCharactersOk;  }> {
        const localVarPath = this.basePath + '/fw/leaderboards/characters/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCharactersOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFwLeaderboardsCharactersOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
     * @summary List of the top corporations in faction warfare
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getFwLeaderboardsCorporations (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCorporationsOk;  }> {
        const localVarPath = this.basePath + '/fw/leaderboards/corporations/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCorporationsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFwLeaderboardsCorporationsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
     * @summary An overview of statistics about factions involved in faction warfare
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getFwStats (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetFwStats200Ok>;  }> {
        const localVarPath = this.basePath + '/fw/stats/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFwStats200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetFwStats200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
     * @summary Ownership of faction warfare systems
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getFwSystems (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetFwSystems200Ok>;  }> {
        const localVarPath = this.basePath + '/fw/systems/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFwSystems200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetFwSystems200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
     * @summary Data about which NPC factions are at war
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getFwWars (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetFwWars200Ok>;  }> {
        const localVarPath = this.basePath + '/fw/wars/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFwWars200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetFwWars200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FittingsApiApiKeys {
}

export class FittingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FittingsApiApiKeys, value: string) {
        (this.authentications as any)[FittingsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
     * @summary Delete fitting
     * @param characterId An EVE character ID
     * @param fittingId ID for a fitting of this character
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public deleteCharactersCharacterIdFittingsFittingId (characterId: number, fittingId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/{fitting_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'fitting_id' + '}', encodeURIComponent(String(fittingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
        }

        // verify required parameter 'fittingId' is not null or undefined
        if (fittingId === null || fittingId === undefined) {
            throw new Error('Required parameter fittingId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
     * @summary Get fittings
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdFittings (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdFittings200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFittings.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdFittings200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdFittings200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
     * @summary Create fitting
     * @param characterId An EVE character ID
     * @param fitting Details about the new fitting
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCharactersCharacterIdFittings (characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdFittingsCreated;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdFittings.');
        }

        // verify required parameter 'fitting' is not null or undefined
        if (fitting === null || fitting === undefined) {
            throw new Error('Required parameter fitting was null or undefined when calling postCharactersCharacterIdFittings.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fitting, "PostCharactersCharacterIdFittingsFitting")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdFittingsCreated;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCharactersCharacterIdFittingsCreated");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FleetsApiApiKeys {
}

export class FleetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FleetsApiApiKeys, value: string) {
        (this.authentications as any)[FleetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
     * @summary Kick fleet member
     * @param fleetId ID for a fleet
     * @param memberId The character ID of a member in this fleet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public deleteFleetsFleetIdMembersMemberId (fleetId: number, memberId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/{member_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)))
            .replace('{' + 'member_id' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
     * @summary Delete fleet squad
     * @param fleetId ID for a fleet
     * @param squadId The squad to delete
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public deleteFleetsFleetIdSquadsSquadId (fleetId: number, squadId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/squads/{squad_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)))
            .replace('{' + 'squad_id' + '}', encodeURIComponent(String(squadId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'squadId' is not null or undefined
        if (squadId === null || squadId === undefined) {
            throw new Error('Required parameter squadId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
     * @summary Delete fleet wing
     * @param fleetId ID for a fleet
     * @param wingId The wing to delete
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public deleteFleetsFleetIdWingsWingId (fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)))
            .replace('{' + 'wing_id' + '}', encodeURIComponent(String(wingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
     * @summary Get character fleet info
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdFleet (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFleetOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fleet/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFleet.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFleetOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdFleetOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet information
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getFleetsFleetId (fleetId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetFleetsFleetIdOk;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFleetsFleetIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFleetsFleetIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet members
     * @param fleetId ID for a fleet
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getFleetsFleetIdMembers (fleetId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdMembers200Ok>;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetIdMembers.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdMembers200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetFleetsFleetIdMembers200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet wings
     * @param fleetId ID for a fleet
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getFleetsFleetIdWings (fleetId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdWings200Ok>;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetIdWings.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdWings200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetFleetsFleetIdWings200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
     * @summary Create fleet invitation
     * @param fleetId ID for a fleet
     * @param invitation Details of the invitation
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postFleetsFleetIdMembers (fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdMembers.');
        }

        // verify required parameter 'invitation' is not null or undefined
        if (invitation === null || invitation === undefined) {
            throw new Error('Required parameter invitation was null or undefined when calling postFleetsFleetIdMembers.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(invitation, "PostFleetsFleetIdMembersInvitation")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
     * @summary Create fleet wing
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postFleetsFleetIdWings (fleetId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsCreated;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdWings.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsCreated;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostFleetsFleetIdWingsCreated");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
     * @summary Create fleet squad
     * @param fleetId ID for a fleet
     * @param wingId The wing_id to create squad in
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postFleetsFleetIdWingsWingIdSquads (fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsWingIdSquadsCreated;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/squads/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)))
            .replace('{' + 'wing_id' + '}', encodeURIComponent(String(wingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsWingIdSquadsCreated;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostFleetsFleetIdWingsWingIdSquadsCreated");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
     * @summary Update fleet
     * @param fleetId ID for a fleet
     * @param newSettings What to update for this fleet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public putFleetsFleetId (fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetId.');
        }

        // verify required parameter 'newSettings' is not null or undefined
        if (newSettings === null || newSettings === undefined) {
            throw new Error('Required parameter newSettings was null or undefined when calling putFleetsFleetId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newSettings, "PutFleetsFleetIdNewSettings")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
     * @summary Move fleet member
     * @param fleetId ID for a fleet
     * @param memberId The character ID of a member in this fleet
     * @param movement Details of the invitation
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public putFleetsFleetIdMembersMemberId (fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/{member_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)))
            .replace('{' + 'member_id' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'movement' is not null or undefined
        if (movement === null || movement === undefined) {
            throw new Error('Required parameter movement was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(movement, "PutFleetsFleetIdMembersMemberIdMovement")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
     * @summary Rename fleet squad
     * @param fleetId ID for a fleet
     * @param naming New name of the squad
     * @param squadId The squad to rename
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public putFleetsFleetIdSquadsSquadId (fleetId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, squadId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/squads/{squad_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)))
            .replace('{' + 'squad_id' + '}', encodeURIComponent(String(squadId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'naming' is not null or undefined
        if (naming === null || naming === undefined) {
            throw new Error('Required parameter naming was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'squadId' is not null or undefined
        if (squadId === null || squadId === undefined) {
            throw new Error('Required parameter squadId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(naming, "PutFleetsFleetIdSquadsSquadIdNaming")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
     * @summary Rename fleet wing
     * @param fleetId ID for a fleet
     * @param naming New name of the wing
     * @param wingId The wing to rename
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public putFleetsFleetIdWingsWingId (fleetId: number, naming: PutFleetsFleetIdWingsWingIdNaming, wingId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/'
            .replace('{' + 'fleet_id' + '}', encodeURIComponent(String(fleetId)))
            .replace('{' + 'wing_id' + '}', encodeURIComponent(String(wingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'naming' is not null or undefined
        if (naming === null || naming === undefined) {
            throw new Error('Required parameter naming was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(naming, "PutFleetsFleetIdWingsWingIdNaming")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IncursionsApiApiKeys {
}

export class IncursionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IncursionsApiApiKeys, value: string) {
        (this.authentications as any)[IncursionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
     * @summary List incursions
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getIncursions (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetIncursions200Ok>;  }> {
        const localVarPath = this.basePath + '/incursions/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIncursions200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetIncursions200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IndustryApiApiKeys {
}

export class IndustryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IndustryApiApiKeys, value: string) {
        (this.authentications as any)[IndustryApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
     * @summary List character industry jobs
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param includeCompleted Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdIndustryJobs (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdIndustryJobs200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/industry/jobs/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdIndustryJobs.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (includeCompleted !== undefined) {
            localVarQueryParameters['include_completed'] = ObjectSerializer.serialize(includeCompleted, "boolean");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdIndustryJobs200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdIndustryJobs200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
     * @summary Character mining ledger
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdMining (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMining200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mining/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMining.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMining200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdMining200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
     * @summary Moon extraction timers
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationCorporationIdMiningExtractions (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningExtractions200Ok>;  }> {
        const localVarPath = this.basePath + '/corporation/{corporation_id}/mining/extractions/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningExtractions.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningExtractions200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationCorporationIdMiningExtractions200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @summary Corporation mining observers
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationCorporationIdMiningObservers (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObservers200Ok>;  }> {
        const localVarPath = this.basePath + '/corporation/{corporation_id}/mining/observers/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningObservers.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObservers200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationCorporationIdMiningObservers200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @summary Observed corporation mining
     * @param corporationId An EVE corporation ID
     * @param observerId A mining observer id
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationCorporationIdMiningObserversObserverId (corporationId: number, observerId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>;  }> {
        const localVarPath = this.basePath + '/corporation/{corporation_id}/mining/observers/{observer_id}/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)))
            .replace('{' + 'observer_id' + '}', encodeURIComponent(String(observerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningObserversObserverId.');
        }

        // verify required parameter 'observerId' is not null or undefined
        if (observerId === null || observerId === undefined) {
            throw new Error('Required parameter observerId was null or undefined when calling getCorporationCorporationIdMiningObserversObserverId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
     * @summary List corporation industry jobs
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param includeCompleted Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdIndustryJobs (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdIndustryJobs200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/industry/jobs/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdIndustryJobs.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (includeCompleted !== undefined) {
            localVarQueryParameters['include_completed'] = ObjectSerializer.serialize(includeCompleted, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdIndustryJobs200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdIndustryJobs200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
     * @summary List industry facilities
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getIndustryFacilities (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetIndustryFacilities200Ok>;  }> {
        const localVarPath = this.basePath + '/industry/facilities/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIndustryFacilities200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetIndustryFacilities200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
     * @summary List solar system cost indices
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getIndustrySystems (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetIndustrySystems200Ok>;  }> {
        const localVarPath = this.basePath + '/industry/systems/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIndustrySystems200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetIndustrySystems200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InsuranceApiApiKeys {
}

export class InsuranceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InsuranceApiApiKeys, value: string) {
        (this.authentications as any)[InsuranceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List insurance levels
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getInsurancePrices (acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetInsurancePrices200Ok>;  }> {
        const localVarPath = this.basePath + '/insurance/prices/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetInsurancePrices200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetInsurancePrices200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KillmailsApiApiKeys {
}

export class KillmailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: KillmailsApiApiKeys, value: string) {
        (this.authentications as any)[KillmailsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return a list of a character's kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
     * @summary Get a character's recent kills and losses
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdKillmailsRecent (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdKillmailsRecent200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/killmails/recent/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdKillmailsRecent.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdKillmailsRecent200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdKillmailsRecent200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of a corporation's kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get a corporation's recent kills and losses
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdKillmailsRecent (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdKillmailsRecent200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/killmails/recent/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdKillmailsRecent.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdKillmailsRecent200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdKillmailsRecent200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
     * @summary Get a single killmail
     * @param killmailHash The killmail hash for verification
     * @param killmailId The killmail ID to be queried
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getKillmailsKillmailIdKillmailHash (killmailHash: string, killmailId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetKillmailsKillmailIdKillmailHashOk;  }> {
        const localVarPath = this.basePath + '/killmails/{killmail_id}/{killmail_hash}/'
            .replace('{' + 'killmail_hash' + '}', encodeURIComponent(String(killmailHash)))
            .replace('{' + 'killmail_id' + '}', encodeURIComponent(String(killmailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'killmailHash' is not null or undefined
        if (killmailHash === null || killmailHash === undefined) {
            throw new Error('Required parameter killmailHash was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
        }

        // verify required parameter 'killmailId' is not null or undefined
        if (killmailId === null || killmailId === undefined) {
            throw new Error('Required parameter killmailId was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetKillmailsKillmailIdKillmailHashOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetKillmailsKillmailIdKillmailHashOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationApiApiKeys {
}

export class LocationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationApiApiKeys, value: string) {
        (this.authentications as any)[LocationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
     * @summary Get character location
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdLocation (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdLocationOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/location/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdLocation.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdLocationOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdLocationOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
     * @summary Get character online
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdOnline (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOnlineOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/online/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdOnline.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOnlineOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdOnlineOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
     * @summary Get current ship
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdShip (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdShipOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/ship/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdShip.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdShipOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdShipOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoyaltyApiApiKeys {
}

export class LoyaltyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoyaltyApiApiKeys, value: string) {
        (this.authentications as any)[LoyaltyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
     * @summary Get loyalty points
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdLoyaltyPoints (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdLoyaltyPoints200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/loyalty/points/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdLoyaltyPoints.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdLoyaltyPoints200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdLoyaltyPoints200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of offers from a specific corporation's loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
     * @summary List loyalty store offers
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getLoyaltyStoresCorporationIdOffers (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetLoyaltyStoresCorporationIdOffers200Ok>;  }> {
        const localVarPath = this.basePath + '/loyalty/stores/{corporation_id}/offers/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getLoyaltyStoresCorporationIdOffers.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetLoyaltyStoresCorporationIdOffers200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetLoyaltyStoresCorporationIdOffers200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MailApiApiKeys {
}

export class MailApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MailApiApiKeys, value: string) {
        (this.authentications as any)[MailApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
     * @summary Delete a mail label
     * @param characterId An EVE character ID
     * @param labelId An EVE label id
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public deleteCharactersCharacterIdMailLabelsLabelId (characterId: number, labelId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/{label_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'label_id' + '}', encodeURIComponent(String(labelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
        }

        // verify required parameter 'labelId' is not null or undefined
        if (labelId === null || labelId === undefined) {
            throw new Error('Required parameter labelId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
     * @summary Delete a mail
     * @param characterId An EVE character ID
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public deleteCharactersCharacterIdMailMailId (characterId: number, mailId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'mail_id' + '}', encodeURIComponent(String(mailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
     * @summary Return mail headers
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param labels Fetch only mails that match one or more of the given labels
     * @param lastMailId List only mail with an ID lower than the given ID, if present
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdMail (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, labels?: Array<number>, lastMailId?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMail200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMail.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "Array<number>");
        }

        if (lastMailId !== undefined) {
            localVarQueryParameters['last_mail_id'] = ObjectSerializer.serialize(lastMailId, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMail200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdMail200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
     * @summary Get mail labels and unread counts
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdMailLabels (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailLabelsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLabels.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailLabelsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdMailLabelsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
     * @summary Return mailing list subscriptions
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdMailLists (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMailLists200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/lists/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLists.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMailLists200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdMailLists200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
     * @summary Return a mail
     * @param characterId An EVE character ID
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdMailMailId (characterId: number, mailId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailMailIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'mail_id' + '}', encodeURIComponent(String(mailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailMailIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdMailMailIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
     * @summary Send a new mail
     * @param characterId An EVE character ID
     * @param mail The mail to send
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCharactersCharacterIdMail (characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdMail.');
        }

        // verify required parameter 'mail' is not null or undefined
        if (mail === null || mail === undefined) {
            throw new Error('Required parameter mail was null or undefined when calling postCharactersCharacterIdMail.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mail, "PostCharactersCharacterIdMailMail")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
     * @summary Create a mail label
     * @param characterId An EVE character ID
     * @param label Label to create
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postCharactersCharacterIdMailLabels (characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdMailLabels.');
        }

        // verify required parameter 'label' is not null or undefined
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling postCharactersCharacterIdMailLabels.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(label, "PostCharactersCharacterIdMailLabelsLabel")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
     * @summary Update metadata about a mail
     * @param characterId An EVE character ID
     * @param contents Data used to update the mail
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public putCharactersCharacterIdMailMailId (characterId: number, contents: PutCharactersCharacterIdMailMailIdContents, mailId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'mail_id' + '}', encodeURIComponent(String(mailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'contents' is not null or undefined
        if (contents === null || contents === undefined) {
            throw new Error('Required parameter contents was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contents, "PutCharactersCharacterIdMailMailIdContents")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MarketApiApiKeys {
}

export class MarketApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MarketApiApiKeys, value: string) {
        (this.authentications as any)[MarketApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
     * @summary List open orders from a character
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdOrders (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOrders200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/orders/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdOrders.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOrders200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdOrders200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
     * @summary List historical orders by a character
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdOrdersHistory (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOrdersHistory200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/orders/history/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdOrdersHistory.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOrdersHistory200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdOrdersHistory200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
     * @summary List open orders from a corporation
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdOrders (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdOrders200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/orders/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdOrders.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdOrders200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdOrders200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
     * @summary List historical orders from a corporation
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdOrdersHistory (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdOrdersHistory200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/orders/history/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdOrdersHistory.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdOrdersHistory200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdOrdersHistory200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getMarketsGroups (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/markets/groups/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param marketGroupId An Eve item group ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getMarketsGroupsMarketGroupId (marketGroupId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetMarketsGroupsMarketGroupIdOk;  }> {
        const localVarPath = this.basePath + '/markets/groups/{market_group_id}/'
            .replace('{' + 'market_group_id' + '}', encodeURIComponent(String(marketGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'marketGroupId' is not null or undefined
        if (marketGroupId === null || marketGroupId === undefined) {
            throw new Error('Required parameter marketGroupId was null or undefined when calling getMarketsGroupsMarketGroupId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetMarketsGroupsMarketGroupIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetMarketsGroupsMarketGroupIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List market prices
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getMarketsPrices (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsPrices200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/prices/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsPrices200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetMarketsPrices200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
     * @summary List historical market statistics in a region
     * @param regionId Return statistics in this region
     * @param typeId Return statistics for this type
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getMarketsRegionIdHistory (regionId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdHistory200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/history/'
            .replace('{' + 'region_id' + '}', encodeURIComponent(String(regionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdHistory.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getMarketsRegionIdHistory.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (typeId !== undefined) {
            localVarQueryParameters['type_id'] = ObjectSerializer.serialize(typeId, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdHistory200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetMarketsRegionIdHistory200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a region
     * @param orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
     * @param regionId Return orders in this region
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param typeId Return orders only for this type
     * @param {*} [options] Override http request options.
     */
    public getMarketsRegionIdOrders (orderType: 'buy' | 'sell' | 'all', regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, typeId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdOrders200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/orders/'
            .replace('{' + 'region_id' + '}', encodeURIComponent(String(regionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderType' is not null or undefined
        if (orderType === null || orderType === undefined) {
            throw new Error('Required parameter orderType was null or undefined when calling getMarketsRegionIdOrders.');
        }

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdOrders.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (orderType !== undefined) {
            localVarQueryParameters['order_type'] = ObjectSerializer.serialize(orderType, "'buy' | 'sell' | 'all'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (typeId !== undefined) {
            localVarQueryParameters['type_id'] = ObjectSerializer.serialize(typeId, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdOrders200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetMarketsRegionIdOrders200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
     * @summary List type IDs relevant to a market
     * @param regionId Return statistics in this region
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param {*} [options] Override http request options.
     */
    public getMarketsRegionIdTypes (regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/types/'
            .replace('{' + 'region_id' + '}', encodeURIComponent(String(regionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdTypes.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a structure
     * @param structureId Return orders in this structure
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getMarketsStructuresStructureId (structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsStructuresStructureId200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/structures/{structure_id}/'
            .replace('{' + 'structure_id' + '}', encodeURIComponent(String(structureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'structureId' is not null or undefined
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling getMarketsStructuresStructureId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsStructuresStructureId200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetMarketsStructuresStructureId200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OpportunitiesApiApiKeys {
}

export class OpportunitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OpportunitiesApiApiKeys, value: string) {
        (this.authentications as any)[OpportunitiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
     * @summary Get a character's completed tasks
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdOpportunities (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOpportunities200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/opportunities/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdOpportunities.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOpportunities200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdOpportunities200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
     * @summary Get opportunities groups
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getOpportunitiesGroups (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/opportunities/groups/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities group
     * @param groupId ID of an opportunities group
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getOpportunitiesGroupsGroupId (groupId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetOpportunitiesGroupsGroupIdOk;  }> {
        const localVarPath = this.basePath + '/opportunities/groups/{group_id}/'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getOpportunitiesGroupsGroupId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetOpportunitiesGroupsGroupIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetOpportunitiesGroupsGroupIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
     * @summary Get opportunities tasks
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getOpportunitiesTasks (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/opportunities/tasks/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities task
     * @param taskId ID of an opportunities task
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getOpportunitiesTasksTaskId (taskId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetOpportunitiesTasksTaskIdOk;  }> {
        const localVarPath = this.basePath + '/opportunities/tasks/{task_id}/'
            .replace('{' + 'task_id' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling getOpportunitiesTasksTaskId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetOpportunitiesTasksTaskIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetOpportunitiesTasksTaskIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlanetaryInteractionApiApiKeys {
}

export class PlanetaryInteractionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlanetaryInteractionApiApiKeys, value: string) {
        (this.authentications as any)[PlanetaryInteractionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
     * @summary Get colonies
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdPlanets (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdPlanets200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/planets/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanets.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdPlanets200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdPlanets200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/`  --- This route is cached for up to 600 seconds
     * @summary Get colony layout
     * @param characterId An EVE character ID
     * @param planetId Planet id of the target planet
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdPlanetsPlanetId (characterId: number, planetId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPlanetsPlanetIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/planets/{planet_id}/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)))
            .replace('{' + 'planet_id' + '}', encodeURIComponent(String(planetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
        }

        // verify required parameter 'planetId' is not null or undefined
        if (planetId === null || planetId === undefined) {
            throw new Error('Required parameter planetId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPlanetsPlanetIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdPlanetsPlanetIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary List corporation customs offices
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdCustomsOffices (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdCustomsOffices200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/customs_offices/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdCustomsOffices.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdCustomsOffices200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdCustomsOffices200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get schematic information
     * @param schematicId A PI schematic ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseSchematicsSchematicId (schematicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseSchematicsSchematicIdOk;  }> {
        const localVarPath = this.basePath + '/universe/schematics/{schematic_id}/'
            .replace('{' + 'schematic_id' + '}', encodeURIComponent(String(schematicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'schematicId' is not null or undefined
        if (schematicId === null || schematicId === undefined) {
            throw new Error('Required parameter schematicId was null or undefined when calling getUniverseSchematicsSchematicId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseSchematicsSchematicIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseSchematicsSchematicIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RoutesApiApiKeys {
}

export class RoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RoutesApiApiKeys, value: string) {
        (this.authentications as any)[RoutesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
     * @summary Get route
     * @param destination destination solar system ID
     * @param origin origin solar system ID
     * @param avoid avoid solar system ID(s)
     * @param connections connected solar system pairs
     * @param datasource The server name you would like data from
     * @param flag route security preference
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getRouteOriginDestination (destination: number, origin: number, avoid?: Array<number>, connections?: Array<Array<number>>, datasource?: 'tranquility', flag?: 'shortest' | 'secure' | 'insecure', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/route/{origin}/{destination}/'
            .replace('{' + 'destination' + '}', encodeURIComponent(String(destination)))
            .replace('{' + 'origin' + '}', encodeURIComponent(String(origin)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'destination' is not null or undefined
        if (destination === null || destination === undefined) {
            throw new Error('Required parameter destination was null or undefined when calling getRouteOriginDestination.');
        }

        // verify required parameter 'origin' is not null or undefined
        if (origin === null || origin === undefined) {
            throw new Error('Required parameter origin was null or undefined when calling getRouteOriginDestination.');
        }

        if (avoid !== undefined) {
            localVarQueryParameters['avoid'] = ObjectSerializer.serialize(avoid, "Array<number>");
        }

        if (connections !== undefined) {
            localVarQueryParameters['connections'] = ObjectSerializer.serialize(connections, "Array<Array<number>>");
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (flag !== undefined) {
            localVarQueryParameters['flag'] = ObjectSerializer.serialize(flag, "'shortest' | 'secure' | 'insecure'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchApiApiKeys {
}

export class SearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SearchApiApiKeys, value: string) {
        (this.authentications as any)[SearchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
     * @summary Search on a string
     * @param categories Type of entities to search for
     * @param characterId An EVE character ID
     * @param search The string to search on
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param strict Whether the search should be a strict match
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdSearch (categories: Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>, characterId: number, search: string, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', strict?: boolean, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSearchOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/search/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        if (categories !== undefined) {
            localVarQueryParameters['categories'] = ObjectSerializer.serialize(categories, "Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>");
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (strict !== undefined) {
            localVarQueryParameters['strict'] = ObjectSerializer.serialize(strict, "boolean");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSearchOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdSearchOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search for entities that match a given sub-string.  --- Alternate route: `/dev/search/`  Alternate route: `/legacy/search/`  Alternate route: `/v2/search/`  --- This route is cached for up to 3600 seconds
     * @summary Search on a string
     * @param categories Type of entities to search for
     * @param search The string to search on
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param strict Whether the search should be a strict match
     * @param {*} [options] Override http request options.
     */
    public getSearch (categories: Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station'>, search: string, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', strict?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetSearchOk;  }> {
        const localVarPath = this.basePath + '/search/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling getSearch.');
        }

        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getSearch.');
        }

        if (categories !== undefined) {
            localVarQueryParameters['categories'] = ObjectSerializer.serialize(categories, "Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station'>");
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (strict !== undefined) {
            localVarQueryParameters['strict'] = ObjectSerializer.serialize(strict, "boolean");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSearchOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSearchOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SkillsApiApiKeys {
}

export class SkillsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SkillsApiApiKeys, value: string) {
        (this.authentications as any)[SkillsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
     * @summary Get character attributes
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdAttributes (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdAttributesOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/attributes/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdAttributes.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdAttributesOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdAttributesOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
     * @summary Get character's skill queue
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdSkillqueue (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdSkillqueue200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/skillqueue/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkillqueue.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdSkillqueue200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdSkillqueue200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
     * @summary Get character skills
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdSkills (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSkillsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/skills/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkills.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSkillsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetCharactersCharacterIdSkillsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SovereigntyApiApiKeys {
}

export class SovereigntyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SovereigntyApiApiKeys, value: string) {
        (this.authentications as any)[SovereigntyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
     * @summary List sovereignty campaigns
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getSovereigntyCampaigns (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyCampaigns200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/campaigns/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyCampaigns200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetSovereigntyCampaigns200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
     * @summary List sovereignty of systems
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getSovereigntyMap (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyMap200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/map/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyMap200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetSovereigntyMap200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
     * @summary List sovereignty structures
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getSovereigntyStructures (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyStructures200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/structures/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyStructures200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetSovereigntyStructures200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StatusApiApiKeys {
}

export class StatusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StatusApiApiKeys, value: string) {
        (this.authentications as any)[StatusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  --- This route is cached for up to 30 seconds
     * @summary Retrieve the uptime and player counts
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getStatus (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetStatusOk;  }> {
        const localVarPath = this.basePath + '/status/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetStatusOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetStatusOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniverseApiApiKeys {
}

export class UniverseApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UniverseApiApiKeys, value: string) {
        (this.authentications as any)[UniverseApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get all character ancestries  --- Alternate route: `/dev/universe/ancestries/`  Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * @summary Get ancestries
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseAncestries (acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseAncestries200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/ancestries/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseAncestries200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetUniverseAncestries200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on an asteroid belt  --- Alternate route: `/dev/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * @summary Get asteroid belt information
     * @param asteroidBeltId asteroid_belt_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseAsteroidBeltsAsteroidBeltId (asteroidBeltId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseAsteroidBeltsAsteroidBeltIdOk;  }> {
        const localVarPath = this.basePath + '/universe/asteroid_belts/{asteroid_belt_id}/'
            .replace('{' + 'asteroid_belt_id' + '}', encodeURIComponent(String(asteroidBeltId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'asteroidBeltId' is not null or undefined
        if (asteroidBeltId === null || asteroidBeltId === undefined) {
            throw new Error('Required parameter asteroidBeltId was null or undefined when calling getUniverseAsteroidBeltsAsteroidBeltId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseAsteroidBeltsAsteroidBeltIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseAsteroidBeltsAsteroidBeltIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of bloodlines  --- Alternate route: `/dev/universe/bloodlines/`  Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * @summary Get bloodlines
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseBloodlines (acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseBloodlines200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/bloodlines/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseBloodlines200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetUniverseBloodlines200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of item categories  --- Alternate route: `/dev/universe/categories/`  Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * @summary Get item categories
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseCategories (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/categories/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information of an item category  --- Alternate route: `/dev/universe/categories/{category_id}/`  Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * @summary Get item category information
     * @param categoryId An Eve item category ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseCategoriesCategoryId (categoryId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseCategoriesCategoryIdOk;  }> {
        const localVarPath = this.basePath + '/universe/categories/{category_id}/'
            .replace('{' + 'category_id' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getUniverseCategoriesCategoryId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseCategoriesCategoryIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseCategoriesCategoryIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of constellations  --- Alternate route: `/dev/universe/constellations/`  Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * @summary Get constellations
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseConstellations (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/constellations/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a constellation  --- Alternate route: `/dev/universe/constellations/{constellation_id}/`  Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * @summary Get constellation information
     * @param constellationId constellation_id integer
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseConstellationsConstellationId (constellationId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseConstellationsConstellationIdOk;  }> {
        const localVarPath = this.basePath + '/universe/constellations/{constellation_id}/'
            .replace('{' + 'constellation_id' + '}', encodeURIComponent(String(constellationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'constellationId' is not null or undefined
        if (constellationId === null || constellationId === undefined) {
            throw new Error('Required parameter constellationId was null or undefined when calling getUniverseConstellationsConstellationId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseConstellationsConstellationIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseConstellationsConstellationIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * @summary Get factions
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseFactions (acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseFactions200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/factions/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseFactions200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetUniverseFactions200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of graphics  --- Alternate route: `/dev/universe/graphics/`  Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * @summary Get graphics
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseGraphics (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/graphics/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * @summary Get graphic information
     * @param graphicId graphic_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseGraphicsGraphicId (graphicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseGraphicsGraphicIdOk;  }> {
        const localVarPath = this.basePath + '/universe/graphics/{graphic_id}/'
            .replace('{' + 'graphic_id' + '}', encodeURIComponent(String(graphicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'graphicId' is not null or undefined
        if (graphicId === null || graphicId === undefined) {
            throw new Error('Required parameter graphicId was null or undefined when calling getUniverseGraphicsGraphicId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseGraphicsGraphicIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseGraphicsGraphicIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of item groups  --- Alternate route: `/dev/universe/groups/`  Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param {*} [options] Override http request options.
     */
    public getUniverseGroups (datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/groups/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param groupId An Eve item group ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseGroupsGroupId (groupId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseGroupsGroupIdOk;  }> {
        const localVarPath = this.basePath + '/universe/groups/{group_id}/'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getUniverseGroupsGroupId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseGroupsGroupIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseGroupsGroupIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a moon  --- Alternate route: `/dev/universe/moons/{moon_id}/`  Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * @summary Get moon information
     * @param moonId moon_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseMoonsMoonId (moonId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseMoonsMoonIdOk;  }> {
        const localVarPath = this.basePath + '/universe/moons/{moon_id}/'
            .replace('{' + 'moon_id' + '}', encodeURIComponent(String(moonId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'moonId' is not null or undefined
        if (moonId === null || moonId === undefined) {
            throw new Error('Required parameter moonId was null or undefined when calling getUniverseMoonsMoonId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseMoonsMoonIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseMoonsMoonIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a planet  --- Alternate route: `/dev/universe/planets/{planet_id}/`  Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * @summary Get planet information
     * @param planetId planet_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniversePlanetsPlanetId (planetId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniversePlanetsPlanetIdOk;  }> {
        const localVarPath = this.basePath + '/universe/planets/{planet_id}/'
            .replace('{' + 'planet_id' + '}', encodeURIComponent(String(planetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'planetId' is not null or undefined
        if (planetId === null || planetId === undefined) {
            throw new Error('Required parameter planetId was null or undefined when calling getUniversePlanetsPlanetId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniversePlanetsPlanetIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniversePlanetsPlanetIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * @summary Get character races
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseRaces (acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseRaces200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/races/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseRaces200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetUniverseRaces200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of regions  --- Alternate route: `/dev/universe/regions/`  Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * @summary Get regions
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseRegions (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/regions/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a region  --- Alternate route: `/dev/universe/regions/{region_id}/`  Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * @summary Get region information
     * @param regionId region_id integer
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseRegionsRegionId (regionId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseRegionsRegionIdOk;  }> {
        const localVarPath = this.basePath + '/universe/regions/{region_id}/'
            .replace('{' + 'region_id' + '}', encodeURIComponent(String(regionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getUniverseRegionsRegionId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseRegionsRegionIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseRegionsRegionIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a stargate  --- Alternate route: `/dev/universe/stargates/{stargate_id}/`  Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * @summary Get stargate information
     * @param stargateId stargate_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseStargatesStargateId (stargateId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseStargatesStargateIdOk;  }> {
        const localVarPath = this.basePath + '/universe/stargates/{stargate_id}/'
            .replace('{' + 'stargate_id' + '}', encodeURIComponent(String(stargateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'stargateId' is not null or undefined
        if (stargateId === null || stargateId === undefined) {
            throw new Error('Required parameter stargateId was null or undefined when calling getUniverseStargatesStargateId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStargatesStargateIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseStargatesStargateIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a star  --- Alternate route: `/dev/universe/stars/{star_id}/`  Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * @summary Get star information
     * @param starId star_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseStarsStarId (starId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseStarsStarIdOk;  }> {
        const localVarPath = this.basePath + '/universe/stars/{star_id}/'
            .replace('{' + 'star_id' + '}', encodeURIComponent(String(starId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'starId' is not null or undefined
        if (starId === null || starId === undefined) {
            throw new Error('Required parameter starId was null or undefined when calling getUniverseStarsStarId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStarsStarIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseStarsStarIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * @summary Get station information
     * @param stationId station_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseStationsStationId (stationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseStationsStationIdOk;  }> {
        const localVarPath = this.basePath + '/universe/stations/{station_id}/'
            .replace('{' + 'station_id' + '}', encodeURIComponent(String(stationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'stationId' is not null or undefined
        if (stationId === null || stationId === undefined) {
            throw new Error('Required parameter stationId was null or undefined when calling getUniverseStationsStationId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStationsStationIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseStationsStationIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * @summary List all public structures
     * @param datasource The server name you would like data from
     * @param filter Only list public structures that have this service online
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseStructures (datasource?: 'tranquility', filter?: 'market' | 'manufacturing_basic', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/structures/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'market' | 'manufacturing_basic'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/dev/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get structure information
     * @param structureId An Eve structure ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getUniverseStructuresStructureId (structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseStructuresStructureIdOk;  }> {
        const localVarPath = this.basePath + '/universe/structures/{structure_id}/'
            .replace('{' + 'structure_id' + '}', encodeURIComponent(String(structureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'structureId' is not null or undefined
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling getUniverseStructuresStructureId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStructuresStructureIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseStructuresStructureIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/dev/universe/system_jumps/`  Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * @summary Get system jumps
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseSystemJumps (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemJumps200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/system_jumps/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemJumps200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetUniverseSystemJumps200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/dev/universe/system_kills/`  Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * @summary Get system kills
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseSystemKills (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemKills200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/system_kills/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemKills200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetUniverseSystemKills200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * @summary Get solar systems
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getUniverseSystems (datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/systems/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * @summary Get solar system information
     * @param systemId system_id integer
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseSystemsSystemId (systemId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseSystemsSystemIdOk;  }> {
        const localVarPath = this.basePath + '/universe/systems/{system_id}/'
            .replace('{' + 'system_id' + '}', encodeURIComponent(String(systemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'systemId' is not null or undefined
        if (systemId === null || systemId === undefined) {
            throw new Error('Required parameter systemId was null or undefined when calling getUniverseSystemsSystemId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseSystemsSystemIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseSystemsSystemIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of type ids  --- Alternate route: `/dev/universe/types/`  Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * @summary Get types
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param {*} [options] Override http request options.
     */
    public getUniverseTypes (datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/types/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * @summary Get type information
     * @param typeId An Eve item type ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getUniverseTypesTypeId (typeId: number, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: GetUniverseTypesTypeIdOk;  }> {
        const localVarPath = this.basePath + '/universe/types/{type_id}/'
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getUniverseTypesTypeId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseTypesTypeIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetUniverseTypesTypeIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
     * @summary Bulk names to IDs
     * @param names The names to resolve
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request options.
     */
    public postUniverseIds (names: Array<string>, acceptLanguage?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', datasource?: 'tranquility', language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko', options: any = {}) : Promise<{ response: http.ClientResponse; body: PostUniverseIdsOk;  }> {
        const localVarPath = this.basePath + '/universe/ids/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'names' is not null or undefined
        if (names === null || names === undefined) {
            throw new Error('Required parameter names was null or undefined when calling postUniverseIds.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko'");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(names, "Array<string>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostUniverseIdsOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostUniverseIdsOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/` 
     * @summary Get names and categories for a set of IDs
     * @param ids The ids to resolve
     * @param datasource The server name you would like data from
     * @param {*} [options] Override http request options.
     */
    public postUniverseNames (ids: Array<number>, datasource?: 'tranquility', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PostUniverseNames200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/names/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ids' is not null or undefined
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling postUniverseNames.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(ids, "Array<number>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostUniverseNames200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PostUniverseNames200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserInterfaceApiApiKeys {
}

export class UserInterfaceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserInterfaceApiApiKeys, value: string) {
        (this.authentications as any)[UserInterfaceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
     * @summary Set Autopilot Waypoint
     * @param addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param destinationId The destination to travel to, can be solar system, station or structure&#39;s id
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postUiAutopilotWaypoint (addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/autopilot/waypoint/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'addToBeginning' is not null or undefined
        if (addToBeginning === null || addToBeginning === undefined) {
            throw new Error('Required parameter addToBeginning was null or undefined when calling postUiAutopilotWaypoint.');
        }

        // verify required parameter 'clearOtherWaypoints' is not null or undefined
        if (clearOtherWaypoints === null || clearOtherWaypoints === undefined) {
            throw new Error('Required parameter clearOtherWaypoints was null or undefined when calling postUiAutopilotWaypoint.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling postUiAutopilotWaypoint.');
        }

        if (addToBeginning !== undefined) {
            localVarQueryParameters['add_to_beginning'] = ObjectSerializer.serialize(addToBeginning, "boolean");
        }

        if (clearOtherWaypoints !== undefined) {
            localVarQueryParameters['clear_other_waypoints'] = ObjectSerializer.serialize(clearOtherWaypoints, "boolean");
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (destinationId !== undefined) {
            localVarQueryParameters['destination_id'] = ObjectSerializer.serialize(destinationId, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
     * @summary Open Contract Window
     * @param contractId The contract to open
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postUiOpenwindowContract (contractId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/contract/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling postUiOpenwindowContract.');
        }

        if (contractId !== undefined) {
            localVarQueryParameters['contract_id'] = ObjectSerializer.serialize(contractId, "number");
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
     * @summary Open Information Window
     * @param targetId The target to open
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postUiOpenwindowInformation (targetId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/information/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'targetId' is not null or undefined
        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling postUiOpenwindowInformation.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (targetId !== undefined) {
            localVarQueryParameters['target_id'] = ObjectSerializer.serialize(targetId, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
     * @summary Open Market Details
     * @param typeId The item type to open in market window
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postUiOpenwindowMarketdetails (typeId: number, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/marketdetails/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling postUiOpenwindowMarketdetails.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (typeId !== undefined) {
            localVarQueryParameters['type_id'] = ObjectSerializer.serialize(typeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
     * @summary Open New Mail Window
     * @param newMail The details of mail to create
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public postUiOpenwindowNewmail (newMail: PostUiOpenwindowNewmailNewMail, datasource?: 'tranquility', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/newmail/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'newMail' is not null or undefined
        if (newMail === null || newMail === undefined) {
            throw new Error('Required parameter newMail was null or undefined when calling postUiOpenwindowNewmail.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newMail, "PostUiOpenwindowNewmailNewMail")
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WalletApiApiKeys {
}

export class WalletApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WalletApiApiKeys, value: string) {
        (this.authentications as any)[WalletApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Returns a character's wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds
     * @summary Get a character's wallet balance
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdWallet (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/wallet/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdWallet.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the given character's wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
     * @summary Get character wallet journal
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdWalletJournal (characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletJournal200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/wallet/journal/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdWalletJournal.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletJournal200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdWalletJournal200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
     * @summary Get wallet transactions
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param fromId Only show transactions happened before the one referenced by this id
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCharactersCharacterIdWalletTransactions (characterId: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletTransactions200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/wallet/transactions/'
            .replace('{' + 'character_id' + '}', encodeURIComponent(String(characterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdWalletTransactions.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (fromId !== undefined) {
            localVarQueryParameters['from_id'] = ObjectSerializer.serialize(fromId, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletTransactions200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCharactersCharacterIdWalletTransactions200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a corporation's wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Returns a corporation's wallet balance
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdWallets (corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWallets200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/wallets/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWallets.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWallets200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdWallets200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the given corporation's wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Get corporation wallet journal
     * @param corporationId An EVE corporation ID
     * @param division Wallet key of the division to fetch journals from
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdWalletsDivisionJournal (corporationId: number, division: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/wallets/{division}/journal/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)))
            .replace('{' + 'division' + '}', encodeURIComponent(String(division)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWalletsDivisionJournal.');
        }

        // verify required parameter 'division' is not null or undefined
        if (division === null || division === undefined) {
            throw new Error('Required parameter division was null or undefined when calling getCorporationsCorporationIdWalletsDivisionJournal.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Get corporation wallet transactions
     * @param corporationId An EVE corporation ID
     * @param division Wallet key of the division to fetch journals from
     * @param datasource The server name you would like data from
     * @param fromId Only show journal entries happened before the transaction referenced by this id
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param {*} [options] Override http request options.
     */
    public getCorporationsCorporationIdWalletsDivisionTransactions (corporationId: number, division: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/wallets/{division}/transactions/'
            .replace('{' + 'corporation_id' + '}', encodeURIComponent(String(corporationId)))
            .replace('{' + 'division' + '}', encodeURIComponent(String(division)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWalletsDivisionTransactions.');
        }

        // verify required parameter 'division' is not null or undefined
        if (division === null || division === undefined) {
            throw new Error('Required parameter division was null or undefined when calling getCorporationsCorporationIdWalletsDivisionTransactions.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (fromId !== undefined) {
            localVarQueryParameters['from_id'] = ObjectSerializer.serialize(fromId, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WarsApiApiKeys {
}

export class WarsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WarsApiApiKeys, value: string) {
        (this.authentications as any)[WarsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
     * @summary List wars
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param maxWarId Only return wars with ID smaller than this
     * @param {*} [options] Override http request options.
     */
    public getWars (datasource?: 'tranquility', ifNoneMatch?: string, maxWarId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/wars/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (maxWarId !== undefined) {
            localVarQueryParameters['max_war_id'] = ObjectSerializer.serialize(maxWarId, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<number>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get war information
     * @param warId ID for a war
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request options.
     */
    public getWarsWarId (warId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetWarsWarIdOk;  }> {
        const localVarPath = this.basePath + '/wars/{war_id}/'
            .replace('{' + 'war_id' + '}', encodeURIComponent(String(warId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'warId' is not null or undefined
        if (warId === null || warId === undefined) {
            throw new Error('Required parameter warId was null or undefined when calling getWarsWarId.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetWarsWarIdOk;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetWarsWarIdOk");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
     * @summary List kills for a war
     * @param warId A valid war ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param {*} [options] Override http request options.
     */
    public getWarsWarIdKillmails (warId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<GetWarsWarIdKillmails200Ok>;  }> {
        const localVarPath = this.basePath + '/wars/{war_id}/killmails/'
            .replace('{' + 'war_id' + '}', encodeURIComponent(String(warId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'warId' is not null or undefined
        if (warId === null || warId === undefined) {
            throw new Error('Required parameter warId was null or undefined when calling getWarsWarIdKillmails.');
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "'tranquility'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['If-None-Match'] = ObjectSerializer.serialize(ifNoneMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetWarsWarIdKillmails200Ok>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GetWarsWarIdKillmails200Ok>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
